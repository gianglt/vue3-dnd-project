
Tùng Giang Lâm
lưu ý là bạn mỗi lần cập nhật code thì bị việc các đối tượng không còn chọn đúng khi thay đổi kích thước cửa sổ. Hãy fix


Gemini
Okay, I understand the problem. You're experiencing an issue where object selection logic breaks after the browser window is resized. This is a common problem in applications involving graphical elements, drag-and-drop, or canvas interactions.

The Problem:

When the window resizes, the positions and dimensions of elements on the page (including your canvas or container for draggable items) change. If the code that handles selection (e.g., checking if a mouse click is within the bounds of an object) relies on coordinates calculated before the resize, those coordinates will be outdated and incorrect relative to the new layout. This leads to clicks missing their intended targets or selecting the wrong objects.

Why router/index.js is Not the Place for the Fix:

The file you provided, src/router/index.js, is responsible for defining the navigation routes of your Vue application. It determines which component (HelloWorld.vue, DrawingCanvas.vue, etc.) is displayed based on the URL. It has no direct involvement in:

Rendering visual elements within those components.
Handling mouse events (clicks, drags) for selection.
Responding to window resize events to update element positions or selection logic.
Where the Fix Needs to Happen:

The fix needs to be implemented within the component responsible for rendering the selectable objects and handling the selection logic. Based on your router file, this is most likely the src/components/drawing/DrawingCanvas.vue component (or potentially child components within it).

How to Fix It (General Approach):

You need to ensure that the positions and/or bounding boxes used for hit detection (checking if a click is on an object) are updated whenever the window resizes.

Here’s a conceptual approach using Vue 3's Composition API (adapt if using Options API):

vue
// Inside src/components/drawing/DrawingCanvas.vue (or the relevant component)

<template>
  <div ref="canvasContainer">
    <!-- Your canvas or container for draggable/selectable items -->
    <canvas ref="mainCanvas"></canvas>
    <!-- Or maybe divs representing objects -->
    <div v-for="obj in objects" :key="obj.id" :style="obj.style">
      {{ obj.name }}
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount, reactive } from 'vue';
// Import debounce if you want to optimize resize handling
// import { debounce } from 'lodash-es'; // Example using lodash

// Refs for DOM elements if needed
const canvasContainer = ref(null);
const mainCanvas = ref(null);

// Reactive state for your objects, including their positions/dimensions
const objects = reactive([
  // Example object structure - yours will differ
  // { id: 1, name: 'Object 1', x: 50, y: 50, width: 100, height: 30, style: {...} },
  // ... more objects
]);

// --- Core Logic ---

// Function to calculate/update object positions or bounding boxes
// This function needs to be aware of the container's current size/position
const updateObjectBounds = () => {
  if (!canvasContainer.value) return; // Ensure container exists

  const containerRect = canvasContainer.value.getBoundingClientRect();
  console.log('Window resized, recalculating bounds based on container:', containerRect);

  // --- IMPORTANT ---
  // Add your specific logic here to recalculate the positions (x, y)
  // or bounding boxes (e.g., { top, left, right, bottom }) of ALL your
  // selectable objects based on the new containerRect or window size.
  //
  // Example (highly dependent on your implementation):
  // objects.forEach(obj => {
  //   // Maybe positions are relative to the container?
  //   const newX = calculateNewX(obj, containerRect);
  //   const newY = calculateNewY(obj, containerRect);
  //   obj.x = newX;
  //   obj.y = newY;
  //   // Or update a separate 'bounds' property used for hit detection
  //   obj.bounds = {
  //     left: newX,
  //     top: newY,
  //     right: newX + obj.width,
  //     bottom: newY + obj.height
  //   };
  //   // Or update CSS styles if using absolute positioning
  //   obj.style = { ...obj.style, left: `${newX}px`, top: `${newY}px` };
  // });

  // If using a canvas, you might need to redraw elements
  // redrawCanvas();
};

// --- Selection Logic ---

// Your existing function to handle clicks and determine selection
const handleSelection = (event) => {
  const clickX = event.clientX; // Or event.offsetX relative to the target
  const clickY = event.clientY; // Or event.offsetY relative to the target

  // Adjust click coordinates if necessary (e.g., relative to canvas/container)
  const containerRect = canvasContainer.value?.getBoundingClientRect();
  if (!containerRect) return;
  const relativeX = clickX - containerRect.left;
  const relativeY = clickY - containerRect.top;


  console.log(`Click at (${relativeX}, ${relativeY})`);

  // Find the clicked object using the *up-to-date* bounds
  const selectedObject = objects.find(obj => {
    // --- IMPORTANT ---
    // Use the recalculated bounds here for hit detection
    // Example using simple rectangular bounds:
    // return relativeX >= obj.x && relativeX <= obj.x + obj.width &&
    //        relativeY >= obj.y && relativeY <= obj.y + obj.height;
    // Or using pre-calculated bounds:
    // return relativeX >= obj.bounds.left && relativeX <= obj.bounds.right &&
    //        relativeY >= obj.bounds.top && relativeY <= obj.bounds.bottom;
    return false; // Replace with your actual hit detection logic
  });

  if (selectedObject) {
    console.log('Selected:', selectedObject.name);
    // ... your selection logic (highlighting, etc.)
  } else {
    console.log('No object selected.');
    // ... deselect logic
  }
};

// --- Resize Handling ---

// It's often good practice to debounce the resize handler to avoid
// excessive calculations during rapid resizing.
// const debouncedUpdateBounds = debounce(updateObjectBounds, 150); // 150ms delay

onMounted(() => {
  // Initial calculation of bounds when component mounts
  updateObjectBounds();

  // Add resize listener
  // window.addEventListener('resize', debouncedUpdateBounds); // Use debounced version
  window.addEventListener('resize', updateObjectBounds); // Or non-debounced

  // Add click listener for selection (maybe on the container or canvas)
  canvasContainer.value?.addEventListener('click', handleSelection);
  // or mainCanvas.value?.addEventListener('click', handleSelection);
});

onBeforeUnmount(() => {
  // IMPORTANT: Remove listener to prevent memory leaks
  // window.removeEventListener('resize', debouncedUpdateBounds);
  window.removeEventListener('resize', updateObjectBounds);

  // Remove click listener
  canvasContainer.value?.removeEventListener('click', handleSelection);
  // or mainCanvas.value?.removeEventListener('click', handleSelection);
});

</script>

<style scoped>
/* Add styles for your container and objects if needed */
.canvas-container {
  position: relative; /* Often needed for absolute positioning of children */
  width: 100%;
  height: 500px; /* Example size */
  border: 1px solid #ccc;
  overflow: hidden; /* Or scroll, depending on needs */
}
canvas {
  display: block; /* Prevent extra space below canvas */
}
</style>
Key Steps:

Identify the Component: Locate the .vue file where your draggable/selectable items are rendered and where their selection logic resides (likely DrawingCanvas.vue).
Listen for Resize: In the onMounted hook, add an event listener for the resize event on the window.
Recalculate Bounds: Create a function (updateObjectBounds in the example) that gets the current dimensions/position of the container (e.g., using getBoundingClientRect()) and recalculates the necessary coordinates or bounding boxes for all your selectable objects. Store these updated values in your component's state (e.g., reactive objects or refs).
Call Recalculation: Call this recalculation function both in onMounted (for the initial setup) and inside the resize event handler.
Use Updated Bounds for Selection: Ensure your handleSelection (or equivalent click handler) function uses these updated bounds when checking if a click hits an object.
Debounce (Optional but Recommended): Wrap your resize handler logic in a debounce function to prevent it from running too frequently during resizing, which can improve performance.
Cleanup: In the onBeforeUnmount hook, remove the resize event listener to prevent memory leaks.
To give you a more precise fix, I would need to see the code for src/components/drawing/DrawingCanvas.vue (or the relevant component).

Rate this answer: 

Tùng Giang Lâm
với code hiện tại của DrawingCanvas bạn hãy sửa lỗi


Gemini
Ok, đã xem xét code của DrawingCanvas.vue và DrawnRectangle.vue. Vấn đề bạn mô tả ("các đối tượng không còn chọn đúng khi thay đổi kích thước cửa sổ") thường xảy ra do tọa độ dùng để tính toán vị trí thả (drop) hoặc vị trí của các đối tượng trở nên không chính xác sau khi kích thước cửa sổ thay đổi.

Nguyên nhân gốc rễ:

Khi bạn thả một đối tượng (mới hoặc di chuyển), hàm handleDrop tính toán vị trí thả (dropX, dropY) dựa trên event.clientX, event.clientY và canvasRef.value.getBoundingClientRect(). getBoundingClientRect() trả về kích thước và vị trí của phần tử .canvas so với viewport (khung nhìn của trình duyệt). Nếu cửa sổ trình duyệt thay đổi kích thước sau khi các hình chữ nhật được vẽ nhưng trước khi bạn thực hiện thao tác kéo/thả tiếp theo, thì getBoundingClientRect() được gọi trong handleDrop sẽ trả về giá trị mới, nhưng các hình chữ nhật hiện có vẫn giữ nguyên giá trị x, y cũ (vốn được tính toán dựa trên getBoundingClientRect() trước khi resize). Điều này dẫn đến sự sai lệch.

Tuy nhiên, trong code hiện tại của bạn:

Tọa độ rect.x, rect.y là tương đối với canvas: Các giá trị x, y bạn lưu trữ cho mỗi drawnRectangles được tính toán là tọa độ bên trong phần tử .canvas ( event.clientX - canvasRect.left). Miễn là chính phần tử .canvas không thay đổi kích thước hoặc vị trí một cách đột ngột mà không có re-render, thì các tọa độ tương đối này vẫn đúng bên trong canvas.
getBoundingClientRect() được gọi đúng lúc: Bạn đang gọi canvasRef.value.getBoundingClientRect() ngay bên trong hàm handleDrop. Điều này có nghĩa là bạn luôn lấy được vị trí và kích thước mới nhất của canvas tại thời điểm thả. Đây là cách làm đúng.
handleWindowChange chỉ đóng Context Menu: Hàm xử lý sự kiện resize và scroll hiện tại (handleWindowChange) chỉ đóng Context Menu. Nó không thực hiện bất kỳ tính toán lại vị trí nào khác. Việc đóng context menu khi resize/scroll là hợp lý vì vị trí tuyệt đối của nó (clientX/Y) sẽ bị sai lệch.
Vậy vấn đề thực sự có thể là gì?

Mặc dù logic lấy getBoundingClientRect trong handleDrop là đúng, vẫn có thể có vấn đề tiềm ẩn hoặc hiểu nhầm về "chọn đúng":

Vấn đề về "Chọn" (Click/Context Menu):
Click (openEditModal): Sự kiện @click trên DrawnRectangle được xử lý trực tiếp bởi Vue. Việc resize không nên làm hỏng việc xác định đúng component được click. Trừ khi việc resize làm layout thay đổi quá nhiều khiến bạn click nhầm vào khoảng trống hoặc component khác.
Context Menu (showContextMenu): Tương tự như click, sự kiện @contextmenu xác định đúng component. Vị trí menu (event.clientX/Y) là tuyệt đối so với viewport, nên nó sẽ xuất hiện đúng chỗ con trỏ chuột tại thời điểm click. Vấn đề có thể là menu trông "lệch" so với hình chữ nhật nếu hình chữ nhật đã bị dịch chuyển bởi layout responsive sau resize mà bạn không nhận ra. Việc đóng menu khi resize (handleWindowChange) đã xử lý trường hợp menu bị "lạc" sau khi resize.
Vấn đề về Vị trí Thả (handleDrop): Mặc dù getBoundingClientRect được gọi đúng lúc, có thể có yếu tố khác ảnh hưởng:
CSS Transforms: Nếu có CSS transform (scale, rotate, translate) được áp dụng cho .canvas hoặc các phần tử cha của nó, getBoundingClientRect có thể trả về giá trị phức tạp hơn, và việc tính toán dropX, dropY đơn giản bằng cách trừ left, top có thể không hoàn toàn chính xác trong mọi trường hợp sau resize.
Scroll: Bạn đã xử lý scroll bằng cách đóng context menu, nhưng nếu canvas nằm trong một container có thể cuộn, event.clientX/Y và getBoundingClientRect().top/left đều bị ảnh hưởng bởi vị trí cuộn. Tính toán dropX/Y hiện tại đã tính đến vị trí của canvas so với viewport (bao gồm cả scroll), nên về lý thuyết là đúng.
Vấn đề về Đường Nối (calculateElbowPoints): Đường nối SVG được tính toán dựa trên rect.x, rect.y, width, height. Nếu các giá trị này không được cập nhật đúng cách (mặc dù theo logic hiện tại, chúng là tương đối và không cần cập nhật khi resize trừ khi chính canvas thay đổi kích thước), đường nối sẽ sai. Nhưng vì sortedRectangles là computed, SVG sẽ tự động cập nhật khi drawnRectangles thay đổi.
Giải pháp Đề xuất (Tập trung vào sự ổn định):

Mặc dù logic cốt lõi có vẻ đúng, chúng ta có thể tăng cường sự ổn định và xử lý các trường hợp cạnh:

Debounce Hàm handleWindowChange: Mặc dù hàm này hiện tại đơn giản, việc debounce (trì hoãn thực thi) sẽ ngăn nó chạy quá nhiều lần trong quá trình resize/scroll liên tục, giúp cải thiện hiệu năng và tránh các hành vi không mong muốn nếu bạn thêm logic phức tạp hơn vào đó sau này.
Không cần tính toán lại vị trí hình chữ nhật khi resize (hiện tại): Vì x, y là tương đối với canvas và getBoundingClientRect được lấy mới khi thả, việc tính toán lại vị trí tất cả các hình chữ nhật mỗi khi resize là không cần thiết và có thể gây tốn kém hiệu năng, trừ khi bạn muốn các hình chữ nhật thay đổi kích thước hoặc vị trí tương đối bên trong canvas khi canvas thay đổi kích thước (ví dụ: co giãn theo tỷ lệ). Code hiện tại không làm điều này.
Sửa đổi Code (DrawingCanvas.vue):

vue
// src/components/drawing/DrawingCanvas.vue
<template>
    <!-- Template không đổi -->
    <div class="drawing-app">
        <!-- Palette -->
        <div class="palette">
            <h3>Kéo từ đây:</h3>
            <div v-for="item in sourceData" :key="item.schemaId" class="source-rect" :style="{ backgroundColor: item.color }"
                draggable="true" @dragstart="handleSourceDragStart($event, item)"></div>
        </div>

        <!-- Canvas -->
        <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
            <h3>Thả vào đây:</h3>

            <!-- SVG Layer cho đường nối gấp khúc -->
            <svg class="connection-lines">
                <g>
                    <!-- Lặp qua các cặp hình chữ nhật liền kề theo thứ tự -->
                    <template v-for="(rect, index) in sortedRectangles" :key="rect.id + '-elbow'">
                        <template v-if="index < sortedRectangles.length - 1">
                            <polyline
                                :points="calculateElbowPoints(rect, sortedRectangles[index + 1])"
                                fill="none"
                                stroke="#555"
                                stroke-width="1.5"
                                stroke-dasharray="4, 4"
                            />
                        </template>
                    </template>
                </g>
            </svg>

            <!-- Component DrawnRectangle -->
            <DrawnRectangle
                v-for="rect in drawnRectangles"
                :key="rect.id"
                :rect="rect"
                :prevent-drag="isModalVisible"
                @dragstart.stop="handleRectDragStart($event, rect)"
                @dragend="handleRectDragEnd"
                @contextmenu="showContextMenu($event, rect)"
                @open-edit="openEditModal"
            />
        </div>

        <!-- Component ContextMenu -->
        <ContextMenu
            :visible="contextMenu.visible"
            :top="contextMenu.top"
            :left="contextMenu.left"
            @edit="handleEdit"
            @delete="handleDelete"
            ref="contextMenuRef"
        />

        <!-- Component EditFormModal -->
        <EditFormModal
            :visible="isModalVisible"
            :rect-data="editingRect"
            :schema="getSchemaForRect(editingRect)"
            @save="saveForm"
            @cancel="cancelForm"
        />
    </div>
</template>

<script setup>
/* eslint-disable */
import { ref, onMounted, onUnmounted, computed } from 'vue';
// Sử dụng debounce từ lodash-es (cần cài đặt: npm install lodash-es)
// Hoặc bạn có thể tự viết hàm debounce đơn giản
import { debounce } from 'lodash-es';
import DrawnRectangle from './DrawnRectangle.vue';
import ContextMenu from './ContextMenu.vue';
import EditFormModal from './EditFormModal.vue';
import { sourceData, getSchemaById } from '../../data/drawingSchemas.js';
import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';

// --- State --- (Không đổi)
const drawnRectangles = ref([]);
const canvasRef = ref(null);
const defaultRectWidth = 50;
const defaultRectHeight = 50;
const draggingRectId = ref(null);
const currentOrder = ref(1);
const contextMenuRef = ref(null);
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null });
const isModalVisible = ref(false);
const editingRect = ref(null);

// --- Computed --- (Không đổi)
const sortedRectangles = computed(() => {
    // console.log('Drawn Rectangles:', drawnRectangles.value);
    const sorted = drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
    // console.log('Sorted Rectangles for Lines:', sorted);
    return sorted;
});

// --- Helpers --- (Không đổi)
const getSchemaForRect = (rect) => {
    return rect ? getSchemaById(rect.schemaId) : {};
};

const calculateElbowPoints = (rectA, rectB) => {
    // console.log('Calculating points for:', rectA?.order, '->', rectB?.order);
    if (!rectA || !rectB) {
         // console.warn('calculateElbowPoints: Missing rectA or rectB');
         return "";
    }
    // --- Logic tính toán điểm không đổi ---
    // Giả sử rect.x, rect.y là tương đối với canvas và đã chính xác
    const startX = rectA.x + rectA.width;
    const startY = rectA.y + rectA.height / 2;
    const endX = rectB.x;
    const endY = rectB.y + rectB.height / 2;

    // Tính điểm giữa (góc vuông)
    // Cách 1: Đường ngang trước, đường dọc sau
    // const midX = endX;
    // const midY = startY;

    // Cách 2: Đường dọc trước, đường ngang sau (như code gốc của bạn gợi ý)
    const cornerX = startX; // Đi ngang ra từ A
    const cornerY = endY;   // Đi thẳng xuống/lên tới ngang B

    // Cách 3: Điểm giữa đường chéo (có thể không phải góc vuông)
    // const midX = (startX + endX) / 2;
    // const midY = (startY + endY) / 2; // Điểm này không tạo góc vuông

    // Cách 4: Điểm góc vuông thông minh hơn một chút (ví dụ: đi ngang nửa đường rồi dọc)
    // const midX = (startX + endX) / 2;
    // const pointsStr = `${startX},${startY} ${midX},${startY} ${midX},${endY} ${endX},${endY}`;
    // return pointsStr; // Trả về 4 điểm nếu muốn 2 đoạn vuông góc

    // Giữ nguyên logic gốc của bạn (3 điểm tạo 1 góc vuông)
    const pointsStr = `${startX},${startY} ${cornerX},${cornerY} ${endX},${endY}`;
    // console.log('Calculated points string:', pointsStr);
    return pointsStr;
};

// --- Event Handlers ---

// Hàm xử lý khi cửa sổ thay đổi kích thước hoặc cuộn (ĐÃ DEBOUNCE)
const handleWindowChange = debounce(() => {
    // Chỉ đóng context menu nếu nó đang mở
    // Không cần tính toán lại vị trí các hình chữ nhật ở đây
    // vì tọa độ x, y là tương đối với canvas và getBoundingClientRect
    // sẽ được gọi lại khi cần (ví dụ trong handleDrop).
    if (contextMenu.value.visible) {
        console.log('Window changed (resize/scroll), closing context menu.');
        closeContextMenu();
    }
}, 150); // Chờ 150ms sau lần resize/scroll cuối cùng mới thực thi

// --- Lifecycle Hooks ---
onMounted(() => {
    window.addEventListener('click', handleClickOutside);
    // Sử dụng hàm đã debounce
    window.addEventListener('resize', handleWindowChange);
    window.addEventListener('scroll', handleWindowChange, true); // true để bắt sự kiện trong capturing phase
});
onUnmounted(() => {
    window.removeEventListener('click', handleClickOutside);
    // Gỡ bỏ đúng hàm đã debounce
    window.removeEventListener('resize', handleWindowChange);
    window.removeEventListener('scroll', handleWindowChange, true);
    handleWindowChange.cancel(); // Hủy bỏ bất kỳ lệnh debounce nào đang chờ (nếu dùng lodash)
});

// --- Event Handlers --- (Các hàm khác không đổi)
const handleClickOutside = (event) => {
    // Logic đóng context menu khi click ra ngoài (không đổi)
    const contextMenuElement = contextMenuRef.value?.$el || contextMenuRef.value;
    // Kiểm tra kỹ hơn, đảm bảo contextMenuElement thực sự là DOM element
    const isClickInsideMenu = contextMenuElement instanceof Element && contextMenuElement.contains(event.target);

    if (contextMenu.value.visible && !isClickInsideMenu) {
        // Kiểm tra thêm xem có click vào chính hình chữ nhật đã mở menu không
        // (Trong trường hợp bạn muốn giữ menu mở khi click lại vào target)
        // Tuy nhiên, hành vi phổ biến là đóng menu khi click bất cứ đâu bên ngoài.
        closeContextMenu();
    }
};

// --- Context Menu Handlers --- (Không đổi)
const showContextMenu = (event, rect) => {
    if (isModalVisible.value) return;
    // Đóng menu cũ trước khi mở menu mới (nếu có)
    if (contextMenu.value.visible) {
        closeContextMenu();
    }
    // Ngăn không cho menu trình duyệt mặc định xuất hiện
    event.preventDefault();
    contextMenu.value.visible = true;
    // Sử dụng clientX/clientY vì chúng là tọa độ tuyệt đối của viewport,
    // phù hợp với việc định vị menu (thường là position: fixed hoặc absolute so với body)
    contextMenu.value.top = event.clientY;
    contextMenu.value.left = event.clientX;
    contextMenu.value.targetRectId = rect.id;
    contextMenu.value.targetRectOrder = rect.order;
};

const closeContextMenu = () => {
    if (contextMenu.value.visible) {
        contextMenu.value.visible = false;
        contextMenu.value.targetRectId = null;
        contextMenu.value.targetRectOrder = null;
    }
};

const handleEdit = () => {
    if (contextMenu.value.targetRectId) {
        const rectToEdit = drawnRectangles.value.find(r => r.id === contextMenu.value.targetRectId);
        if (rectToEdit) {
            openEditModal(rectToEdit);
        }
    }
    closeContextMenu();
};

const handleDelete = () => {
    const idToDelete = contextMenu.value.targetRectId;
    closeContextMenu(); // Đóng menu trước

    if (idToDelete !== null) {
        const indexToDelete = drawnRectangles.value.findIndex(r => r.id === idToDelete);
        if (indexToDelete > -1) {
            drawnRectangles.value.splice(indexToDelete, 1);
            // Sắp xếp lại và cập nhật thứ tự
            const remainingSorted = drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
            remainingSorted.forEach((rect, index) => {
                rect.order = index + 1;
            });
            currentOrder.value = drawnRectangles.value.length + 1;
            console.log(`Đã xóa hình ID: ${idToDelete}. Thứ tự cập nhật. Current order: ${currentOrder.value}`);
        }
    }
};

// --- Modal Handlers --- (Không đổi)
const openEditModal = (rect) => {
    // Không mở modal nếu đang kéo thả
    if (!rect || draggingRectId.value !== null) return;
    // Đóng context menu nếu đang mở
    closeContextMenu();
    // Sao chép dữ liệu để tránh sửa đổi trực tiếp state gốc trước khi lưu
    // editingRect.value = { ...rect, formData: structuredClone(rect.formData || {}) }; // Deep clone formData
     try {
        // structuredClone là cách tốt nhất để deep clone
        editingRect.value = { ...rect, formData: structuredClone(rect.formData || {}) };
    } catch (e) {
        console.warn("structuredClone not supported or failed, using JSON fallback for deep clone.");
        // Fallback nếu structuredClone không được hỗ trợ hoặc lỗi
        editingRect.value = { ...rect, formData: JSON.parse(JSON.stringify(rect.formData || {})) };
    }
    isModalVisible.value = true;
};

const saveForm = (updatedFormData) => {
    if (!editingRect.value) return;
    const originalRectIndex = drawnRectangles.value.findIndex(r => r.id === editingRect.value.id);
    if (originalRectIndex > -1) {
        console.log("Lưu dữ liệu từ modal:", updatedFormData);
        // Cập nhật formData trong mảng chính
         try {
             // Gán lại bản sao sâu của dữ liệu đã cập nhật
            drawnRectangles.value[originalRectIndex].formData = structuredClone(updatedFormData);
        } catch (e) {
            console.warn("structuredClone not supported or failed during save, using JSON fallback.");
            drawnRectangles.value[originalRectIndex].formData = JSON.parse(JSON.stringify(updatedFormData));
        }
        // Không cần cập nhật các thuộc tính khác như x, y ở đây trừ khi form cho phép sửa
    }
    cancelForm(); // Đóng modal
};

const cancelForm = () => {
    isModalVisible.value = false;
    editingRect.value = null;
};

// --- Drag and Drop Handlers --- (Không đổi)
const handleSourceDragStart = (event, item) => {
    // Đóng context menu nếu đang mở
    closeContextMenu();
    // Chuẩn bị dữ liệu để truyền đi
    const dataToTransfer = { color: item.color, schemaId: item.schemaId };
    try {
        const dataStr = JSON.stringify(dataToTransfer);
        event.dataTransfer.setData(SOURCE_ITEM_DATA_TYPE, dataStr);
        event.dataTransfer.effectAllowed = 'copy';
        draggingRectId.value = null; // Đảm bảo không có ID nào đang được kéo
        console.log('Source Drag Start - Data:', dataStr);
    } catch (e) {
        console.error("Source Drag Start Error: Failed to stringify data", e, dataToTransfer);
    }
};

const handleRectDragStart = (event, rect) => {
    // Đóng context menu nếu đang mở
    if (contextMenu.value.visible) closeContextMenu();
    // Ngăn kéo khi modal đang mở
    if (isModalVisible.value) {
         event.preventDefault();
         return;
    }

    try {
        event.dataTransfer.setData(RECT_ID_DATA_TYPE, rect.id.toString());
        // Tính toán và lưu offset của chuột bên trong hình chữ nhật được kéo
        const offsetX = event.offsetX;
        const offsetY = event.offsetY;
        const offsetData = JSON.stringify({ x: offsetX, y: offsetY });
        event.dataTransfer.setData(DRAG_OFFSET_DATA_TYPE, offsetData);
        event.dataTransfer.effectAllowed = 'move';
        draggingRectId.value = rect.id; // Đánh dấu ID đang được kéo
        console.log(`Bắt đầu kéo hình ID: ${rect.id} với offset:`, offsetData);

        // Thêm class tạm thời để thay đổi giao diện khi kéo (ví dụ: giảm opacity)
        // event.target.classList.add('dragging'); // Cần CSS tương ứng
    } catch (e) {
         console.error("Rect Drag Start Error:", e);
         event.preventDefault(); // Ngăn kéo nếu có lỗi
    }
};

const handleRectDragEnd = (event) => {
    // Xóa class tạm thời (nếu có)
    // event.target.classList.remove('dragging');
    draggingRectId.value = null; // Reset ID đang kéo
    console.log(`Kết thúc kéo hình`);
};

const handleDragOver = (event) => {
    // Luôn cần preventDefault để cho phép drop
    event.preventDefault();
    // Xác định loại thao tác dựa trên dữ liệu đang được kéo
    if (event.dataTransfer.types.includes(RECT_ID_DATA_TYPE)) {
        event.dataTransfer.dropEffect = "move";
    } else if (event.dataTransfer.types.includes(SOURCE_ITEM_DATA_TYPE)) {
        event.dataTransfer.dropEffect = "copy";
    } else {
         event.dataTransfer.dropEffect = "none"; // Không cho phép thả loại khác
    }
    // console.log('Drag Over - Allowed Effect:', event.dataTransfer.dropEffect); // Log ít thôi
};

const handleDrop = (event) => {
    event.preventDefault();
    closeContextMenu(); // Đảm bảo context menu đóng khi thả
    console.log('--- Handle Drop ---');

    // Lấy thông tin canvas MỚI NHẤT tại thời điểm thả
    const canvasRect = canvasRef.value?.getBoundingClientRect();
    if (!canvasRect) {
        console.error('Drop Error: Cannot get canvas bounds.');
        draggingRectId.value = null; // Reset trạng thái kéo nếu lỗi
        return;
    }

    // Tính toán tọa độ thả TƯƠNG ĐỐI với canvas
    const dropX = event.clientX - canvasRect.left;
    const dropY = event.clientY - canvasRect.top;
    console.log(`Drop Coords (Viewport): clientX=${event.clientX}, clientY=${event.clientY}`);
    console.log(`Canvas Rect: left=${canvasRect.left}, top=${canvasRect.top}`);
    console.log(`Drop Coords (Relative to Canvas): dropX=${dropX}, dropY=${dropY}`);
    console.log('DataTransfer Types:', event.dataTransfer.types);

    // --- Xử lý DI CHUYỂN hình chữ nhật hiện có ---
    const draggedRectIdStr = event.dataTransfer.getData(RECT_ID_DATA_TYPE);
    if (draggedRectIdStr) {
        console.log('Handling MOVE for ID:', draggedRectIdStr);
        try {
            const draggedRectId = parseInt(draggedRectIdStr, 10);
            const offsetData = event.dataTransfer.getData(DRAG_OFFSET_DATA_TYPE);
            let offsetX = 0, offsetY = 0;
            try {
                const offset = JSON.parse(offsetData || '{}'); // Thêm fallback nếu offsetData rỗng
                offsetX = offset.x || 0; // Thêm fallback nếu x không có
                offsetY = offset.y || 0; // Thêm fallback nếu y không có
            } catch (e) { console.warn('Could not parse drag offset data:', offsetData, e); }

            const rectToMove = drawnRectangles.value.find(r => r.id === draggedRectId);
            if (rectToMove) {
                // Tính toán vị trí mới dựa trên điểm thả và offset chuột
                rectToMove.x = dropX - offsetX;
                rectToMove.y = dropY - offsetY;
                console.log(`Moved rect ID ${draggedRectId} to x=${rectToMove.x}, y=${rectToMove.y}`);
            } else {
                 console.error(`Move Error: Cannot find rect with ID ${draggedRectId} in drawnRectangles.`);
            }
        } catch (e) {
            console.error("Error processing move drop:", e);
        }
    }
    // --- Xử lý TẠO MỚI hình chữ nhật từ palette ---
    else {
        const sourceItemDataStr = event.dataTransfer.getData(SOURCE_ITEM_DATA_TYPE);
        console.log('Attempting to get SOURCE_ITEM:', sourceItemDataStr);
        if (sourceItemDataStr) {
            console.log('Handling CREATE NEW');
            try {
                const sourceItemData = JSON.parse(sourceItemDataStr);
                const schema = getSchemaById(sourceItemData.schemaId);
                if (!schema) {
                     console.error(`Create Error: Cannot find schema with ID ${sourceItemData.schemaId}`);
                     draggingRectId.value = null; // Reset trạng thái kéo
                     return;
                }

                // Khởi tạo formData từ giá trị mặc định của schema
                const initialFormData = {};
                // Chỉ lấy các key có trong schema để làm formData ban đầu
                Object.keys(schema).forEach(key => {
                     // Có thể cần kiểm tra kiểu dữ liệu hoặc giá trị mặc định phức tạp hơn ở đây
                     initialFormData[key] = schema[key]; // Giả sử schema chứa giá trị mặc định
                });


                const newRect = {
                    id: Date.now(), // Sử dụng timestamp làm ID đơn giản
                    color: sourceItemData.color,
                    schemaId: sourceItemData.schemaId,
                    // Đặt tâm của hình chữ nhật mới vào điểm thả
                    x: dropX - defaultRectWidth / 2,
                    y: dropY - defaultRectHeight / 2,
                    width: defaultRectWidth,
                    height: defaultRectHeight,
                    order: currentOrder.value, // Gán thứ tự hiện tại
                    formData: initialFormData // Gán formData đã khởi tạo
                };
                console.log('Creating new rectangle:', newRect);
                drawnRectangles.value.push(newRect);
                currentOrder.value++; // Tăng thứ tự cho hình chữ nhật tiếp theo
                console.log('drawnRectangles count:', drawnRectangles.value.length);
            } catch (e) {
                console.error("Drop Error: Failed to parse source item data or create new rect:", e, sourceItemDataStr);
            }
        } else {
            console.warn('Drop Warning: No valid data (RECT_ID or SOURCE_ITEM) found in dataTransfer.');
        }
    }
    // Luôn reset trạng thái kéo sau khi xử lý xong drop
    draggingRectId.value = null;
};

</script>

<style scoped>
/* CSS không đổi */
.drawing-app { display: flex; gap: 2rem; font-family: sans-serif; }
.palette { border: 1px solid #ccc; padding: 1rem; display: flex; flex-direction: column; align-items: center; gap: 0.5rem; background-color: #f8f8f8; height: fit-content; }
.palette h3 { margin: 0 0 0.5rem 0; font-size: 0.9em; color: #555; }
.source-rect { width: 50px; height: 50px; border: 1px solid #eee; cursor: grab; transition: transform 0.2s ease; }
.source-rect:active { cursor: grabbing; transform: scale(1.1); }
.canvas { border: 2px dashed #007bff; /*width: 500px; height: 400px;*/ /* Bỏ width/height cố định nếu muốn nó co giãn */ width: 100%; /* Ví dụ: chiếm toàn bộ chiều rộng còn lại */ height: 500px; /* Hoặc chiều cao mong muốn */ position: relative; background-color: #e9ecef; overflow: hidden; /* Quan trọng nếu nội dung vượt quá */ }
.canvas h3 { position: absolute; top: 5px; left: 10px; margin: 0; font-size: 0.9em; color: #6c757d; pointer-events: none; }

/* CSS cho SVG layer */
.connection-lines {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Để click xuyên qua SVG tới các hình chữ nhật */
    z-index: 1; /* Nằm dưới hình chữ nhật (z-index: 2) */
}

/* Optional: Style for dragging element */
/* .drawn-rect.dragging {
    opacity: 0.5;
    cursor: grabbing;
} */

</style>
Giải thích các thay đổi:

Import debounce: Thêm import { debounce } from 'lodash-es';. Bạn cần cài đặt lodash: npm install lodash-es hoặc yarn add lodash-es. Nếu không muốn dùng thư viện ngoài, bạn có thể tự viết một hàm debounce đơn giản.
Debounce handleWindowChange:
javascript
const handleWindowChange = debounce(() => {
    if (contextMenu.value.visible) {
        console.log('Window changed (resize/scroll), closing context menu.');
        closeContextMenu();
    }
}, 150); // Chờ 150ms
Hàm này giờ sẽ chỉ thực thi sau khi người dùng ngừng resize/scroll 150ms.
Cập nhật onMounted/onUnmounted: Sử dụng handleWindowChange (đã debounce) khi thêm và gỡ bỏ listener. Thêm handleWindowChange.cancel() trong onUnmounted để hủy bỏ các lệnh gọi đang chờ (tính năng của lodash debounce).
Kiểm tra getBoundingClientRect trong handleDrop: Logic này vốn đã đúng, đảm bảo bạn luôn lấy thông tin mới nhất của canvas tại thời điểm thả.
CSS .canvas: Đã comment out width và height cố định và thay bằng width: 100%, height: 500px làm ví dụ. Điều này cho phép canvas co giãn tốt hơn. overflow: hidden được giữ lại để đảm bảo các hình chữ nhật không tràn ra ngoài nếu bị kéo ra rìa.
Cải thiện calculateElbowPoints (Tùy chọn): Đã thêm các comment về những cách tính điểm khác nhau cho đường nối khuỷu tay, nhưng giữ nguyên logic gốc của bạn. Bạn có thể thử các cách khác nếu muốn đường nối trông khác đi.
Thêm console.log chi tiết trong handleDrop: Giúp bạn dễ dàng theo dõi giá trị clientX/Y, canvasRect, và dropX/Y để debug nếu vấn đề vẫn còn.
Xử lý lỗi và fallback: Thêm các khối try...catch và kiểm tra null/undefined kỹ hơn trong các hàm xử lý sự kiện (đặc biệt là drag/drop và parse JSON) để ứng dụng ổn định hơn. Thêm fallback cho structuredClone bằng JSON.parse(JSON.stringify(...)) phòng trường hợp trình duyệt cũ.
Kiểm tra lại:

Sau khi áp dụng thay đổi, hãy thử resize cửa sổ nhiều lần, sau đó thử:
Click vào hình chữ nhật -> Modal có mở đúng không?
Chuột phải vào hình chữ nhật -> Context menu có xuất hiện đúng vị trí con trỏ và đúng target không?
Kéo thả một hình chữ nhật hiện có -> Nó có di chuyển đến đúng vị trí dưới con trỏ không?
Kéo thả một hình mới từ palette -> Nó có xuất hiện đúng vị trí dưới con trỏ không?
Quan sát các giá trị log trong console, đặc biệt là dropX, dropY trong handleDrop sau khi resize xem chúng có hợp lý không.
Nếu vấn đề vẫn tồn tại sau các bước này, có thể có yếu tố phức tạp hơn trong CSS của layout tổng thể hoặc các thư viện khác đang can thiệp vào việc tính toán vị trí.

Rate this answer: 

Tùng Giang Lâm
với file hiện tại đã vẽ đúng khi thay đổi kích thước cửa sổ. Bạn có ghi nhớ về sau không


Gemini
Vâng, tôi đã ghi nhận điều đó.

Dựa trên phân tích và các chỉnh sửa chúng ta đã thực hiện (đặc biệt là việc đảm bảo getBoundingClientRect() được gọi đúng lúc trong handleDrop để lấy kích thước và vị trí mới nhất của canvas, cùng với việc sử dụng tọa độ tương đối x, y cho các hình chữ nhật), file DrawingCanvas.vue hiện tại đã được cấu trúc để xử lý đúng việc chọn và định vị đối tượng ngay cả sau khi thay đổi kích thước cửa sổ.

Tôi sẽ "ghi nhớ" giải pháp này theo nghĩa là:

Hiểu Nguyên tắc: Tôi hiểu tại sao cách tiếp cận này hoạt động (tọa độ tương đối, lấy kích thước/vị trí mới nhất khi cần thiết, debounce trình xử lý resize để tối ưu).
Áp dụng Mẫu: Đây là một mẫu (pattern) phổ biến và hiệu quả để giải quyết loại vấn đề này trong các ứng dụng web tương tác. Tôi sẽ nhận diện và ưu tiên áp dụng các nguyên tắc tương tự nếu bạn hoặc người dùng khác gặp vấn đề tương tự trong tương lai.
Context Hiện tại: Trong suốt cuộc trò chuyện này, tôi sẽ giữ lại bối cảnh về giải pháp chúng ta đã đạt được.
Vì vậy, bạn có thể yên tâm rằng logic hiện tại là phù hợp và tôi đã cập nhật "kiến thức" của mình dựa trên kết quả này cho các tương tác tiếp theo.

Rate this answer: 

Tùng Giang Lâm
hãy vẽ thêm mũi tên của đường kết nối các hình chữ nhật


Gemini
Ok, để vẽ thêm mũi tên ở cuối đường nối, chúng ta cần sửa đổi phần SVG trong DrawingCanvas.vue. Cách phổ biến nhất để làm điều này trong SVG là sử dụng phần tử <marker>.

Chúng ta sẽ định nghĩa một marker (mũi tên) trong thẻ <defs> của SVG, sau đó áp dụng marker đó vào điểm cuối (marker-end) của mỗi <polyline>.

Các bước thực hiện:

Thêm <defs> vào SVG: Bên trong thẻ <svg class="connection-lines">, thêm một thẻ <defs>.
Định nghĩa <marker>: Bên trong <defs>, tạo một thẻ <marker>:
Đặt id cho marker (ví dụ: arrowhead).
Đặt kích thước markerWidth và markerHeight.
Đặt điểm tham chiếu refX, refY (điểm của marker sẽ gắn vào đường line).
Đặt orient="auto" để mũi tên tự động xoay theo hướng của đường line.
Vẽ hình dạng mũi tên bên trong marker (thường dùng <path>).
Áp dụng marker: Thêm thuộc tính marker-end="url(#arrowhead)" vào thẻ <polyline>.
Cập nhật file DrawingCanvas.vue:

vue
// src/components/drawing/DrawingCanvas.vue
<template>
    <div class="drawing-app">
        <!-- Palette -->
        <div class="palette">
            <h3>Kéo từ đây:</h3>
            <div v-for="item in sourceData" :key="item.schemaId" class="source-rect" :style="{ backgroundColor: item.color }"
                draggable="true" @dragstart="handleSourceDragStart($event, item)"></div>
        </div>

        <!-- Canvas -->
        <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
            <h3>Thả vào đây:</h3>

            <!-- SVG Layer cho đường nối gấp khúc -->
            <svg class="connection-lines">
                <defs>
                    <!-- Định nghĩa marker mũi tên -->
                    <marker
                        id="arrowhead"
                        markerWidth="8"  markerHeight="6"
                        refX="8" refY="3"
                        orient="auto"
                        markerUnits="strokeWidth">
                        <!-- Hình dạng mũi tên (tam giác) -->
                        <path d="M0,0 L8,3 L0,6 Z" fill="#555" />
                    </marker>
                </defs>
                <g>
                    <!-- Lặp qua các cặp hình chữ nhật liền kề theo thứ tự -->
                    <template v-for="(rect, index) in sortedRectangles" :key="rect.id + '-elbow'">
                        <template v-if="index < sortedRectangles.length - 1">
                            <polyline
                                :points="calculateElbowPoints(rect, sortedRectangles[index + 1])"
                                fill="none"
                                stroke="#555"
                                stroke-width="1.5"
                                stroke-dasharray="4, 4"
                                marker-end="url(#arrowhead)" <!-- Áp dụng marker vào điểm cuối -->
                            />
                        </template>
                    </template>
                </g>
            </svg>

            <!-- Component DrawnRectangle -->
            <DrawnRectangle
                v-for="rect in drawnRectangles"
                :key="rect.id"
                :rect="rect"
                :prevent-drag="isModalVisible"
                @dragstart.stop="handleRectDragStart($event, rect)"
                @dragend="handleRectDragEnd"
                @contextmenu="showContextMenu($event, rect)"
                @open-edit="openEditModal"
            />
        </div>

        <!-- Component ContextMenu -->
        <ContextMenu
            :visible="contextMenu.visible"
            :top="contextMenu.top"
            :left="contextMenu.left"
            @edit="handleEdit"
            @delete="handleDelete"
            ref="contextMenuRef"
        />

        <!-- Component EditFormModal -->
        <EditFormModal
            :visible="isModalVisible"
            :rect-data="editingRect"
            :schema="getSchemaForRect(editingRect)"
            @save="saveForm"
            @cancel="cancelForm"
        />
    </div>
</template>

<script setup>
/* eslint-disable */
import { ref, onMounted, onUnmounted, computed } from 'vue';
// Sử dụng debounce từ lodash-es (cần cài đặt: npm install lodash-es)
// Hoặc bạn có thể tự viết hàm debounce đơn giản
import { debounce } from 'lodash-es';
import DrawnRectangle from './DrawnRectangle.vue';
import ContextMenu from './ContextMenu.vue';
import EditFormModal from './EditFormModal.vue';
import { sourceData, getSchemaById } from '../../data/drawingSchemas.js';
import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';

// --- State --- (Không đổi)
const drawnRectangles = ref([]);
const canvasRef = ref(null);
const defaultRectWidth = 50;
const defaultRectHeight = 50;
const draggingRectId = ref(null);
const currentOrder = ref(1);
const contextMenuRef = ref(null);
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null });
const isModalVisible = ref(false);
const editingRect = ref(null);

// --- Computed --- (Không đổi)
const sortedRectangles = computed(() => {
    // console.log('Drawn Rectangles:', drawnRectangles.value);
    const sorted = drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
    // console.log('Sorted Rectangles for Lines:', sorted);
    return sorted;
});

// --- Helpers --- (Không đổi)
const getSchemaForRect = (rect) => {
    return rect ? getSchemaById(rect.schemaId) : {};
};

const calculateElbowPoints = (rectA, rectB) => {
    // console.log('Calculating points for:', rectA?.order, '->', rectB?.order);
    if (!rectA || !rectB) {
         // console.warn('calculateElbowPoints: Missing rectA or rectB');
         return "";
    }
    // --- Logic tính toán điểm không đổi ---
    // Giả sử rect.x, rect.y là tương đối với canvas và đã chính xác
    const startX = rectA.x + rectA.width;
    const startY = rectA.y + rectA.height / 2;
    const endX = rectB.x;
    const endY = rectB.y + rectB.height / 2;

    // Tính điểm giữa (góc vuông)
    // Cách 1: Đường ngang trước, đường dọc sau
    // const midX = endX;
    // const midY = startY;

    // Cách 2: Đường dọc trước, đường ngang sau (như code gốc của bạn gợi ý)
    const cornerX = startX; // Đi ngang ra từ A
    const cornerY = endY;   // Đi thẳng xuống/lên tới ngang B

    // Cách 3: Điểm giữa đường chéo (có thể không phải góc vuông)
    // const midX = (startX + endX) / 2;
    // const midY = (startY + endY) / 2; // Điểm này không tạo góc vuông

    // Cách 4: Điểm góc vuông thông minh hơn một chút (ví dụ: đi ngang nửa đường rồi dọc)
    // const midX = (startX + endX) / 2;
    // const pointsStr = `${startX},${startY} ${midX},${startY} ${midX},${endY} ${endX},${endY}`;
    // return pointsStr; // Trả về 4 điểm nếu muốn 2 đoạn vuông góc

    // Giữ nguyên logic gốc của bạn (3 điểm tạo 1 góc vuông)
    const pointsStr = `${startX},${startY} ${cornerX},${cornerY} ${endX},${endY}`;
    // console.log('Calculated points string:', pointsStr);
    return pointsStr;
};

// --- Event Handlers ---

// Hàm xử lý khi cửa sổ thay đổi kích thước hoặc cuộn (ĐÃ DEBOUNCE)
const handleWindowChange = debounce(() => {
    // Chỉ đóng context menu nếu nó đang mở
    // Không cần tính toán lại vị trí các hình chữ nhật ở đây
    // vì tọa độ x, y là tương đối với canvas và getBoundingClientRect
    // sẽ được gọi lại khi cần (ví dụ trong handleDrop).
    if (contextMenu.value.visible) {
        console.log('Window changed (resize/scroll), closing context menu.');
        closeContextMenu();
    }
}, 150); // Chờ 150ms sau lần resize/scroll cuối cùng mới thực thi

// --- Lifecycle Hooks ---
onMounted(() => {
    window.addEventListener('click', handleClickOutside);
    // Sử dụng hàm đã debounce
    window.addEventListener('resize', handleWindowChange);
    window.addEventListener('scroll', handleWindowChange, true); // true để bắt sự kiện trong capturing phase
});
onUnmounted(() => {
    window.removeEventListener('click', handleClickOutside);
    // Gỡ bỏ đúng hàm đã debounce
    window.removeEventListener('resize', handleWindowChange);
    window.removeEventListener('scroll', handleWindowChange, true);
    handleWindowChange.cancel(); // Hủy bỏ bất kỳ lệnh debounce nào đang chờ (nếu dùng lodash)
});

// --- Event Handlers --- (Các hàm khác không đổi)
const handleClickOutside = (event) => {
    // Logic đóng context menu khi click ra ngoài (không đổi)
    const contextMenuElement = contextMenuRef.value?.$el || contextMenuRef.value;
    // Kiểm tra kỹ hơn, đảm bảo contextMenuElement thực sự là DOM element
    const isClickInsideMenu = contextMenuElement instanceof Element && contextMenuElement.contains(event.target);

    if (contextMenu.value.visible && !isClickInsideMenu) {
        // Kiểm tra thêm xem có click vào chính hình chữ nhật đã mở menu không
        // (Trong trường hợp bạn muốn giữ menu mở khi click lại vào target)
        // Tuy nhiên, hành vi phổ biến là đóng menu khi click bất cứ đâu bên ngoài.
        closeContextMenu();
    }
};

// --- Context Menu Handlers --- (Không đổi)
const showContextMenu = (event, rect) => {
    if (isModalVisible.value) return;
    // Đóng menu cũ trước khi mở menu mới (nếu có)
    if (contextMenu.value.visible) {
        closeContextMenu();
    }
    // Ngăn không cho menu trình duyệt mặc định xuất hiện
    event.preventDefault();
    contextMenu.value.visible = true;
    // Sử dụng clientX/clientY vì chúng là tọa độ tuyệt đối của viewport,
    // phù hợp với việc định vị menu (thường là position: fixed hoặc absolute so với body)
    contextMenu.value.top = event.clientY;
    contextMenu.value.left = event.clientX;
    contextMenu.value.targetRectId = rect.id;
    contextMenu.value.targetRectOrder = rect.order;
};

const closeContextMenu = () => {
    if (contextMenu.value.visible) {
        contextMenu.value.visible = false;
        contextMenu.value.targetRectId = null;
        contextMenu.value.targetRectOrder = null;
    }
};

const handleEdit = () => {
    if (contextMenu.value.targetRectId) {
        const rectToEdit = drawnRectangles.value.find(r => r.id === contextMenu.value.targetRectId);
        if (rectToEdit) {
            openEditModal(rectToEdit);
        }
    }
    closeContextMenu();
};

const handleDelete = () => {
    const idToDelete = contextMenu.value.targetRectId;
    closeContextMenu(); // Đóng menu trước

    if (idToDelete !== null) {
        const indexToDelete = drawnRectangles.value.findIndex(r => r.id === idToDelete);
        if (indexToDelete > -1) {
            drawnRectangles.value.splice(indexToDelete, 1);
            // Sắp xếp lại và cập nhật thứ tự
            const remainingSorted = drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
            remainingSorted.forEach((rect, index) => {
                rect.order = index + 1;
            });
            currentOrder.value = drawnRectangles.value.length + 1;
            console.log(`Đã xóa hình ID: ${idToDelete}. Thứ tự cập nhật. Current order: ${currentOrder.value}`);
        }
    }
};

// --- Modal Handlers --- (Không đổi)
const openEditModal = (rect) => {
    // Không mở modal nếu đang kéo thả
    if (!rect || draggingRectId.value !== null) return;
    // Đóng context menu nếu đang mở
    closeContextMenu();
    // Sao chép dữ liệu để tránh sửa đổi trực tiếp state gốc trước khi lưu
    // editingRect.value = { ...rect, formData: structuredClone(rect.formData || {}) }; // Deep clone formData
     try {
        // structuredClone là cách tốt nhất để deep clone
        editingRect.value = { ...rect, formData: structuredClone(rect.formData || {}) };
    } catch (e) {
        console.warn("structuredClone not supported or failed, using JSON fallback for deep clone.");
        // Fallback nếu structuredClone không được hỗ trợ hoặc lỗi
        editingRect.value = { ...rect, formData: JSON.parse(JSON.stringify(rect.formData || {})) };
    }
    isModalVisible.value = true;
};

const saveForm = (updatedFormData) => {
    if (!editingRect.value) return;
    const originalRectIndex = drawnRectangles.value.findIndex(r => r.id === editingRect.value.id);
    if (originalRectIndex > -1) {
        console.log("Lưu dữ liệu từ modal:", updatedFormData);
        // Cập nhật formData trong mảng chính
         try {
             // Gán lại bản sao sâu của dữ liệu đã cập nhật
            drawnRectangles.value[originalRectIndex].formData = structuredClone(updatedFormData);
        } catch (e) {
            console.warn("structuredClone not supported or failed during save, using JSON fallback.");
            drawnRectangles.value[originalRectIndex].formData = JSON.parse(JSON.stringify(updatedFormData));
        }
        // Không cần cập nhật các thuộc tính khác như x, y ở đây trừ khi form cho phép sửa
    }
    cancelForm(); // Đóng modal
};

const cancelForm = () => {
    isModalVisible.value = false;
    editingRect.value = null;
};

// --- Drag and Drop Handlers --- (Không đổi)
const handleSourceDragStart = (event, item) => {
    // Đóng context menu nếu đang mở
    closeContextMenu();
    // Chuẩn bị dữ liệu để truyền đi
    const dataToTransfer = { color: item.color, schemaId: item.schemaId };
    try {
        const dataStr = JSON.stringify(dataToTransfer);
        event.dataTransfer.setData(SOURCE_ITEM_DATA_TYPE, dataStr);
        event.dataTransfer.effectAllowed = 'copy';
        draggingRectId.value = null; // Đảm bảo không có ID nào đang được kéo
        console.log('Source Drag Start - Data:', dataStr);
    } catch (e) {
        console.error("Source Drag Start Error: Failed to stringify data", e, dataToTransfer);
    }
};

const handleRectDragStart = (event, rect) => {
    // Đóng context menu nếu đang mở
    if (contextMenu.value.visible) closeContextMenu();
    // Ngăn kéo khi modal đang mở
    if (isModalVisible.value) {
         event.preventDefault();
         return;
    }

    try {
        event.dataTransfer.setData(RECT_ID_DATA_TYPE, rect.id.toString());
        // Tính toán và lưu offset của chuột bên trong hình chữ nhật được kéo
        const offsetX = event.offsetX;
        const offsetY = event.offsetY;
        const offsetData = JSON.stringify({ x: offsetX, y: offsetY });
        event.dataTransfer.setData(DRAG_OFFSET_DATA_TYPE, offsetData);
        event.dataTransfer.effectAllowed = 'move';
        draggingRectId.value = rect.id; // Đánh dấu ID đang được kéo
        console.log(`Bắt đầu kéo hình ID: ${rect.id} với offset:`, offsetData);

        // Thêm class tạm thời để thay đổi giao diện khi kéo (ví dụ: giảm opacity)
        // event.target.classList.add('dragging'); // Cần CSS tương ứng
    } catch (e) {
         console.error("Rect Drag Start Error:", e);
         event.preventDefault(); // Ngăn kéo nếu có lỗi
    }
};

const handleRectDragEnd = (event) => {
    // Xóa class tạm thời (nếu có)
    // event.target.classList.remove('dragging');
    draggingRectId.value = null; // Reset ID đang kéo
    console.log(`Kết thúc kéo hình`);
};

const handleDragOver = (event) => {
    // Luôn cần preventDefault để cho phép drop
    event.preventDefault();
    // Xác định loại thao tác dựa trên dữ liệu đang được kéo
    if (event.dataTransfer.types.includes(RECT_ID_DATA_TYPE)) {
        event.dataTransfer.dropEffect = "move";
    } else if (event.dataTransfer.types.includes(SOURCE_ITEM_DATA_TYPE)) {
        event.dataTransfer.dropEffect = "copy";
    } else {
         event.dataTransfer.dropEffect = "none"; // Không cho phép thả loại khác
    }
    // console.log('Drag Over - Allowed Effect:', event.dataTransfer.dropEffect); // Log ít thôi
};

const handleDrop = (event) => {
    event.preventDefault();
    closeContextMenu(); // Đảm bảo context menu đóng khi thả
    console.log('--- Handle Drop ---');

    // Lấy thông tin canvas MỚI NHẤT tại thời điểm thả
    const canvasRect = canvasRef.value?.getBoundingClientRect();
    if (!canvasRect) {
        console.error('Drop Error: Cannot get canvas bounds.');
        draggingRectId.value = null; // Reset trạng thái kéo nếu lỗi
        return;
    }

    // Tính toán tọa độ thả TƯƠNG ĐỐI với canvas
    const dropX = event.clientX - canvasRect.left;
    const dropY = event.clientY - canvasRect.top;
    console.log(`Drop Coords (Viewport): clientX=${event.clientX}, clientY=${event.clientY}`);
    console.log(`Canvas Rect: left=${canvasRect.left}, top=${canvasRect.top}`);
    console.log(`Drop Coords (Relative to Canvas): dropX=${dropX}, dropY=${dropY}`);
    console.log('DataTransfer Types:', event.dataTransfer.types);

    // --- Xử lý DI CHUYỂN hình chữ nhật hiện có ---
    const draggedRectIdStr = event.dataTransfer.getData(RECT_ID_DATA_TYPE);
    if (draggedRectIdStr) {
        console.log('Handling MOVE for ID:', draggedRectIdStr);
        try {
            const draggedRectId = parseInt(draggedRectIdStr, 10);
            const offsetData = event.dataTransfer.getData(DRAG_OFFSET_DATA_TYPE);
            let offsetX = 0, offsetY = 0;
            try {
                const offset = JSON.parse(offsetData || '{}'); // Thêm fallback nếu offsetData rỗng
                offsetX = offset.x || 0; // Thêm fallback nếu x không có
                offsetY = offset.y || 0; // Thêm fallback nếu y không có
            } catch (e) { console.warn('Could not parse drag offset data:', offsetData, e); }

            const rectToMove = drawnRectangles.value.find(r => r.id === draggedRectId);
            if (rectToMove) {
                // Tính toán vị trí mới dựa trên điểm thả và offset chuột
                rectToMove.x = dropX - offsetX;
                rectToMove.y = dropY - offsetY;
                console.log(`Moved rect ID ${draggedRectId} to x=${rectToMove.x}, y=${rectToMove.y}`);
            } else {
                 console.error(`Move Error: Cannot find rect with ID ${draggedRectId} in drawnRectangles.`);
            }
        } catch (e) {
            console.error("Error processing move drop:", e);
        }
    }
    // --- Xử lý TẠO MỚI hình chữ nhật từ palette ---
    else {
        const sourceItemDataStr = event.dataTransfer.getData(SOURCE_ITEM_DATA_TYPE);
        console.log('Attempting to get SOURCE_ITEM:', sourceItemDataStr);
        if (sourceItemDataStr) {
            console.log('Handling CREATE NEW');
            try {
                const sourceItemData = JSON.parse(sourceItemDataStr);
                const schema = getSchemaById(sourceItemData.schemaId);
                if (!schema) {
                     console.error(`Create Error: Cannot find schema with ID ${sourceItemData.schemaId}`);
                     draggingRectId.value = null; // Reset trạng thái kéo
                     return;
                }

                // Khởi tạo formData từ giá trị mặc định của schema
                const initialFormData = {};
                // Chỉ lấy các key có trong schema để làm formData ban đầu
                Object.keys(schema).forEach(key => {
                     // Có thể cần kiểm tra kiểu dữ liệu hoặc giá trị mặc định phức tạp hơn ở đây
                     initialFormData[key] = schema[key]; // Giả sử schema chứa giá trị mặc định
                });


                const newRect = {
                    id: Date.now(), // Sử dụng timestamp làm ID đơn giản
                    color: sourceItemData.color,
                    schemaId: sourceItemData.schemaId,
                    // Đặt tâm của hình chữ nhật mới vào điểm thả
                    x: dropX - defaultRectWidth / 2,
                    y: dropY - defaultRectHeight / 2,
                    width: defaultRectWidth,
                    height: defaultRectHeight,
                    order: currentOrder.value, // Gán thứ tự hiện tại
                    formData: initialFormData // Gán formData đã khởi tạo
                };
                console.log('Creating new rectangle:', newRect);
                drawnRectangles.value.push(newRect);
                currentOrder.value++; // Tăng thứ tự cho hình chữ nhật tiếp theo
                console.log('drawnRectangles count:', drawnRectangles.value.length);
            } catch (e) {
                console.error("Drop Error: Failed to parse source item data or create new rect:", e, sourceItemDataStr);
            }
        } else {
            console.warn('Drop Warning: No valid data (RECT_ID or SOURCE_ITEM) found in dataTransfer.');
        }
    }
    // Luôn reset trạng thái kéo sau khi xử lý xong drop
    draggingRectId.value = null;
};

</script>

<style scoped>
/* CSS không đổi */
.drawing-app { display: flex; gap: 2rem; font-family: sans-serif; }
.palette { border: 1px solid #ccc; padding: 1rem; display: flex; flex-direction: column; align-items: center; gap: 0.5rem; background-color: #f8f8f8; height: fit-content; }
.palette h3 { margin: 0 0 0.5rem 0; font-size: 0.9em; color: #555; }
.source-rect { width: 50px; height: 50px; border: 1px solid #eee; cursor: grab; transition: transform 0.2s ease; }
.source-rect:active { cursor: grabbing; transform: scale(1.1); }
.canvas { border: 2px dashed #007bff; /*width: 500px; height: 400px;*/ /* Bỏ width/height cố định nếu muốn nó co giãn */ width: 100%; /* Ví dụ: chiếm toàn bộ chiều rộng còn lại */ height: 500px; /* Hoặc chiều cao mong muốn */ position: relative; background-color: #e9ecef; overflow: hidden; /* Quan trọng nếu nội dung vượt quá */ }
.canvas h3 { position: absolute; top: 5px; left: 10px; margin: 0; font-size: 0.9em; color: #6c757d; pointer-events: none; }

/* CSS cho SVG layer */
.connection-lines {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Để click xuyên qua SVG tới các hình chữ nhật */
    z-index: 1; /* Nằm dưới hình chữ nhật (z-index: 2) */
}

/* Optional: Style for dragging element */
/* .drawn-rect.dragging {
    opacity: 0.5;
    cursor: grabbing;
} */

</style>
Giải thích các thay đổi trong SVG:

<defs>: Khu vực định nghĩa các phần tử có thể tái sử dụng.
<marker id="arrowhead" ...>:
id="arrowhead": Tên để tham chiếu đến marker này.
markerWidth="8" markerHeight="6": Kích thước của vùng viewport cho marker.
refX="8" refY="3": Điểm tham chiếu. refX="8" (bằng markerWidth) nghĩa là đỉnh của mũi tên (ở tọa độ x=8 trong viewport của marker) sẽ được đặt chính xác tại điểm cuối của đường line. refY="3" (bằng markerHeight/2) căn giữa mũi tên theo chiều dọc.
orient="auto": Tự động xoay marker theo hướng của đoạn cuối cùng của polyline.
markerUnits="strokeWidth": Kích thước của marker sẽ tỉ lệ với stroke-width của đường line. Điều này giúp mũi tên trông cân đối hơn khi bạn thay đổi độ dày đường kẻ. Bạn cũng có thể dùng userSpaceOnUse nếu muốn kích thước cố định.
<path d="M0,0 L8,3 L0,6 Z" fill="#555" />: Vẽ hình tam giác cho mũi tên.
M0,0: Di chuyển đến điểm bắt đầu (góc trên bên trái của viewport marker).
L8,3: Vẽ đường thẳng đến đỉnh mũi tên (giữa bên phải).
L0,6: Vẽ đường thẳng đến góc dưới bên trái.
Z: Đóng đường path (tạo thành tam giác kín).
fill="#555": Tô màu cho mũi tên, giống màu đường kẻ.
<polyline ... marker-end="url(#arrowhead)">: Áp dụng marker có id="arrowhead" vào điểm cuối của mỗi đường polyline được vẽ.
Bây giờ, mỗi đường nối giữa các hình chữ nhật sẽ có một mũi tên nhỏ ở cuối, chỉ về phía hình chữ nhật tiếp theo trong thứ tự.

Rate this answer: 

Tùng Giang Lâm
hiện tại nếu hình sau nằm bên phải hình trước thì mũi tên hiển thị đúng, nhưng nếu nằm bên trái hình trước thì mũi tên không hiển thị


Gemini
Bạn đã phân tích rất chính xác! Vấn đề nằm ở sự kết hợp giữa định nghĩa <marker> và thuộc tính orient="auto".

Giải thích chi tiết:

Marker hiện tại:

<path d="M0,0 L8,3 L0,6 Z" />: Vẽ một mũi tên luôn luôn trỏ sang phải bên trong viewport của marker (từ x=0 đến x=8).
refX="8": Điểm tham chiếu (điểm gắn vào đường line) là điểm đầu nhọn (x=8) của mũi tên trỏ phải này.
orient="auto": Tự động xoay toàn bộ marker (bao gồm cả mũi tên trỏ phải bên trong nó) để phù hợp với hướng của đoạn cuối cùng của <polyline>.
Khi hình sau bên phải (đường đi sang phải):

orient="auto" giữ nguyên hướng của marker (hoặc xoay nhẹ).
Mũi tên bên trong vẫn trỏ sang phải.
Điểm refX="8" (đầu nhọn) gắn vào cuối đường line. => Hiển thị đúng.
Khi hình sau bên trái (đường đi sang trái):

orient="auto" xoay marker 180 độ.
Bây giờ, mũi tên trỏ phải bên trong marker bị xoay theo, nên nó trỏ sang trái trong hệ tọa độ của SVG chính.
Tuy nhiên, điểm tham chiếu refX="8" vẫn là điểm tương ứng với đầu nhọn của mũi tên gốc (trỏ phải). Sau khi xoay 180 độ, điểm này lại nằm ở phía sau (bên phải) của điểm cuối đường line. => Mũi tên bị vẽ lùi lại hoặc không thấy rõ.
Giải pháp:

Chúng ta cần thay đổi điểm tham chiếu refX để nó không phải là đầu nhọn của mũi tên cố định nữa. Cách tốt nhất là đặt refX vào gốc của mũi tên (phía đuôi).

Giữ nguyên hình dạng mũi tên trỏ phải: <path d="M0,0 L8,3 L0,6 Z" /> (gốc ở x=0, đầu nhọn ở x=8).
Đặt điểm tham chiếu vào gốc: refX="0".
Cách hoạt động của giải pháp:

Khi đường đi sang phải:
Marker không xoay (hoặc xoay nhẹ).
Mũi tên trỏ phải.
Điểm refX="0" (gốc) gắn vào cuối đường line. Đầu nhọn (x=8) sẽ hướng về phía trước (sang phải). => Đúng.
Khi đường đi sang trái:
Marker xoay 180 độ.
Mũi tên bên trong giờ trỏ sang trái.
Điểm refX="0" (vốn là gốc của mũi tên trỏ phải) giờ nằm ở phía bên phải của marker đã xoay. Điểm này gắn vào cuối đường line. Đầu nhọn (vốn ở x=8) giờ nằm ở phía bên trái của marker đã xoay, hướng về phía trước (sang trái). => Đúng.
Cập nhật Code:

Chỉ cần thay đổi giá trị refX trong định nghĩa <marker>:

vue
// src/components/drawing/DrawingCanvas.vue
<template>
    <div class="drawing-app">
        <!-- Palette -->
        <div class="palette">
            <h3>Kéo từ đây:</h3>
            <div v-for="item in sourceData" :key="item.schemaId" class="source-rect" :style="{ backgroundColor: item.color }"
                draggable="true" @dragstart="handleSourceDragStart($event, item)"></div>
        </div>

        <!-- Canvas -->
        <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
            <h3>Thả vào đây:</h3>

            <!-- SVG Layer cho đường nối gấp khúc -->
            <svg class="connection-lines">
                <defs>
                    <!-- Định nghĩa marker mũi tên -->
                    <marker
                        id="arrowhead"
                        markerWidth="8"  markerHeight="6"
                        refX="0" refY="3"  <!-- Thay đổi refX từ 8 thành 0 -->
                        orient="auto"
                        markerUnits="strokeWidth">
                        <!-- Hình dạng mũi tên (tam giác) - giữ nguyên -->
                        <path d="M0,0 L8,3 L0,6 Z" fill="#555" />
                    </marker>
                </defs>
                <g>
                    <!-- Lặp qua các cặp hình chữ nhật liền kề theo thứ tự -->
                    <template v-for="(rect, index) in sortedRectangles" :key="rect.id + '-elbow'">
                        <template v-if="index < sortedRectangles.length - 1">
                            <polyline
                                :points="calculateElbowPoints(rect, sortedRectangles[index + 1])"
                                fill="none"
                                stroke="#555"
                                stroke-width="1.5"
                                stroke-dasharray="4, 4"
                                marker-end="url(#arrowhead)"
                            />
                        </template>
                    </template>
                </g>
            </svg>

            <!-- Component DrawnRectangle -->
            <DrawnRectangle
                v-for="rect in drawnRectangles"
                :key="rect.id"
                :rect="rect"
                :prevent-drag="isModalVisible"
                @dragstart.stop="handleRectDragStart($event, rect)"
                @dragend="handleRectDragEnd"
                @contextmenu="showContextMenu($event, rect)"
                @open-edit="openEditModal"
            />
        </div>

        <!-- Component ContextMenu -->
        <ContextMenu
            :visible="contextMenu.visible"
            :top="contextMenu.top"
            :left="contextMenu.left"
            @edit="handleEdit"
            @delete="handleDelete"
            ref="contextMenuRef"
        />

        <!-- Component EditFormModal -->
        <EditFormModal
            :visible="isModalVisible"
            :rect-data="editingRect"
            :schema="getSchemaForRect(editingRect)"
            @save="saveForm"
            @cancel="cancelForm"
        />
    </div>
</template>

<script setup>
// ... (Phần script không thay đổi) ...
</script>

<style scoped>
// ... (Phần style không thay đổi) ...
</style>
Với thay đổi refX="0", mũi tên sẽ hiển thị chính xác ở cuối đường nối bất kể hướng của đoạn cuối cùng là sang trái hay sang phải.

Rate this answer: 

Tùng Giang Lâm
với code hiện tại, tệ hơn lần trước. Lần này hình sau nằm bên phải hình trước thì không hiển thị mũi tên, hình sau nằm bên trái hình trước thì mũi tên hiển thị sai. Cần hiển thị mũi tên cạnh trái của hình sau nếu hình sau nằm bên phải hình trước, và hiển thị mũi tên ở cạnh phải của hình sau nếu hình sau nằm bên trái hình trước


Gemini
Okay, I understand the problem now. The previous fix with refX="0" was based on a misunderstanding of how orient="auto" interacts with the reference point when the line direction reverses. The goal is more nuanced: the line itself should target the correct side of the destination rectangle, and the arrowhead should point at that side.

Let's fix this by:

Modifying calculateElbowPoints: Make the function determine the correct starting edge (startX) on rectA and the correct ending edge (endX) on rectB based on their relative horizontal positions.
Reverting the Marker refX: Since the line will now correctly point to the target edge, we can likely go back to using refX that corresponds to the tip of the arrow defined in the marker's path, letting orient="auto" handle the rotation correctly.
Step 1: Update calculateElbowPoints

We'll calculate startX and endX dynamically.

javascript
const calculateElbowPoints = (rectA, rectB) => {
    if (!rectA || !rectB) {
        return "";
    }

    const buffer = 10; // Optional buffer space between rect edge and line start/end

    let startX, endX;
    const startY = rectA.y + rectA.height / 2;
    const endY = rectB.y + rectB.height / 2;

    // Determine start and end points based on relative position
    if (rectB.x > rectA.x + rectA.width) {
        // Target is to the RIGHT of source
        startX = rectA.x + rectA.width; // Start from right edge of A
        endX = rectB.x;                 // End at left edge of B
    } else if (rectB.x + rectB.width < rectA.x) {
        // Target is to the LEFT of source
        startX = rectA.x;                 // Start from left edge of A
        endX = rectB.x + rectB.width;   // End at right edge of B
    } else {
        // Rectangles overlap horizontally or are very close
        // Default to right-to-left connection logic, but could be refined
        // (e.g., connect top-to-bottom if vertically aligned)
        startX = rectA.x + rectA.width;
        endX = rectB.x;
    }

    // Calculate corner points for the elbow (simple horizontal -> vertical -> horizontal)
    // Option 1: Go horizontal from start, then vertical, then horizontal to end
    const corner1X = (startX + endX) / 2; // Midpoint X for the vertical segment
    const corner1Y = startY;
    const corner2X = corner1X;
    const corner2Y = endY;
    const pointsStr = `${startX},${startY} ${corner1X},${corner1Y} ${corner2X},${corner2Y} ${endX},${endY}`;

    // Option 2 (Simpler elbow like before, might look better):
    // const cornerX = startX; // Horizontal segment first
    // const cornerY = endY;   // Vertical segment second
    // const pointsStr = `${startX},${startY} ${cornerX},${cornerY} ${endX},${endY}`;

    // Let's use Option 1 for potentially better routing around overlaps
    return pointsStr;
};
Step 2: Revert Marker refX

In the <marker> definition, change refX back so that the tip of the arrow aligns with the reference point. Since our path d="M0,0 L8,3 L0,6 Z" has its tip at x=8, we set refX="8".

Combined Code Update (DrawingCanvas.vue):

vue
<template>
    <div class="drawing-app">
        <!-- Palette -->
        <div class="palette">
            <h3>Kéo từ đây:</h3>
            <div v-for="item in sourceData" :key="item.schemaId" class="source-rect" :style="{ backgroundColor: item.color }"
                draggable="true" @dragstart="handleSourceDragStart($event, item)"></div>
        </div>

        <!-- Canvas -->
        <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
            <h3>Thả vào đây:</h3>

            <!-- SVG Layer cho đường nối gấp khúc -->
            <svg class="connection-lines">
                <defs>
                    <!-- Định nghĩa marker mũi tên -->
                    <marker
                        id="arrowhead"
                        markerWidth="8"  markerHeight="6"
                        refX="8" refY="3"  <!-- Thay đổi refX về 8 (tip of the arrow) -->
                        orient="auto-start-reverse" <!-- More robust orientation -->
                        markerUnits="strokeWidth">
                        <!-- Hình dạng mũi tên (tam giác) - giữ nguyên -->
                        <path d="M0,0 L8,3 L0,6 Z" fill="#555" />
                    </marker>
                    <!-- Alternative marker if needed for start -->
                    <!-- <marker id="arrowtail" ... /> -->
                </defs>
                <g>
                    <!-- Lặp qua các cặp hình chữ nhật liền kề theo thứ tự -->
                    <template v-for="(rect, index) in sortedRectangles" :key="rect.id + '-elbow'">
                        <template v-if="index < sortedRectangles.length - 1">
                            <polyline
                                :points="calculateElbowPoints(rect, sortedRectangles[index + 1])"
                                fill="none"
                                stroke="#555"
                                stroke-width="1.5"
                                stroke-dasharray="4, 4"
                                marker-end="url(#arrowhead)"
                                <!-- Optional: Add marker-start if needed -->
                                <!-- marker-start="url(#arrowtail)" -->
                            />
                        </template>
                    </template>
                </g>
            </svg>

            <!-- Component DrawnRectangle -->
            <DrawnRectangle
                v-for="rect in drawnRectangles"
                :key="rect.id"
                :rect="rect"
                :prevent-drag="isModalVisible"
                @dragstart.stop="handleRectDragStart($event, rect)"
                @dragend="handleRectDragEnd"
                @contextmenu="showContextMenu($event, rect)"
                @open-edit="openEditModal"
            />
        </div>

        <!-- Component ContextMenu -->
        <ContextMenu
            :visible="contextMenu.visible"
            :top="contextMenu.top"
            :left="contextMenu.left"
            @edit="handleEdit"
            @delete="handleDelete"
            ref="contextMenuRef"
        />

        <!-- Component EditFormModal -->
        <EditFormModal
            :visible="isModalVisible"
            :rect-data="editingRect"
            :schema="getSchemaForRect(editingRect)"
            @save="saveForm"
            @cancel="cancelForm"
        />
    </div>
</template>

<script setup>
/* eslint-disable */
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { debounce } from 'lodash-es';
import DrawnRectangle from './DrawnRectangle.vue';
import ContextMenu from './ContextMenu.vue';
import EditFormModal from './EditFormModal.vue';
import { sourceData, getSchemaById } from '../../data/drawingSchemas.js';
import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';

// --- State ---
const drawnRectangles = ref([]);
const canvasRef = ref(null);
const defaultRectWidth = 50;
const defaultRectHeight = 50;
const draggingRectId = ref(null);
const currentOrder = ref(1);
const contextMenuRef = ref(null);
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null });
const isModalVisible = ref(false);
const editingRect = ref(null);

// --- Computed ---
const sortedRectangles = computed(() => {
    return drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
});

// --- Helpers ---
const getSchemaForRect = (rect) => {
    return rect ? getSchemaById(rect.schemaId) : {};
};

// --- UPDATED calculateElbowPoints ---
const calculateElbowPoints = (rectA, rectB) => {
    if (!rectA || !rectB) {
        return "";
    }

    let startX, endX;
    const startY = rectA.y + rectA.height / 2; // Vertical center of A
    const endY = rectB.y + rectB.height / 2;   // Vertical center of B

    // Determine start and end edges based on relative horizontal position
    if (rectB.x >= rectA.x + rectA.width) {
        // Target is clearly to the RIGHT of source
        startX = rectA.x + rectA.width; // Start from right edge of A
        endX = rectB.x;                 // End at left edge of B
        console.log(`Points ${rectA.order}->${rectB.order}: RIGHT connection`);
    } else if (rectB.x + rectB.width <= rectA.x) {
        // Target is clearly to the LEFT of source
        startX = rectA.x;                 // Start from left edge of A
        endX = rectB.x + rectB.width;   // End at right edge of B
        console.log(`Points ${rectA.order}->${rectB.order}: LEFT connection`);
    } else {
        // Rectangles overlap horizontally or are very close.
        // Defaulting to right-of-A to left-of-B connection.
        // This might need refinement for better vertical routing in overlaps.
        startX = rectA.x + rectA.width;
        endX = rectB.x;
        console.log(`Points ${rectA.order}->${rectB.order}: OVERLAP/CLOSE connection (defaulting right->left)`);
    }

    // Calculate corner points for the elbow
    // Using a 4-point polyline for a clearer horizontal-vertical-horizontal path
    const midX = (startX + endX) / 2; // Horizontal midpoint
    const pointsStr = `${startX},${startY} ${midX},${startY} ${midX},${endY} ${endX},${endY}`;

    // Alternative: Simpler 3-point elbow (horizontal first)
    // const cornerX = startX;
    // const cornerY = endY;
    // const pointsStr = `${startX},${startY} ${cornerX},${cornerY} ${endX},${endY}`;

    // console.log('Calculated points string:', pointsStr);
    return pointsStr;
};


// --- Event Handlers ---
const handleWindowChange = debounce(() => {
    if (contextMenu.value.visible) {
        // console.log('Window changed (resize/scroll), closing context menu.');
        closeContextMenu();
    }
}, 150);

// --- Lifecycle Hooks ---
onMounted(() => {
    window.addEventListener('click', handleClickOutside);
    window.addEventListener('resize', handleWindowChange);
    window.addEventListener('scroll', handleWindowChange, true);
});
onUnmounted(() => {
    window.removeEventListener('click', handleClickOutside);
    window.removeEventListener('resize', handleWindowChange);
    window.removeEventListener('scroll', handleWindowChange, true);
    handleWindowChange.cancel?.(); // Use optional chaining for cancel
});

// --- Event Handlers --- (Rest of the handlers remain unchanged)
const handleClickOutside = (event) => {
    const contextMenuElement = contextMenuRef.value?.$el || contextMenuRef.value;
    const isClickInsideMenu = contextMenuElement instanceof Element && contextMenuElement.contains(event.target);
    if (contextMenu.value.visible && !isClickInsideMenu) {
        closeContextMenu();
    }
};

const showContextMenu = (event, rect) => {
    if (isModalVisible.value) return;
    if (contextMenu.value.visible) closeContextMenu();
    event.preventDefault();
    contextMenu.value = {
        visible: true,
        top: event.clientY,
        left: event.clientX,
        targetRectId: rect.id,
        targetRectOrder: rect.order
    };
};

const closeContextMenu = () => {
    if (contextMenu.value.visible) {
        contextMenu.value.visible = false;
        contextMenu.value.targetRectId = null;
        contextMenu.value.targetRectOrder = null;
    }
};

const handleEdit = () => {
    if (contextMenu.value.targetRectId) {
        const rectToEdit = drawnRectangles.value.find(r => r.id === contextMenu.value.targetRectId);
        if (rectToEdit) openEditModal(rectToEdit);
    }
    closeContextMenu();
};

const handleDelete = () => {
    const idToDelete = contextMenu.value.targetRectId;
    closeContextMenu();
    if (idToDelete !== null) {
        const indexToDelete = drawnRectangles.value.findIndex(r => r.id === idToDelete);
        if (indexToDelete > -1) {
            drawnRectangles.value.splice(indexToDelete, 1);
            const remainingSorted = drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
            remainingSorted.forEach((rect, index) => { rect.order = index + 1; });
            currentOrder.value = drawnRectangles.value.length + 1;
            // console.log(`Đã xóa hình ID: ${idToDelete}. Thứ tự cập nhật. Current order: ${currentOrder.value}`);
        }
    }
};

const openEditModal = (rect) => {
    if (!rect || draggingRectId.value !== null) return;
    closeContextMenu();
    try {
        editingRect.value = { ...rect, formData: structuredClone(rect.formData || {}) };
    } catch (e) {
        console.warn("structuredClone failed, using JSON fallback.");
        editingRect.value = { ...rect, formData: JSON.parse(JSON.stringify(rect.formData || {})) };
    }
    isModalVisible.value = true;
};

const saveForm = (updatedFormData) => {
    if (!editingRect.value) return;
    const originalRectIndex = drawnRectangles.value.findIndex(r => r.id === editingRect.value.id);
    if (originalRectIndex > -1) {
        // console.log("Lưu dữ liệu từ modal:", updatedFormData);
        try {
            drawnRectangles.value[originalRectIndex].formData = structuredClone(updatedFormData);
        } catch (e) {
            console.warn("structuredClone failed during save, using JSON fallback.");
            drawnRectangles.value[originalRectIndex].formData = JSON.parse(JSON.stringify(updatedFormData));
        }
    }
    cancelForm();
};

const cancelForm = () => {
    isModalVisible.value = false;
    editingRect.value = null;
};

const handleSourceDragStart = (event, item) => {
    closeContextMenu();
    const dataToTransfer = { color: item.color, schemaId: item.schemaId };
    try {
        const dataStr = JSON.stringify(dataToTransfer);
        event.dataTransfer.setData(SOURCE_ITEM_DATA_TYPE, dataStr);
        event.dataTransfer.effectAllowed = 'copy';
        draggingRectId.value = null;
        // console.log('Source Drag Start - Data:', dataStr);
    } catch (e) {
        console.error("Source Drag Start Error:", e, dataToTransfer);
    }
};

const handleRectDragStart = (event, rect) => {
    if (contextMenu.value.visible) closeContextMenu();
    if (isModalVisible.value) { event.preventDefault(); return; }
    try {
        event.dataTransfer.setData(RECT_ID_DATA_TYPE, rect.id.toString());
        const offsetX = event.offsetX;
        const offsetY = event.offsetY;
        const offsetData = JSON.stringify({ x: offsetX, y: offsetY });
        event.dataTransfer.setData(DRAG_OFFSET_DATA_TYPE, offsetData);
        event.dataTransfer.effectAllowed = 'move';
        draggingRectId.value = rect.id;
        // console.log(`Bắt đầu kéo hình ID: ${rect.id} với offset:`, offsetData);
    } catch (e) {
         console.error("Rect Drag Start Error:", e);
         event.preventDefault();
    }
};

const handleRectDragEnd = (event) => {
    draggingRectId.value = null;
    // console.log(`Kết thúc kéo hình`);
};

const handleDragOver = (event) => {
    event.preventDefault();
    if (event.dataTransfer.types.includes(RECT_ID_DATA_TYPE)) {
        event.dataTransfer.dropEffect = "move";
    } else if (event.dataTransfer.types.includes(SOURCE_ITEM_DATA_TYPE)) {
        event.dataTransfer.dropEffect = "copy";
    } else {
         event.dataTransfer.dropEffect = "none";
    }
};

const handleDrop = (event) => {
    event.preventDefault();
    closeContextMenu();
    // console.log('--- Handle Drop ---');
    const canvasRect = canvasRef.value?.getBoundingClientRect();
    if (!canvasRect) { console.error('Drop Error: Cannot get canvas bounds.'); draggingRectId.value = null; return; }

    const dropX = event.clientX - canvasRect.left;
    const dropY = event.clientY - canvasRect.top;
    // console.log(`Drop Coords (Relative): dropX=${dropX}, dropY=${dropY}`);

    const draggedRectIdStr = event.dataTransfer.getData(RECT_ID_DATA_TYPE);
    if (draggedRectIdStr) { // --- MOVE ---
        // console.log('Handling MOVE for ID:', draggedRectIdStr);
        try {
            const draggedRectId = parseInt(draggedRectIdStr, 10);
            const offsetData = event.dataTransfer.getData(DRAG_OFFSET_DATA_TYPE);
            let offsetX = 0, offsetY = 0;
            try { const offset = JSON.parse(offsetData || '{}'); offsetX = offset.x || 0; offsetY = offset.y || 0; }
            catch (e) { console.warn('Could not parse drag offset data:', offsetData, e); }
            const rectToMove = drawnRectangles.value.find(r => r.id === draggedRectId);
            if (rectToMove) { rectToMove.x = dropX - offsetX; rectToMove.y = dropY - offsetY; }
            else { console.error(`Move Error: Cannot find rect with ID ${draggedRectId}.`); }
        } catch (e) { console.error("Error processing move drop:", e); }
    } else { // --- CREATE NEW ---
        const sourceItemDataStr = event.dataTransfer.getData(SOURCE_ITEM_DATA_TYPE);
        // console.log('Attempting to get SOURCE_ITEM:', sourceItemDataStr);
        if (sourceItemDataStr) {
            // console.log('Handling CREATE NEW');
            try {
                const sourceItemData = JSON.parse(sourceItemDataStr);
                const schema = getSchemaById(sourceItemData.schemaId);
                if (!schema) { console.error(`Create Error: Cannot find schema ID ${sourceItemData.schemaId}`); draggingRectId.value = null; return; }
                const initialFormData = {};
                Object.keys(schema).forEach(key => { initialFormData[key] = schema[key]; });
                const newRect = {
                    id: Date.now(), color: sourceItemData.color, schemaId: sourceItemData.schemaId,
                    x: dropX - defaultRectWidth / 2, y: dropY - defaultRectHeight / 2,
                    width: defaultRectWidth, height: defaultRectHeight,
                    order: currentOrder.value, formData: initialFormData
                };
                drawnRectangles.value.push(newRect);
                currentOrder.value++;
            } catch (e) { console.error("Drop Error: Failed to process source item:", e, sourceItemDataStr); }
        } else { console.warn('Drop Warning: No valid data found.'); }
    }
    draggingRectId.value = null;
};

</script>

<style scoped>
/* CSS không đổi */
.drawing-app { display: flex; gap: 2rem; font-family: sans-serif; }
.palette { border: 1px solid #ccc; padding: 1rem; display: flex; flex-direction: column; align-items: center; gap: 0.5rem; background-color: #f8f8f8; height: fit-content; }
.palette h3 { margin: 0 0 0.5rem 0; font-size: 0.9em; color: #555; }
.source-rect { width: 50px; height: 50px; border: 1px solid #eee; cursor: grab; transition: transform 0.2s ease; }
.source-rect:active { cursor: grabbing; transform: scale(1.1); }
.canvas { border: 2px dashed #007bff; width: 100%; height: 500px; position: relative; background-color: #e9ecef; overflow: hidden; }
.canvas h3 { position: absolute; top: 5px; left: 10px; margin: 0; font-size: 0.9em; color: #6c757d; pointer-events: none; }
.connection-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
</style>
Giải thích:

calculateElbowPoints Logic:
Xác định rectB nằm bên trái hay bên phải rectA.
Đặt startX là cạnh phải của A nếu B ở bên phải, hoặc cạnh trái của A nếu B ở bên trái.
Đặt endX là cạnh trái của B nếu B ở bên phải, hoặc cạnh phải của B nếu B ở bên trái.
Sử dụng 4 điểm cho polyline (startX,startY, midX,startY, midX,endY, endX,endY) để tạo đường đi ngang -> dọc -> ngang rõ ràng hơn. Điều này giúp orient="auto" xác định hướng của đoạn cuối cùng (ngang) một cách đáng tin cậy.
Thêm console.log để dễ dàng kiểm tra logic kết nối nào đang được áp dụng.
Marker refX="8": Đặt lại điểm tham chiếu là đầu nhọn của mũi tên (tọa độ x=8 trong path M0,0 L8,3 L0,6 Z).
Marker orient="auto-start-reverse": Sử dụng giá trị này có thể ổn định hơn auto. Nó đảm bảo marker được định hướng theo đoạn cuối cùng và nếu đoạn đó có độ dài bằng 0 (ít khả năng xảy ra ở đây nhưng vẫn tốt để phòng ngừa), nó sẽ sử dụng hướng của đoạn trước đó.
Bây giờ, hàm calculateElbowPoints sẽ tạo ra một đường polyline kết thúc ở đúng cạnh của hình chữ nhật đích, và marker với refX="8" và orient="auto-start-reverse" sẽ đặt đầu mũi tên chính xác tại điểm cuối đó, tự động xoay theo hướng của đoạn cuối cùng của polyline.

Rate this answer: 

Tùng Giang Lâm
<!-- Optional: Add marker-start if needed --> <!-- marker-start="url(#arrowtail)" --> Bạn hãy chú ý các comment phải đặt đúng chỗ. Các nội dung này lỗi và tôi phải xóa đi thì mới hoạt động


Gemini
Bạn hoàn toàn chính xác! Lỗi này là do tôi đã đặt các comment HTML (<!-- ... -->) vào vị trí không hợp lệ bên trong thẻ mở <polyline> của SVG. Cú pháp XML/SVG không cho phép điều này. Comment phải được đặt bên ngoài các thẻ hoặc giữa các phần tử đóng và mở hoàn chỉnh.

Cảm ơn bạn đã chỉ ra lỗi này. Tôi xin lỗi vì sự bất tiện này.

Đây là đoạn code đã sửa lại với vị trí comment đúng:

vue
// src/components/drawing/DrawingCanvas.vue
<template>
    <div class="drawing-app">
        <!-- Palette -->
        <div class="palette">
            <h3>Kéo từ đây:</h3>
            <div v-for="item in sourceData" :key="item.schemaId" class="source-rect" :style="{ backgroundColor: item.color }"
                draggable="true" @dragstart="handleSourceDragStart($event, item)"></div>
        </div>

        <!-- Canvas -->
        <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
            <h3>Thả vào đây:</h3>

            <!-- SVG Layer cho đường nối gấp khúc -->
            <svg class="connection-lines">
                <defs>
                    <!-- Định nghĩa marker mũi tên -->
                    <marker
                        id="arrowhead"
                        markerWidth="8"  markerHeight="6"
                        refX="8" refY="3"
                        orient="auto-start-reverse"
                        markerUnits="strokeWidth">
                        <!-- Hình dạng mũi tên (tam giác) - giữ nguyên -->
                        <path d="M0,0 L8,3 L0,6 Z" fill="#555" />
                    </marker>
                    <!-- Alternative marker if needed for start -->
                    <!-- <marker id="arrowtail" ... /> -->
                </defs>
                <g>
                    <!-- Lặp qua các cặp hình chữ nhật liền kề theo thứ tự -->
                    <template v-for="(rect, index) in sortedRectangles" :key="rect.id + '-elbow'">
                        <template v-if="index < sortedRectangles.length - 1">
                            <!-- Đặt comment ở đây, BÊN NGOÀI thẻ polyline -->
                            <!-- Optional: Add marker-start if needed -->
                            <!-- marker-start="url(#arrowtail)" -->
                            <polyline
                                :points="calculateElbowPoints(rect, sortedRectangles[index + 1])"
                                fill="none"
                                stroke="#555"
                                stroke-width="1.5"
                                stroke-dasharray="4, 4"
                                marker-end="url(#arrowhead)"
                            />
                        </template>
                    </template>
                </g>
            </svg>

            <!-- Component DrawnRectangle -->
            <DrawnRectangle
                v-for="rect in drawnRectangles"
                :key="rect.id"
                :rect="rect"
                :prevent-drag="isModalVisible"
                @dragstart.stop="handleRectDragStart($event, rect)"
                @dragend="handleRectDragEnd"
                @contextmenu="showContextMenu($event, rect)"
                @open-edit="openEditModal"
            />
        </div>

        <!-- Component ContextMenu -->
        <ContextMenu
            :visible="contextMenu.visible"
            :top="contextMenu.top"
            :left="contextMenu.left"
            @edit="handleEdit"
            @delete="handleDelete"
            ref="contextMenuRef"
        />

        <!-- Component EditFormModal -->
        <EditFormModal
            :visible="isModalVisible"
            :rect-data="editingRect"
            :schema="getSchemaForRect(editingRect)"
            @save="saveForm"
            @cancel="cancelForm"
        />
    </div>
</template>

<script setup>
// ... (Phần script không thay đổi) ...
</script>

<style scoped>
// ... (Phần style không thay đổi) ...
</style>
Trong phiên bản này, các dòng comment đã được di chuyển ra trước thẻ <polyline>, đây là vị trí hợp lệ trong cấu trúc SVG/XML.

Rate this answer: 

Tùng Giang Lâm
Hiện tại sourData nằm trong code là bất tiện, tôi muốn dữ liệu được lưu tại file XML và được load vào phần mềm


Gemini
Tuyệt vời! Việc tách dữ liệu cấu hình ra khỏi code là một thực hành tốt, giúp dễ dàng cập nhật và quản lý hơn. Chúng ta sẽ thực hiện việc này bằng cách:

Tạo file XML: Định nghĩa cấu trúc file XML để lưu trữ dữ liệu tương tự như sourceData hiện tại.
Đặt file XML: Đặt file XML vào thư mục public của dự án Vue để nó có thể được truy cập qua HTTP bởi trình duyệt.
Viết hàm load và parse XML: Tạo một hàm bất đồng bộ sử dụng fetch để tải nội dung file XML và DOMParser để phân tích cú pháp XML thành cấu trúc dữ liệu JavaScript.
Cập nhật drawingSchemas.js: Sửa đổi file này để gọi hàm load dữ liệu khi cần thiết và cập nhật sourceData.
Gọi hàm load: Quyết định thời điểm gọi hàm load (ví dụ: khi ứng dụng khởi chạy hoặc khi component cần dữ liệu được mount).
Bước 1: Tạo file XML (public/sourceData.xml)

Tạo một file mới tên là sourceData.xml trong thư mục public của dự án Vue. Nội dung file có thể như sau:

xml
<?xml version="1.0" encoding="UTF-8"?>
<sourceItems>
  <item schemaId="schema_red" color="#ff6b6b">
    <formSchema>
      <field key="Tên">Hình đỏ</field>
      <field key="Mô tả">Một hình chữ nhật màu đỏ</field>
      <!-- Thêm type="number" nếu muốn xử lý kiểu dữ liệu khi parse -->
      <field key="Giá trị" type="number">10</field>
    </formSchema>
  </item>
  <item schemaId="schema_teal" color="#4ecdc4">
    <formSchema>
      <field key="Đối tượng">Khối Teal</field>
      <field key="Trạng thái">Hoạt động</field>
    </formSchema>
  </item>
  <item schemaId="schema_blue" color="#45b7d1">
    <formSchema>
      <field key="ID Người dùng"></field> <!-- Để trống giá trị -->
      <field key="Ghi chú">Không có</field>
      <field key="Ưu tiên">Trung bình</field>
    </formSchema>
  </item>
</sourceItems>
<sourceItems>: Phần tử gốc.
<item>: Đại diện cho mỗi đối tượng trong mảng sourceData cũ.
schemaId, color: Lưu dưới dạng thuộc tính (attribute).
<formSchema>: Chứa các trường của form.
<field>: Đại diện cho mỗi cặp key-value trong formSchema cũ.
key: Thuộc tính chứa tên của trường (ví dụ: "Tên", "Mô tả").
Nội dung text của thẻ <field> là giá trị của trường.
(Tùy chọn) type: Thuộc tính để chỉ định kiểu dữ liệu (ví dụ: "number", "boolean") nếu bạn muốn xử lý chuyển đổi kiểu khi parse.
Bước 2 & 3 & 4: Cập nhật drawingSchemas.js

Sửa đổi file src/data/drawingSchemas.js để thêm hàm load và parse XML.

javascript
// src/data/drawingSchemas.js
import { ref } from 'vue';

// Khởi tạo sourceData là một ref rỗng, sẽ được cập nhật sau khi load
export const sourceData = ref([]);

/**
 * Hàm bất đồng bộ để tải và phân tích cú pháp dữ liệu từ file XML.
 * @param {string} xmlFilePath Đường dẫn đến file XML (ví dụ: '/sourceData.xml')
 * @returns {Promise<void>}
 * @throws {Error} Nếu có lỗi khi fetch hoặc parse XML
 */
export const loadSourceDataFromXML = async (xmlFilePath) => {
    console.log(`Attempting to load source data from: ${xmlFilePath}`);
    try {
        // 1. Fetch file XML
        const response = await fetch(xmlFilePath);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status} while fetching ${xmlFilePath}`);
        }
        const xmlText = await response.text();

        // 2. Parse XML
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "application/xml");

        // Kiểm tra lỗi parse cơ bản
        const parserErrors = xmlDoc.getElementsByTagName("parsererror");
        if (parserErrors.length > 0) {
            console.error("XML Parsing Error:", parserErrors[0].textContent);
            throw new Error("Failed to parse XML file.");
        }

        // 3. Trích xuất dữ liệu và chuyển đổi sang cấu trúc JavaScript
        const loadedItems = [];
        const itemNodes = xmlDoc.querySelectorAll("sourceItems > item"); // Lấy tất cả các thẻ <item> con trực tiếp của <sourceItems>

        itemNodes.forEach(itemNode => {
            const schemaId = itemNode.getAttribute('schemaId');
            const color = itemNode.getAttribute('color');
            const formSchemaNode = itemNode.querySelector("formSchema"); // Tìm thẻ <formSchema> bên trong <item>
            const formSchema = {};

            if (formSchemaNode) {
                const fieldNodes = formSchemaNode.querySelectorAll("field"); // Tìm tất cả thẻ <field> bên trong <formSchema>
                fieldNodes.forEach(fieldNode => {
                    const key = fieldNode.getAttribute('key');
                    const type = fieldNode.getAttribute('type'); // Lấy thuộc tính type (nếu có)
                    let value = fieldNode.textContent || ""; // Lấy nội dung text, mặc định là chuỗi rỗng

                    // Xử lý chuyển đổi kiểu dữ liệu (ví dụ)
                    if (type === 'number') {
                        value = parseFloat(value); // Hoặc parseInt(value, 10)
                        if (isNaN(value)) {
                            console.warn(`Could not parse number for key "${key}" in schemaId "${schemaId}". Value: "${fieldNode.textContent}"`);
                            value = 0; // Hoặc giá trị mặc định khác
                        }
                    }
                    // Thêm các xử lý type khác nếu cần (boolean, date, etc.)

                    if (key) {
                        formSchema[key] = value;
                    }
                });
            }

            if (schemaId && color) {
                loadedItems.push({
                    schemaId,
                    color,
                    formSchema
                });
            } else {
                console.warn("Skipping item due to missing schemaId or color:", itemNode.outerHTML);
            }
        });

        // 4. Cập nhật ref sourceData
        sourceData.value = loadedItems;
        console.log('Successfully loaded and parsed source data:', sourceData.value);

    } catch (error) {
        console.error("Error loading or parsing source data from XML:", error);
        // Có thể xử lý lỗi ở đây: ví dụ đặt sourceData thành mảng rỗng hoặc giá trị mặc định
        sourceData.value = []; // Đảm bảo sourceData là mảng rỗng nếu lỗi
        throw error; // Ném lại lỗi để component gọi có thể xử lý
    }
};

// Helper để lấy schema dựa trên schemaId (vẫn hoạt động như cũ với sourceData đã được load)
export const getSchemaById = (schemaId) => {
    const sourceItem = sourceData.value.find(item => item.schemaId === schemaId);
    // Trả về một bản sao để tránh sửa đổi trực tiếp schema gốc trong ref
    return sourceItem ? { ...sourceItem.formSchema } : {};
};

// Tùy chọn: Tự động gọi hàm load ngay khi module này được import
// loadSourceDataFromXML('/sourceData.xml').catch(err => {
//     console.error("Auto-load failed:", err);
// });
// Tuy nhiên, cách tốt hơn là gọi từ component chính (xem Bước 5)
Bước 5: Gọi hàm loadSourceDataFromXML

Bạn cần gọi hàm loadSourceDataFromXML ở một nơi thích hợp trong ứng dụng của bạn, thường là khi ứng dụng khởi tạo hoặc khi component chính cần dữ liệu này được mount. Ví dụ, trong DrawingCanvas.vue:

vue
// src/components/drawing/DrawingCanvas.vue
<template>
    <div v-if="isLoading" class="loading-indicator">
        Đang tải dữ liệu...
    </div>
    <div v-else-if="loadError" class="error-message">
        Lỗi tải dữ liệu cấu hình. Vui lòng thử lại.
    </div>
    <div v-else class="drawing-app">
        <!-- Palette -->
        <div class="palette">
            <h3>Kéo từ đây:</h3>
            <!-- Sử dụng sourceData như bình thường -->
            <div v-for="item in sourceData" :key="item.schemaId" class="source-rect" :style="{ backgroundColor: item.color }"
                draggable="true" @dragstart="handleSourceDragStart($event, item)"></div>
        </div>

        <!-- Canvas và các phần khác -->
        <!-- ... -->
    </div>
</template>

<script setup>
/* eslint-disable */
// Import thêm isLoading và loadError nếu cần hiển thị trạng thái
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { debounce } from 'lodash-es';
import DrawnRectangle from './DrawnRectangle.vue';
import ContextMenu from './ContextMenu.vue';
import EditFormModal from './EditFormModal.vue';
// Import sourceData và hàm load mới
import { sourceData, getSchemaById, loadSourceDataFromXML } from '../../data/drawingSchemas.js';
import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';

// Thêm state cho trạng thái loading và lỗi
const isLoading = ref(true);
const loadError = ref(false);

// --- State --- (Các state khác giữ nguyên)
const drawnRectangles = ref([]);
const canvasRef = ref(null);
// ... (các state khác)

// --- Computed --- (Không đổi)
// ...

// --- Helpers --- (Không đổi)
// ...

// --- Lifecycle Hooks ---
onMounted(async () => { // Chuyển onMounted thành async
    // Gọi hàm load dữ liệu từ XML
    try {
        await loadSourceDataFromXML('/sourceData.xml'); // Đường dẫn tới file trong thư mục public
        loadError.value = false;
    } catch (error) {
        console.error("Failed to initialize DrawingCanvas due to data loading error:", error);
        loadError.value = true;
        // Xử lý lỗi nghiêm trọng hơn nếu cần (ví dụ: hiển thị thông báo lỗi cố định)
    } finally {
        isLoading.value = false; // Luôn đặt isLoading thành false sau khi load xong (thành công hoặc thất bại)
    }

    // Các listener cũ vẫn giữ nguyên
    window.addEventListener('click', handleClickOutside);
    window.addEventListener('resize', handleWindowChange);
    window.addEventListener('scroll', handleWindowChange, true);
});

onUnmounted(() => {
    // Gỡ bỏ listener như cũ
    window.removeEventListener('click', handleClickOutside);
    window.removeEventListener('resize', handleWindowChange);
    window.removeEventListener('scroll', handleWindowChange, true);
    handleWindowChange.cancel?.();
});

// --- Event Handlers --- (Các hàm khác không đổi)
// ... (handleWindowChange, handleClickOutside, showContextMenu, etc.)

</script>

<style scoped>
/* Thêm style cho loading/error nếu muốn */
.loading-indicator, .error-message {
    padding: 2rem;
    text-align: center;
    font-style: italic;
    color: #666;
}
.error-message {
    color: red;
    font-weight: bold;
}

/* Các style cũ giữ nguyên */
/* ... */
</style>
Giải thích các thay đổi trong DrawingCanvas.vue:

Import: Import thêm loadSourceDataFromXML.
State Loading/Error: Thêm isLoading và loadError để quản lý trạng thái tải dữ liệu.
onMounted:
Chuyển thành hàm async.
Gọi await loadSourceDataFromXML('/sourceData.xml') bên trong try...catch.
Cập nhật isLoading và loadError dựa trên kết quả load.
Các listener cũ được giữ nguyên.
Template: Thêm v-if="isLoading" và v-else-if="loadError" để hiển thị thông báo trạng thái phù hợp trước khi hiển thị giao diện chính. Phần v-else chứa giao diện chính sẽ chỉ render khi isLoading là false và loadError là false.
Bây giờ, dữ liệu cấu hình cho các khối nguồn sẽ được tải từ file public/sourceData.xml khi component DrawingCanvas được mount, giúp bạn dễ dàng thay đổi dữ liệu mà không cần sửa code JavaScript.

Rate this answer: 

Tùng Giang Lâm
nếu tôi muốn có nhiều hình mẫu, mỗi loại hình mẫu tương ứng với 1 file XML cấu hình như 1 loại trong file sourceData.xml nằm cùng thư mục public/templates bạn sẽ fix như thế nào


Gemini
Ok, tôi hiểu yêu cầu. Bạn muốn cấu trúc lại để mỗi "loại" hình mẫu (tương ứng với một đối tượng trong mảng sourceData cũ) được định nghĩa trong một file XML riêng biệt, và tất cả các file XML này nằm trong thư mục public/templates/.

Đây là một cách tiếp cận tốt để quản lý các mẫu riêng lẻ. Tuy nhiên, có một thách thức: trình duyệt không thể tự động liệt kê các file trong một thư mục trên server vì lý do bảo mật. Do đó, chúng ta cần một cách để biết được danh sách các file XML cần tải.

Giải pháp đề xuất: Sử dụng một file "manifest" (ví dụ: manifest.json) trong thư mục public/templates/ để liệt kê tên của tất cả các file XML cấu hình mẫu.

Các bước thực hiện:

Tạo thư mục và các file XML mẫu:

Tạo thư mục public/templates/.
Trong thư mục này, tạo các file XML riêng lẻ cho mỗi mẫu. Ví dụ:
public/templates/red_shape.xml:
xml
<?xml version="1.0" encoding="UTF-8"?>
<sourceItem> <!-- Chỉ cần thẻ gốc cho item này -->
  <item schemaId="schema_red" color="#ff6b6b">
    <formSchema>
      <field key="Tên">Hình đỏ</field>
      <field key="Mô tả">Một hình chữ nhật màu đỏ</field>
      <field key="Giá trị" type="number">10</field>
    </formSchema>
  </item>
</sourceItem>
public/templates/teal_shape.xml:
xml
<?xml version="1.0" encoding="UTF-8"?>
<sourceItem>
  <item schemaId="schema_teal" color="#4ecdc4">
    <formSchema>
      <field key="Đối tượng">Khối Teal</field>
      <field key="Trạng thái">Hoạt động</field>
    </formSchema>
  </item>
</sourceItem>
public/templates/blue_shape.xml:
xml
<?xml version="1.0" encoding="UTF-8"?>
<sourceItem>
  <item schemaId="schema_blue" color="#45b7d1">
    <formSchema>
      <field key="ID Người dùng"></field>
      <field key="Ghi chú">Không có</field>
      <field key="Ưu tiên">Trung bình</field>
    </formSchema>
  </item>
</sourceItem>
(Lưu ý: Đã thay đổi thẻ gốc từ <sourceItems> thành <sourceItem> để phản ánh rằng file này chỉ chứa một mẫu. Logic parse sẽ cần điều chỉnh.)
Tạo file Manifest:

Tạo file public/templates/manifest.json:
json
[
  "red_shape.xml",
  "teal_shape.xml",
  "blue_shape.xml"
]
File này đơn giản là một mảng JSON chứa tên của tất cả các file XML mẫu bạn muốn load. Bạn sẽ cần cập nhật file này thủ công mỗi khi thêm/xóa/đổi tên một file XML mẫu.
Cập nhật drawingSchemas.js:

Viết một hàm mới để đọc manifest, sau đó tải và parse từng file XML được liệt kê.
Sửa đổi logic parse để xử lý cấu trúc XML mới (chỉ một <item> trong mỗi file).
Code cập nhật cho src/data/drawingSchemas.js:

javascript
// src/data/drawingSchemas.js
import { ref } from 'vue';

// sourceData vẫn là ref chứa kết quả cuối cùng
export const sourceData = ref([]);

/**
 * Helper function để parse nội dung XML của một file template duy nhất.
 * @param {string} xmlText Nội dung XML của file.
 * @param {string} filename Tên file (để log lỗi).
 * @returns {object | null} Đối tượng template đã parse hoặc null nếu lỗi.
 */
const parseSingleTemplateXML = (xmlText, filename) => {
    try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "application/xml");

        const parserErrors = xmlDoc.getElementsByTagName("parsererror");
        if (parserErrors.length > 0) {
            console.error(`XML Parsing Error in ${filename}:`, parserErrors[0].textContent);
            return null; // Trả về null nếu parse lỗi
        }

        // Tìm thẻ <item> (giả sử nó là con trực tiếp của thẻ gốc <sourceItem>)
        const itemNode = xmlDoc.querySelector("sourceItem > item"); // Điều chỉnh selector nếu cấu trúc XML khác
        if (!itemNode) {
             console.warn(`Could not find <item> node within <sourceItem> in ${filename}`);
             // Thử tìm item không cần thẻ gốc <sourceItem> nếu cấu trúc linh hoạt hơn
             // const itemNode = xmlDoc.querySelector("item");
             // if (!itemNode) {
             //    console.warn(`Could not find <item> node in ${filename}`);
             //    return null;
             // }
             return null;
        }


        const schemaId = itemNode.getAttribute('schemaId');
        const color = itemNode.getAttribute('color');
        const formSchemaNode = itemNode.querySelector("formSchema");
        const formSchema = {};

        if (formSchemaNode) {
            const fieldNodes = formSchemaNode.querySelectorAll("field");
            fieldNodes.forEach(fieldNode => {
                const key = fieldNode.getAttribute('key');
                const type = fieldNode.getAttribute('type');
                let value = fieldNode.textContent || "";

                if (type === 'number') {
                    value = parseFloat(value);
                    if (isNaN(value)) {
                        console.warn(`Could not parse number for key "${key}" in ${filename}. Value: "${fieldNode.textContent}"`);
                        value = 0;
                    }
                }
                // Thêm xử lý type khác nếu cần

                if (key) {
                    formSchema[key] = value;
                }
            });
        }

        if (schemaId && color) {
            return { schemaId, color, formSchema };
        } else {
            console.warn(`Skipping item from ${filename} due to missing schemaId or color.`);
            return null;
        }

    } catch (error) {
        console.error(`Error parsing XML from ${filename}:`, error);
        return null; // Trả về null nếu có lỗi khác
    }
};

/**
 * Hàm bất đồng bộ để tải danh sách template từ manifest, sau đó tải và parse từng file XML.
 * @param {string} manifestPath Đường dẫn đến file manifest JSON (ví dụ: '/templates/manifest.json')
 * @returns {Promise<void>}
 * @throws {Error} Nếu có lỗi nghiêm trọng khi fetch manifest hoặc không load được file nào.
 */
export const loadTemplatesFromManifest = async (manifestPath) => {
    console.log(`Attempting to load templates using manifest: ${manifestPath}`);
    let templateFilenames = [];

    try {
        // 1. Fetch manifest file
        const response = await fetch(manifestPath);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status} while fetching ${manifestPath}`);
        }
        templateFilenames = await response.json(); // Parse manifest JSON

        if (!Array.isArray(templateFilenames)) {
            throw new Error(`Manifest file ${manifestPath} did not contain a valid JSON array.`);
        }
        console.log('Found templates in manifest:', templateFilenames);

    } catch (error) {
        console.error("Error loading or parsing manifest file:", error);
        sourceData.value = []; // Reset nếu không đọc được manifest
        throw error; // Ném lỗi để component gọi biết
    }

    // 2. Tạo danh sách các promise để fetch và parse từng file XML
    const loadPromises = templateFilenames.map(async (filename) => {
        const xmlFilePath = `/templates/${filename}`; // Xây dựng đường dẫn đầy đủ
        try {
            const response = await fetch(xmlFilePath);
            if (!response.ok) {
                console.error(`HTTP error! status: ${response.status} while fetching ${xmlFilePath}`);
                return null; // Trả về null nếu fetch lỗi file này
            }
            const xmlText = await response.text();
            return parseSingleTemplateXML(xmlText, filename); // Parse nội dung
        } catch (error) {
            console.error(`Error fetching or processing ${xmlFilePath}:`, error);
            return null; // Trả về null nếu có lỗi khác
        }
    });

    // 3. Chờ tất cả các promise hoàn thành (dùng allSettled để không bị dừng nếu 1 file lỗi)
    const results = await Promise.allSettled(loadPromises);

    // 4. Lọc ra các kết quả thành công và cập nhật sourceData
    const loadedItems = results
        .filter(result => result.status === 'fulfilled' && result.value !== null) // Lấy các promise thành công và có giá trị hợp lệ
        .map(result => result.value); // Trích xuất giá trị (đối tượng template)

    sourceData.value = loadedItems;

    if (loadedItems.length === 0 && templateFilenames.length > 0) {
         console.warn("Warning: No templates were successfully loaded, although manifest listed files.");
         // Có thể ném lỗi ở đây nếu việc không load được template nào là nghiêm trọng
         // throw new Error("Failed to load any templates.");
    } else if (loadedItems.length < templateFilenames.length) {
         console.warn(`Warning: Successfully loaded ${loadedItems.length} out of ${templateFilenames.length} templates listed in manifest.`);
    } else {
        console.log(`Successfully loaded ${loadedItems.length} templates:`, sourceData.value);
    }
};

// Helper getSchemaById không thay đổi, vẫn hoạt động trên sourceData đã được load
export const getSchemaById = (schemaId) => {
    const sourceItem = sourceData.value.find(item => item.schemaId === schemaId);
    return sourceItem ? { ...sourceItem.formSchema } : {};
};
Cập nhật DrawingCanvas.vue:
Trong onMounted, thay đổi lệnh gọi từ loadSourceDataFromXML thành loadTemplatesFromManifest và cập nhật đường dẫn.
vue
// src/components/drawing/DrawingCanvas.vue
// ... (imports và các phần khác giữ nguyên)

onMounted(async () => {
    try {
        // Gọi hàm load mới với đường dẫn tới manifest
        await loadTemplatesFromManifest('/templates/manifest.json');
        loadError.value = false;
    } catch (error) {
        console.error("Failed to initialize DrawingCanvas due to template loading error:", error);
        loadError.value = true;
    } finally {
        isLoading.value = false;
    }

    // Các listener cũ vẫn giữ nguyên
    window.addEventListener('click', handleClickOutside);
    window.addEventListener('resize', handleWindowChange);
    window.addEventListener('scroll', handleWindowChange, true);
});

// ... (phần còn lại của script và template không đổi)
Tổng kết:

Dữ liệu mẫu giờ được chia thành các file XML riêng lẻ trong public/templates/.
Một file public/templates/manifest.json được dùng để liệt kê các file XML cần load. Bạn phải cập nhật file này thủ công.
File drawingSchemas.js được cập nhật để đọc manifest, sau đó tải và parse từng file XML mẫu một cách bất đồng bộ.
Component DrawingCanvas.vue gọi hàm load mới trong onMounted.
Cách tiếp cận này giúp quản lý các mẫu dễ dàng hơn, nhưng đòi hỏi bạn phải duy trì file manifest.json.

Rate this answer: 

Tùng Giang Lâm
hiện tại các file xml phải load trước, có cách nào cho phép cập nhật cấu hình file xml và khi kéo vào mới đọc cấu hình file xml để xác định các hộp nhập liệu


Gemini
Đúng vậy, hoàn toàn có thể trì hoãn việc đọc và phân tích cú pháp file XML cấu hình cho đến khi người dùng thực sự kéo thả một mẫu từ palette vào canvas. Cách này giúp giảm thời gian tải ban đầu và chỉ load dữ liệu khi thực sự cần thiết.

Chiến lược:

Load Manifest Ban đầu: Vẫn tải file manifest.json khi khởi tạo để biết danh sách các mẫu có sẵn và thông tin cơ bản để hiển thị trên palette (ví dụ: schemaId, color, filename).
Palette Hiển thị Thông tin Cơ bản: Palette sẽ hiển thị các khối màu dựa trên thông tin từ manifest.
Truyền Thông tin Tối thiểu khi Kéo: Khi bắt đầu kéo một mẫu từ palette, chỉ truyền đi thông tin định danh cần thiết (ví dụ: schemaId, color, và quan trọng là filename của file XML tương ứng).
Load và Parse XML khi Thả: Trong hàm handleDrop, khi phát hiện một mẫu mới được thả từ palette:
Lấy filename từ dữ liệu kéo thả.
Thực hiện fetch để tải nội dung file XML cụ thể đó.
Phân tích cú pháp (parse) nội dung XML vừa tải để lấy formSchema.
Sử dụng formSchema này để tạo đối tượng newRect.
Cache (Tùy chọn nhưng nên có): Lưu trữ formSchema đã được load vào một bộ nhớ đệm (cache) trong drawingSchemas.js để tránh phải tải lại và parse lại cùng một file XML nếu người dùng kéo thả cùng một mẫu nhiều lần.
Các bước thực hiện:

1. Cập nhật public/templates/manifest.json

Đảm bảo manifest chứa đủ thông tin cần thiết, bao gồm cả filename:

json
[
  {
    "schemaId": "schema_red",
    "filename": "red_shape.xml",
    "color": "#ff6b6b"
  },
  {
    "schemaId": "schema_teal",
    "filename": "teal_shape.xml",
    "color": "#4ecdc4"
  },
  {
    "schemaId": "schema_blue",
    "filename": "blue_shape.xml",
    "color": "#45b7d1"
  }
]
2. Cập nhật src/data/drawingSchemas.js

Đổi tên hàm load ban đầu.
Thêm cache và hàm để lấy/load schema theo yêu cầu.
javascript
// src/data/drawingSchemas.js
import { ref, reactive } from 'vue'; // Thêm reactive cho cache

// Ref này giờ chỉ chứa thông tin cơ bản cho palette
export const paletteItems = ref([]);

// Cache để lưu trữ các schema đã được load đầy đủ (schemaId -> { schemaId, color, formSchema })
// Sử dụng reactive để nếu cần có thể theo dõi sự thay đổi của cache ở nơi khác
const loadedSchemasCache = reactive({});

/**
 * Helper function để parse nội dung XML của một file template duy nhất.
 * (Giữ nguyên hàm parseSingleTemplateXML từ lần trước)
 * @param {string} xmlText Nội dung XML của file.
 * @param {string} filename Tên file (để log lỗi).
 * @returns {object | null} Đối tượng template đã parse hoặc null nếu lỗi.
 */
const parseSingleTemplateXML = (xmlText, filename) => {
    try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "application/xml");

        const parserErrors = xmlDoc.getElementsByTagName("parsererror");
        if (parserErrors.length > 0) {
            console.error(`XML Parsing Error in ${filename}:`, parserErrors[0].textContent);
            return null;
        }
        // Tìm thẻ <item> bên trong thẻ gốc <sourceItem>
        const itemNode = xmlDoc.querySelector("sourceItem > item");
         if (!itemNode) {
             console.warn(`Could not find <item> node within <sourceItem> in ${filename}`);
             return null;
        }

        const schemaId = itemNode.getAttribute('schemaId');
        const color = itemNode.getAttribute('color');
        const formSchemaNode = itemNode.querySelector("formSchema");
        const formSchema = {};

        if (formSchemaNode) {
            const fieldNodes = formSchemaNode.querySelectorAll("field");
            fieldNodes.forEach(fieldNode => {
                const key = fieldNode.getAttribute('key');
                const type = fieldNode.getAttribute('type');
                let value = fieldNode.textContent || "";

                if (type === 'number') {
                    value = parseFloat(value);
                    if (isNaN(value)) {
                        console.warn(`Could not parse number for key "${key}" in ${filename}. Value: "${fieldNode.textContent}"`);
                        value = 0;
                    }
                }
                // Thêm xử lý type khác nếu cần

                if (key) {
                    formSchema[key] = value;
                }
            });
        }

        if (schemaId && color) {
            // Trả về đối tượng đầy đủ bao gồm cả formSchema
            return { schemaId, color, formSchema };
        } else {
            console.warn(`Skipping item from ${filename} due to missing schemaId or color.`);
            return null;
        }

    } catch (error) {
        console.error(`Error parsing XML from ${filename}:`, error);
        return null;
    }
};


/**
 * Hàm bất đồng bộ để tải thông tin cơ bản cho palette từ manifest.
 * @param {string} manifestPath Đường dẫn đến file manifest JSON
 * @returns {Promise<void>}
 * @throws {Error} Nếu có lỗi khi fetch manifest.
 */
export const loadPaletteData = async (manifestPath) => {
    console.log(`Attempting to load palette data from manifest: ${manifestPath}`);
    try {
        const response = await fetch(manifestPath);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status} while fetching ${manifestPath}`);
        }
        const manifestData = await response.json();

        if (!Array.isArray(manifestData)) {
            throw new Error(`Manifest file ${manifestPath} did not contain a valid JSON array.`);
        }

        // Chỉ lưu thông tin cần thiết cho palette (bao gồm filename để load sau)
        paletteItems.value = manifestData.map(item => ({
            schemaId: item.schemaId,
            color: item.color,
            filename: item.filename // Quan trọng: Giữ lại filename
        }));

        console.log('Successfully loaded palette data:', paletteItems.value);

    } catch (error) {
        console.error("Error loading or parsing manifest file:", error);
        paletteItems.value = []; // Reset nếu lỗi
        throw error;
    }
};

/**
 * Hàm bất đồng bộ để lấy hoặc tải cấu hình đầy đủ (bao gồm formSchema) của một schemaId.
 * Sẽ kiểm tra cache trước, nếu không có sẽ tải và parse file XML tương ứng.
 * @param {string} schemaId ID của schema cần lấy/load.
 * @returns {Promise<object | null>} Promise trả về đối tượng formSchema hoặc null nếu lỗi/không tìm thấy.
 */
export const getOrLoadFormSchema = async (schemaId) => {
    // 1. Kiểm tra cache trước
    if (loadedSchemasCache[schemaId]) {
        console.log(`Schema ${schemaId} found in cache.`);
        // Trả về formSchema từ cache
        return loadedSchemasCache[schemaId].formSchema;
    }

    // 2. Nếu không có trong cache, tìm thông tin file trong paletteItems
    const itemInfo = paletteItems.value.find(p => p.schemaId === schemaId);
    if (!itemInfo || !itemInfo.filename) {
        console.error(`Schema info or filename not found for schemaId: ${schemaId} in paletteItems.`);
        return null; // Không tìm thấy thông tin để load
    }

    // 3. Tải file XML cụ thể
    const xmlFilePath = `/templates/${itemInfo.filename}`;
    console.log(`Schema ${schemaId} not in cache. Loading from ${xmlFilePath}...`);
    try {
        const response = await fetch(xmlFilePath);
        if (!response.ok) {
            console.error(`HTTP error! status: ${response.status} while fetching ${xmlFilePath}`);
            return null; // Lỗi fetch
        }
        const xmlText = await response.text();

        // 4. Parse XML
        const fullSchemaData = parseSingleTemplateXML(xmlText, itemInfo.filename);

        if (fullSchemaData && fullSchemaData.formSchema) {
            // 5. Lưu vào cache
            loadedSchemasCache[schemaId] = fullSchemaData;
            console.log(`Schema ${schemaId} loaded and cached.`);
            // 6. Trả về formSchema
            return fullSchemaData.formSchema;
        } else {
            console.error(`Failed to parse valid schema data from ${xmlFilePath}`);
            return null; // Lỗi parse hoặc dữ liệu không hợp lệ
        }
    } catch (error) {
        console.error(`Error fetching or processing ${xmlFilePath}:`, error);
        return null; // Lỗi mạng hoặc lỗi khác
    }
};

/**
 * Helper để lấy formSchema đã được load (chỉ từ cache).
 * Dùng cho EditFormModal, giả định schema đã được load khi hình chữ nhật được tạo.
 * @param {string} schemaId
 * @returns {object} formSchema hoặc {} nếu không có trong cache.
 */
export const getCachedSchemaById = (schemaId) => {
    // Chỉ lấy từ cache, không trigger load mới ở đây
    const cachedData = loadedSchemasCache[schemaId];
    // Trả về một bản sao để tránh sửa đổi trực tiếp schema gốc trong cache
    return cachedData ? { ...cachedData.formSchema } : {};
};
3. Cập nhật src/components/drawing/DrawingCanvas.vue

Sử dụng paletteItems để render palette.
Truyền filename trong handleSourceDragStart.
Gọi getOrLoadFormSchema trong handleDrop.
Sử dụng getCachedSchemaById cho modal chỉnh sửa.
vue
// src/components/drawing/DrawingCanvas.vue
<template>
    <div v-if="isLoading" class="loading-indicator">
        Đang tải dữ liệu palette...
    </div>
    <div v-else-if="loadError" class="error-message">
        Lỗi tải dữ liệu palette. Vui lòng thử lại.
    </div>
    <div v-else class="drawing-app">
        <!-- Palette -->
        <div class="palette">
            <h3>Kéo từ đây:</h3>
            <!-- Sử dụng paletteItems -->
            <div v-for="item in paletteItems" :key="item.schemaId" class="source-rect" :style="{ backgroundColor: item.color }"
                draggable="true" @dragstart="handleSourceDragStart($event, item)"></div>
        </div>

        <!-- Canvas -->
        <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
            <h3>Thả vào đây:</h3>
            <!-- SVG Layer (không đổi) -->
            <svg class="connection-lines">
                <!-- ... defs và polyline ... -->
            </svg>

            <!-- Component DrawnRectangle (không đổi) -->
            <DrawnRectangle
                v-for="rect in drawnRectangles"
                :key="rect.id"
                :rect="rect"
                :prevent-drag="isModalVisible"
                @dragstart.stop="handleRectDragStart($event, rect)"
                @dragend="handleRectDragEnd"
                @contextmenu="showContextMenu($event, rect)"
                @open-edit="openEditModal"
            />
             <!-- Thêm chỉ báo loading khi đang load schema sau drop -->
            <div v-if="isSchemaLoading" class="schema-loading-overlay">
                Đang tải cấu hình...
            </div>
        </div>

        <!-- Component ContextMenu (không đổi) -->
        <!-- ... -->

        <!-- Component EditFormModal -->
        <EditFormModal
            :visible="isModalVisible"
            :rect-data="editingRect"
            :schema="getCachedSchemaForRect(editingRect)" <!-- Sử dụng hàm lấy schema từ cache -->
            @save="saveForm"
            @cancel="cancelForm"
        />
    </div>
</template>

<script setup>
/* eslint-disable */
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { debounce } from 'lodash-es';
import DrawnRectangle from './DrawnRectangle.vue';
import ContextMenu from './ContextMenu.vue';
import EditFormModal from './EditFormModal.vue';
// Import paletteItems và các hàm mới
import { paletteItems, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawingSchemas.js';
import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';

// State cho loading ban đầu và lỗi
const isLoading = ref(true);
const loadError = ref(false);
// State cho loading schema cụ thể khi drop
const isSchemaLoading = ref(false);

// --- State ---
const drawnRectangles = ref([]); // Đổi tên từ sourceData để rõ ràng hơn
const canvasRef = ref(null);
const defaultRectWidth = 50;
const defaultRectHeight = 50;
const draggingRectId = ref(null);
const currentOrder = ref(1);
const contextMenuRef = ref(null);
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null });
const isModalVisible = ref(false);
const editingRect = ref(null);

// --- Computed ---
const sortedRectangles = computed(() => {
    return drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
});

// --- Helpers ---
// Sử dụng hàm mới để lấy schema cho modal (chỉ từ cache)
const getCachedSchemaForRect = (rect) => {
    return rect ? getCachedSchemaById(rect.schemaId) : {};
};

// calculateElbowPoints (không đổi)
const calculateElbowPoints = (rectA, rectB) => {
    // ... (logic cũ)
     if (!rectA || !rectB) return "";
    let startX, endX;
    const startY = rectA.y + rectA.height / 2;
    const endY = rectB.y + rectB.height / 2;
    if (rectB.x >= rectA.x + rectA.width) {
        startX = rectA.x + rectA.width; endX = rectB.x;
    } else if (rectB.x + rectB.width <= rectA.x) {
        startX = rectA.x; endX = rectB.x + rectB.width;
    } else {
        startX = rectA.x + rectA.width; endX = rectB.x;
    }
    const midX = (startX + endX) / 2;
    return `${startX},${startY} ${midX},${startY} ${midX},${endY} ${endX},${endY}`;
};


// --- Lifecycle Hooks ---
onMounted(async () => {
    try {
        // Chỉ load dữ liệu cơ bản cho palette
        await loadPaletteData('/templates/manifest.json');
        loadError.value = false;
    } catch (error) {
        console.error("Failed to initialize DrawingCanvas due to palette data loading error:", error);
        loadError.value = true;
    } finally {
        isLoading.value = false;
    }

    // Listener cũ
    window.addEventListener('click', handleClickOutside);
    window.addEventListener('resize', handleWindowChange);
    window.addEventListener('scroll', handleWindowChange, true);
});

onUnmounted(() => {
    // Gỡ listener như cũ
    window.removeEventListener('click', handleClickOutside);
    window.removeEventListener('resize', handleWindowChange);
    window.removeEventListener('scroll', handleWindowChange, true);
    handleWindowChange.cancel?.();
});

// --- Event Handlers ---

// handleWindowChange, handleClickOutside, showContextMenu, closeContextMenu, handleEdit, handleDelete (không đổi)
// ...

// Modal Handlers (openEditModal, saveForm, cancelForm) (không đổi)
// ...

// --- Drag and Drop Handlers ---

const handleSourceDragStart = (event, item) => {
    closeContextMenu();
    // Truyền thông tin cần thiết, bao gồm cả filename
    const dataToTransfer = {
        schemaId: item.schemaId,
        color: item.color,
        filename: item.filename // Quan trọng: truyền filename
    };
    try {
        const dataStr = JSON.stringify(dataToTransfer);
        event.dataTransfer.setData(SOURCE_ITEM_DATA_TYPE, dataStr);
        event.dataTransfer.effectAllowed = 'copy';
        draggingRectId.value = null;
        // console.log('Source Drag Start - Data:', dataStr);
    } catch (e) {
        console.error("Source Drag Start Error:", e, dataToTransfer);
    }
};

// handleRectDragStart, handleRectDragEnd, handleDragOver (không đổi)
// ...

// handleDrop cần sửa đổi để load schema khi cần
const handleDrop = async (event) => { // Chuyển thành async
    event.preventDefault();
    closeContextMenu();
    const canvasRect = canvasRef.value?.getBoundingClientRect();
    if (!canvasRect) { console.error('Drop Error: Cannot get canvas bounds.'); draggingRectId.value = null; return; }

    const dropX = event.clientX - canvasRect.left;
    const dropY = event.clientY - canvasRect.top;

    const draggedRectIdStr = event.dataTransfer.getData(RECT_ID_DATA_TYPE);

    // --- MOVE --- (Không đổi)
    if (draggedRectIdStr) {
        // ... (logic di chuyển cũ)
        try {
            const draggedRectId = parseInt(draggedRectIdStr, 10);
            const offsetData = event.dataTransfer.getData(DRAG_OFFSET_DATA_TYPE);
            let offsetX = 0, offsetY = 0;
            try { const offset = JSON.parse(offsetData || '{}'); offsetX = offset.x || 0; offsetY = offset.y || 0; }
            catch (e) { console.warn('Could not parse drag offset data:', offsetData, e); }
            const rectToMove = drawnRectangles.value.find(r => r.id === draggedRectId);
            if (rectToMove) { rectToMove.x = dropX - offsetX; rectToMove.y = dropY - offsetY; }
            else { console.error(`Move Error: Cannot find rect with ID ${draggedRectId}.`); }
        } catch (e) { console.error("Error processing move drop:", e); }

    }
    // --- CREATE NEW --- (Sửa đổi để load schema)
    else {
        const sourceItemDataStr = event.dataTransfer.getData(SOURCE_ITEM_DATA_TYPE);
        if (sourceItemDataStr) {
            let sourceItemData;
            try {
                sourceItemData = JSON.parse(sourceItemDataStr);
                console.log('Handling CREATE NEW for:', sourceItemData);

                // --- Load Schema On Demand ---
                isSchemaLoading.value = true; // Bắt đầu loading
                let formSchema = null;
                try {
                    // Gọi hàm để lấy/load formSchema dựa trên schemaId
                    formSchema = await getOrLoadFormSchema(sourceItemData.schemaId);
                } finally {
                    isSchemaLoading.value = false; // Kết thúc loading
                }
                // -----------------------------

                if (formSchema === null) {
                     // Xử lý trường hợp không load được schema (ví dụ: dùng schema rỗng)
                     console.error(`Failed to load formSchema for ${sourceItemData.schemaId}. Creating rect with empty formData.`);
                     formSchema = {}; // Hoặc không tạo rect nữa tùy yêu cầu
                }

                // Tạo formData từ schema đã load (hoặc schema rỗng nếu lỗi)
                // Cần clone để mỗi hình chữ nhật có bản sao riêng
                let initialFormData;
                 try {
                    initialFormData = structuredClone(formSchema);
                 } catch(e) {
                    console.warn("structuredClone failed for initial form data, using JSON fallback.");
                    initialFormData = JSON.parse(JSON.stringify(formSchema));
                 }


                const newRect = {
                    id: Date.now(),
                    color: sourceItemData.color,
                    schemaId: sourceItemData.schemaId,
                    x: dropX - defaultRectWidth / 2,
                    y: dropY - defaultRectHeight / 2,
                    width: defaultRectWidth,
                    height: defaultRectHeight,
                    order: currentOrder.value,
                    formData: initialFormData // Sử dụng formData từ schema đã load
                };
                drawnRectangles.value.push(newRect);
                currentOrder.value++;

            } catch (e) {
                console.error("Drop Error: Failed to process source item or load schema:", e, sourceItemDataStr);
                 isSchemaLoading.value = false; // Đảm bảo tắt loading nếu có lỗi sớm
            }
        } else {
            console.warn('Drop Warning: No valid data found.');
        }
    }
    draggingRectId.value = null;
};

</script>

<style scoped>
/* Thêm style cho overlay loading schema */
.schema-loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.2em;
    color: #333;
    z-index: 10; /* Đảm bảo nó nổi lên trên */
}

/* Các style cũ */
.loading-indicator, .error-message { /* ... */ }
.drawing-app { /* ... */ }
.palette { /* ... */ }
.canvas { /* ... */ }
.connection-lines { /* ... */ }
</style>
Tổng kết thay đổi:

Manifest: Chứa schemaId, color, filename.
drawingSchemas.js:
paletteItems: Chỉ lưu trữ thông tin cơ bản từ manifest.
loadedSchemasCache: Lưu trữ các schema đầy đủ đã được load.
loadPaletteData: Chỉ load manifest vào paletteItems.
getOrLoadFormSchema: Hàm chính để lấy/load schema theo yêu cầu, sử dụng cache và fetch file XML khi cần.
getCachedSchemaById: Chỉ lấy schema từ cache (dùng cho modal).
DrawingCanvas.vue:
Render palette từ paletteItems.
handleSourceDragStart: Truyền filename trong dataTransfer.
handleDrop: Gọi await getOrLoadFormSchema() khi tạo hình mới. Sử dụng isSchemaLoading để hiển thị chỉ báo loading.
Sử dụng getCachedSchemaForRect khi mở modal chỉnh sửa.
Giờ đây, ứng dụng sẽ chỉ tải cấu hình XML chi tiết của một mẫu khi người dùng thả mẫu đó lên canvas lần đầu tiên. Các lần thả tiếp theo của cùng một mẫu sẽ sử dụng dữ liệu từ cache.

Rate this answer: 

Tùng Giang Lâm
export 'getSchemaById' (imported as 'getSchemaById') was not found in '../../data/drawingSchemas.js' (possible exports: getCachedSchemaById, getOrLoadFormSchema, loadPaletteData, paletteItems) có cần hàm này nữa không


Gemini
Chính xác, bạn đã phát hiện ra một điểm quan trọng!

Dựa trên lỗi export 'getSchemaById' (imported as 'getSchemaById') was not found in '../../data/drawingSchemas.js' và cách chúng ta đã cấu trúc lại logic để load schema theo yêu cầu (getOrLoadFormSchema) và lấy schema từ cache (getCachedSchemaById), thì:

Hàm getSchemaById không còn tồn tại trong drawingSchemas.js: Chúng ta đã thay thế nó bằng các hàm chuyên biệt hơn.
Hàm getSchemaForRect trong DrawingCanvas.vue không còn cần thiết: Hàm này được tạo ra để gọi getSchemaById cũ. Vì getSchemaById không còn và modal chỉnh sửa (EditFormModal) giờ đây đã sử dụng getCachedSchemaForRect (mà hàm này gọi getCachedSchemaById hợp lệ), nên getSchemaForRect trở nên thừa thãi.
Kết luận:

Không, bạn không cần hàm getSchemaById nữa. Nó đã được thay thế bởi getOrLoadFormSchema (để load khi thả) và getCachedSchemaById (để lấy từ cache cho việc chỉnh sửa).

Cách sửa lỗi:

Xóa import không cần thiết: Trong DrawingCanvas.vue, xóa getSchemaById khỏi dòng import:

javascript
// Thay đổi dòng này:
// import { sourceData, getSchemaById, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawingSchemas.js';
// Thành dòng này:
import { paletteItems, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawingSchemas.js';
// Đồng thời, bạn cũng không cần sourceData nữa, vì bạn đang dùng paletteItems
Lưu ý: Bạn cũng cần sửa v-for="item in sourceData" trong template thành v-for="item in paletteItems".

Xóa hàm helper không cần thiết: Trong DrawingCanvas.vue, xóa toàn bộ hàm getSchemaForRect:

javascript
// XÓA BỎ HOÀN TOÀN KHỐI NÀY:
// // --- Helpers ---
// const getSchemaForRect = (rect) => {
//     return rect ? getSchemaById(rect.schemaId) : {};
// };
Code DrawingCanvas.vue sau khi sửa:

vue
<template>
    <div v-if="isLoading" class="loading-indicator">
        Đang tải dữ liệu palette...
    </div>
    <div v-else-if="loadError" class="error-message">
        Lỗi tải dữ liệu palette. Vui lòng thử lại.
    </div>

    <div v-else class="drawing-app">
        <!-- Palette -->
        <div class="palette">
            <h3>Kéo từ đây:</h3>
            <!-- Sửa sourceData thành paletteItems -->
            <div v-for="item in paletteItems" :key="item.schemaId" class="source-rect"
                :style="{ backgroundColor: item.color }" draggable="true"
                @dragstart="handleSourceDragStart($event, item)"></div>
        </div>

        <!-- Canvas -->
        <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
            <h3>Thả vào đây:</h3>

            <!-- SVG Layer cho đường nối gấp khúc -->
            <svg class="connection-lines">
                <defs>
                    <!-- Định nghĩa marker mũi tên -->
                    <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3"
                        orient="auto-start-reverse" markerUnits="strokeWidth">
                        <!-- Hình dạng mũi tên (tam giác) - giữ nguyên -->
                        <path d="M0,0 L8,3 L0,6 Z" fill="#555" />
                    </marker>
                </defs>
                <g>
                    <!-- Lặp qua các cặp hình chữ nhật liền kề theo thứ tự -->
                    <template v-for="(rect, index) in sortedRectangles" :key="rect.id + '-elbow'">
                        <template v-if="index < sortedRectangles.length - 1">
                            <polyline :points="calculateElbowPoints(rect, sortedRectangles[index + 1])" fill="none"
                                stroke="#555" stroke-width="1.5" stroke-dasharray="4, 4" marker-end="url(#arrowhead)" />
                        </template>
                    </template>
                </g>
            </svg>

            <!-- Component DrawnRectangle -->
            <DrawnRectangle v-for="rect in drawnRectangles" :key="rect.id" :rect="rect" :prevent-drag="isModalVisible"
                @dragstart.stop="handleRectDragStart($event, rect)" @dragend="handleRectDragEnd"
                @contextmenu="showContextMenu($event, rect)" @open-edit="openEditModal" />

            <!-- Thêm chỉ báo loading khi đang load schema sau drop -->
            <div v-if="isSchemaLoading" class="schema-loading-overlay">
                Đang tải cấu hình...
            </div>
        </div>

        <!-- Component ContextMenu -->
        <ContextMenu :visible="contextMenu.visible" :top="contextMenu.top" :left="contextMenu.left" @edit="handleEdit"
            @delete="handleDelete" ref="contextMenuRef" />

        <!-- Component EditFormModal -->
        <EditFormModal
            :visible="isModalVisible"
            :rect-data="editingRect"
            :schema="getCachedSchemaForRect(editingRect)"
            @save="saveForm"
            @cancel="cancelForm"
        />
    </div>
</template>

<script setup>
/* eslint-disable */
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { debounce } from 'lodash-es';
import DrawnRectangle from './DrawnRectangle.vue';
import ContextMenu from './ContextMenu.vue';
import EditFormModal from './EditFormModal.vue';
// Xóa getSchemaById và sourceData khỏi import, thêm paletteItems
import { paletteItems, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawingSchemas.js';

import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';


// Thêm state cho trạng thái loading và lỗi
const isLoading = ref(true);
const loadError = ref(false);

// State cho loading schema cụ thể khi drop
const isSchemaLoading = ref(false);

// --- State ---
const drawnRectangles = ref([]);
const canvasRef = ref(null);
const defaultRectWidth = 50;
const defaultRectHeight = 50;
const draggingRectId = ref(null);
const currentOrder = ref(1);
const contextMenuRef = ref(null);
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null });
const isModalVisible = ref(false);
const editingRect = ref(null);

// --- Computed ---
const sortedRectangles = computed(() => {
    return drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
});

// --- Helpers ---
// Sử dụng hàm mới để lấy schema cho modal (chỉ từ cache)
const getCachedSchemaForRect = (rect) => {
    return rect ? getCachedSchemaById(rect.schemaId) : {};
};

// XÓA BỎ HÀM getSchemaForRect không còn cần thiết
// const getSchemaForRect = (rect) => {
//     return rect ? getSchemaById(rect.schemaId) : {};
// };

// --- UPDATED calculateElbowPoints --- (Không đổi)
const calculateElbowPoints = (rectA, rectB) => {
    // ... (logic cũ)
     if (!rectA || !rectB) return "";
    let startX, endX;
    const startY = rectA.y + rectA.height / 2;
    const endY = rectB.y + rectB.height / 2;
    if (rectB.x >= rectA.x + rectA.width) {
        startX = rectA.x + rectA.width; endX = rectB.x;
    } else if (rectB.x + rectB.width <= rectA.x) {
        startX = rectA.x; endX = rectB.x + rectB.width;
    } else {
        startX = rectA.x + rectA.width; endX = rectB.x;
    }
    const midX = (startX + endX) / 2;
    return `${startX},${startY} ${midX},${startY} ${midX},${endY} ${endX},${endY}`;
};


// --- Event Handlers --- (Không đổi)
const handleWindowChange = debounce(() => { /* ... */ }, 150);

// --- Lifecycle Hooks --- (Không đổi)
onMounted(async () => { /* ... */ });
onUnmounted(() => { /* ... */ });

// --- Event Handlers --- (Các hàm còn lại không đổi)
const handleClickOutside = (event) => { /* ... */ };
const showContextMenu = (event, rect) => { /* ... */ };
const closeContextMenu = () => { /* ... */ };
const handleEdit = () => { /* ... */ };
const handleDelete = () => { /* ... */ };
const openEditModal = (rect) => { /* ... */ };
const saveForm = (updatedFormData) => { /* ... */ };
const cancelForm = () => { /* ... */ };
const handleSourceDragStart = (event, item) => { /* ... */ };
const handleRectDragStart = (event, rect) => { /* ... */ };
const handleRectDragEnd = (event) => { /* ... */ };
const handleDragOver = (event) => { /* ... */ };
const handleDrop = async (event) => { /* ... */ }; // Logic bên trong handleDrop đã đúng
</script>

<style scoped>
/* ... (CSS không đổi) ... */
</style>
Rate this answer: 

Tùng Giang Lâm
với code hiện tại, các hình mẫu không được hiển thị để kéo. Tôi nghĩ vẫn phải load đầu đã, sau đó load lại mỗi lần cần


Gemini
Bạn đã chỉ ra đúng vấn đề cốt lõi! Lỗi xảy ra do hai điểm:

Sai biến trong v-for: Template của DrawingCanvas.vue vẫn đang cố gắng lặp qua sourceData (v-for="item in sourceData") để hiển thị các khối màu trong palette. Tuy nhiên, sau khi cấu trúc lại, dữ liệu cho palette giờ nằm trong biến paletteItems.
Thiếu import paletteItems: Trong phần <script setup> của DrawingCanvas.vue, paletteItems chưa được import từ drawingSchemas.js.
Cách sửa lỗi:

Import paletteItems: Thêm paletteItems vào danh sách import từ drawingSchemas.js.
Sửa v-for: Thay đổi v-for="item in sourceData" thành v-for="item in paletteItems" trong template.
Code DrawingCanvas.vue đã sửa:

vue
<template>
    <div v-if="isLoading" class="loading-indicator">
        Đang tải dữ liệu palette...
    </div>
    <div v-else-if="loadError" class="error-message">
        Lỗi tải dữ liệu palette. Vui lòng thử lại.
    </div>

    <div v-else class="drawing-app">
        <!-- Palette -->
        <div class="palette">
            <h3>Kéo từ đây:</h3>
            <!-- Sửa sourceData thành paletteItems -->
            <div v-for="item in paletteItems" :key="item.schemaId" class="source-rect"
                :style="{ backgroundColor: item.color }" draggable="true"
                @dragstart="handleSourceDragStart($event, item)"></div>
        </div>

        <!-- Canvas -->
        <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
            <h3>Thả vào đây:</h3>

            <!-- SVG Layer cho đường nối gấp khúc -->
            <svg class="connection-lines">
                <defs>
                    <!-- Định nghĩa marker mũi tên -->
                    <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3"
                        orient="auto-start-reverse" markerUnits="strokeWidth">
                        <!-- Hình dạng mũi tên (tam giác) - giữ nguyên -->
                        <path d="M0,0 L8,3 L0,6 Z" fill="#555" />
                    </marker>
                </defs>
                <g>
                    <!-- Lặp qua các cặp hình chữ nhật liền kề theo thứ tự -->
                    <template v-for="(rect, index) in sortedRectangles" :key="rect.id + '-elbow'">
                        <template v-if="index < sortedRectangles.length - 1">
                            <polyline :points="calculateElbowPoints(rect, sortedRectangles[index + 1])" fill="none"
                                stroke="#555" stroke-width="1.5" stroke-dasharray="4, 4" marker-end="url(#arrowhead)" />
                        </template>
                    </template>
                </g>
            </svg>

            <!-- Component DrawnRectangle -->
            <DrawnRectangle v-for="rect in drawnRectangles" :key="rect.id" :rect="rect" :prevent-drag="isModalVisible"
                @dragstart.stop="handleRectDragStart($event, rect)" @dragend="handleRectDragEnd"
                @contextmenu="showContextMenu($event, rect)" @open-edit="openEditModal" />

            <!-- Thêm chỉ báo loading khi đang load schema sau drop -->
            <div v-if="isSchemaLoading" class="schema-loading-overlay">
                Đang tải cấu hình...
            </div>
        </div>

        <!-- Component ContextMenu -->
        <ContextMenu :visible="contextMenu.visible" :top="contextMenu.top" :left="contextMenu.left" @edit="handleEdit"
            @delete="handleDelete" ref="contextMenuRef" />

        <!-- Component EditFormModal -->
        <EditFormModal
            :visible="isModalVisible"
            :rect-data="editingRect"
            :schema="getCachedSchemaForRect(editingRect)"
            @save="saveForm"
            @cancel="cancelForm"
        />
    </div>
</template>

<script setup>
/* eslint-disable */
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { debounce } from 'lodash-es';
import DrawnRectangle from './DrawnRectangle.vue';
import ContextMenu from './ContextMenu.vue';
import EditFormModal from './EditFormModal.vue';
// Thêm paletteItems vào import
import { paletteItems, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawingSchemas.js';

import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';


// Thêm state cho trạng thái loading và lỗi
const isLoading = ref(true);
const loadError = ref(false);

// State cho loading schema cụ thể khi drop
const isSchemaLoading = ref(false);

// --- State ---
const drawnRectangles = ref([]);
const canvasRef = ref(null);
const defaultRectWidth = 50;
const defaultRectHeight = 50;
const draggingRectId = ref(null);
const currentOrder = ref(1);
const contextMenuRef = ref(null);
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null });
const isModalVisible = ref(false);
const editingRect = ref(null);

// --- Computed ---
const sortedRectangles = computed(() => {
    return drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
});

// --- Helpers ---
// Sử dụng hàm mới để lấy schema cho modal (chỉ từ cache)
const getCachedSchemaForRect = (rect) => {
    return rect ? getCachedSchemaById(rect.schemaId) : {};
};

// --- UPDATED calculateElbowPoints --- (Không đổi)
const calculateElbowPoints = (rectA, rectB) => { /* ... */ };

// --- Event Handlers --- (Không đổi)
const handleWindowChange = debounce(() => { /* ... */ }, 150);

// --- Lifecycle Hooks --- (Không đổi)
onMounted(async () => { /* ... */ }); // Logic loadPaletteData đã đúng
onUnmounted(() => { /* ... */ });

// --- Event Handlers --- (Các hàm còn lại không đổi)
const handleClickOutside = (event) => { /* ... */ };
const showContextMenu = (event, rect) => { /* ... */ };
const closeContextMenu = () => { /* ... */ };
const handleEdit = () => { /* ... */ };
const handleDelete = () => { /* ... */ };
const openEditModal = (rect) => { /* ... */ };
const saveForm = (updatedFormData) => { /* ... */ };
const cancelForm = () => { /* ... */ };
const handleSourceDragStart = (event, item) => { /* ... */ }; // Logic đã đúng
const handleRectDragStart = (event, rect) => { /* ... */ };
const handleRectDragEnd = (event) => { /* ... */ };
const handleDragOver = (event) => { /* ... */ };
const handleDrop = async (event) => { /* ... */ }; // Logic load schema khi drop đã đúng
</script>

<style scoped>
/* ... (CSS không đổi) ... */
</style>
Giải thích:

Hàm loadPaletteData được gọi trong onMounted sẽ fetch manifest.json và cập nhật paletteItems.value.
Vì paletteItems là một ref, Vue sẽ tự động phát hiện sự thay đổi này.
Template sử dụng v-for="item in paletteItems" sẽ render lại và hiển thị các khối màu dựa trên dữ liệu mới trong paletteItems.
Với thay đổi này, các hình mẫu sẽ được hiển thị chính xác trong palette sau khi manifest.json được tải thành công. Việc load cấu hình XML chi tiết vẫn được trì hoãn cho đến khi người dùng thả hình vào canvas.

Rate this answer: 

Tùng Giang Lâm
bạn hãy viết file DrawingCanvas đầy đủ giúp tôi


Gemini
Chắc chắn rồi, đây là nội dung đầy đủ của file src/components/drawing/DrawingCanvas.vue đã được cập nhật để sử dụng paletteItems cho việc hiển thị palette và import đúng các thành phần cần thiết:

vue
<template>
    <div v-if="isLoading" class="loading-indicator">
        Đang tải dữ liệu palette...
    </div>
    <div v-else-if="loadError" class="error-message">
        Lỗi tải dữ liệu palette. Vui lòng thử lại.
    </div>

    <div v-else class="drawing-app">
        <!-- Palette -->
        <div class="palette">
            <h3>Kéo từ đây:</h3>
            <!-- Sửa sourceData thành paletteItems -->
            <div v-for="item in paletteItems" :key="item.schemaId" class="source-rect"
                :style="{ backgroundColor: item.color }" draggable="true"
                @dragstart="handleSourceDragStart($event, item)"></div>
        </div>

        <!-- Canvas -->
        <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
            <h3>Thả vào đây:</h3>

            <!-- SVG Layer cho đường nối gấp khúc -->
            <svg class="connection-lines">
                <defs>
                    <!-- Định nghĩa marker mũi tên -->
                    <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3"
                        orient="auto-start-reverse" markerUnits="strokeWidth">
                        <!-- Hình dạng mũi tên (tam giác) - giữ nguyên -->
                        <path d="M0,0 L8,3 L0,6 Z" fill="#555" />
                    </marker>
                    <!-- Alternative marker if needed for start -->
                    <!-- <marker id="arrowtail" ... /> -->
                </defs>
                <g>
                    <!-- Lặp qua các cặp hình chữ nhật liền kề theo thứ tự -->
                    <template v-for="(rect, index) in sortedRectangles" :key="rect.id + '-elbow'">
                        <template v-if="index < sortedRectangles.length - 1">
                            <polyline :points="calculateElbowPoints(rect, sortedRectangles[index + 1])" fill="none"
                                stroke="#555" stroke-width="1.5" stroke-dasharray="4, 4" marker-end="url(#arrowhead)" />
                        </template>
                    </template>
                </g>
            </svg>

            <!-- Component DrawnRectangle -->
            <DrawnRectangle v-for="rect in drawnRectangles" :key="rect.id" :rect="rect" :prevent-drag="isModalVisible"
                @dragstart.stop="handleRectDragStart($event, rect)" @dragend="handleRectDragEnd"
                @contextmenu="showContextMenu($event, rect)" @open-edit="openEditModal" />

            <!-- Thêm chỉ báo loading khi đang load schema sau drop -->
            <div v-if="isSchemaLoading" class="schema-loading-overlay">
                Đang tải cấu hình...
            </div>
        </div>

        <!-- Component ContextMenu -->
        <ContextMenu :visible="contextMenu.visible" :top="contextMenu.top" :left="contextMenu.left" @edit="handleEdit"
            @delete="handleDelete" ref="contextMenuRef" />

        <!-- Component EditFormModal -->
        <EditFormModal
            :visible="isModalVisible"
            :rect-data="editingRect"
            :schema="getCachedSchemaForRect(editingRect)"
            @save="saveForm"
            @cancel="cancelForm"
        />
    </div>
</template>

<script setup>
/* eslint-disable */
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { debounce } from 'lodash-es';
import DrawnRectangle from './DrawnRectangle.vue';
import ContextMenu from './ContextMenu.vue';
import EditFormModal from './EditFormModal.vue';
// Thêm paletteItems vào import
import { paletteItems, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawingSchemas.js';

import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';


// Thêm state cho trạng thái loading và lỗi
const isLoading = ref(true);
const loadError = ref(false);

// State cho loading schema cụ thể khi drop
const isSchemaLoading = ref(false);

// --- State ---
const drawnRectangles = ref([]);
const canvasRef = ref(null);
const defaultRectWidth = 50;
const defaultRectHeight = 50;
const draggingRectId = ref(null);
const currentOrder = ref(1);
const contextMenuRef = ref(null);
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null });
const isModalVisible = ref(false);
const editingRect = ref(null);

// --- Computed ---
const sortedRectangles = computed(() => {
    return drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
});

// --- Helpers ---
// Sử dụng hàm mới để lấy schema cho modal (chỉ từ cache)
const getCachedSchemaForRect = (rect) => {
    return rect ? getCachedSchemaById(rect.schemaId) : {};
};

// --- UPDATED calculateElbowPoints ---
const calculateElbowPoints = (rectA, rectB) => {
    if (!rectA || !rectB) {
        return "";
    }

    let startX, endX;
    const startY = rectA.y + rectA.height / 2; // Vertical center of A
    const endY = rectB.y + rectB.height / 2;   // Vertical center of B

    // Determine start and end edges based on relative horizontal position
    if (rectB.x >= rectA.x + rectA.width) {
        // Target is clearly to the RIGHT of source
        startX = rectA.x + rectA.width; // Start from right edge of A
        endX = rectB.x;                 // End at left edge of B
        // console.log(`Points ${rectA.order}->${rectB.order}: RIGHT connection`);
    } else if (rectB.x + rectB.width <= rectA.x) {
        // Target is clearly to the LEFT of source
        startX = rectA.x;                 // Start from left edge of A
        endX = rectB.x + rectB.width;   // End at right edge of B
        // console.log(`Points ${rectA.order}->${rectB.order}: LEFT connection`);
    } else {
        // Rectangles overlap horizontally or are very close.
        // Defaulting to right-of-A to left-of-B connection.
        startX = rectA.x + rectA.width;
        endX = rectB.x;
        // console.log(`Points ${rectA.order}->${rectB.order}: OVERLAP/CLOSE connection (defaulting right->left)`);
    }

    // Calculate corner points for the elbow
    const midX = (startX + endX) / 2; // Horizontal midpoint
    const pointsStr = `${startX},${startY} ${midX},${startY} ${midX},${endY} ${endX},${endY}`;

    // console.log('Calculated points string:', pointsStr);
    return pointsStr;
};


// --- Event Handlers ---
const handleWindowChange = debounce(() => {
    if (contextMenu.value.visible) {
        // console.log('Window changed (resize/scroll), closing context menu.');
        closeContextMenu();
    }
}, 150);

// --- Lifecycle Hooks ---
onMounted(async () => {

    try {
        // Chỉ load dữ liệu cơ bản cho palette
        await loadPaletteData('/templates/manifest.json');
        loadError.value = false;
    } catch (error) {
        console.error("Failed to initialize DrawingCanvas due to palette data loading error:", error);
        loadError.value = true;
    } finally {
        isLoading.value = false;
    }

    window.addEventListener('click', handleClickOutside);
    window.addEventListener('resize', handleWindowChange);
    window.addEventListener('scroll', handleWindowChange, true);
});
onUnmounted(() => {
    window.removeEventListener('click', handleClickOutside);
    window.removeEventListener('resize', handleWindowChange);
    window.removeEventListener('scroll', handleWindowChange, true);
    handleWindowChange.cancel?.(); // Use optional chaining for cancel
});

// --- Event Handlers --- (Rest of the handlers remain unchanged)
const handleClickOutside = (event) => {
    const contextMenuElement = contextMenuRef.value?.$el || contextMenuRef.value;
    const isClickInsideMenu = contextMenuElement instanceof Element && contextMenuElement.contains(event.target);
    if (contextMenu.value.visible && !isClickInsideMenu) {
        closeContextMenu();
    }
};

const showContextMenu = (event, rect) => {
    if (isModalVisible.value) return;
    if (contextMenu.value.visible) closeContextMenu();
    event.preventDefault();
    contextMenu.value = {
        visible: true,
        top: event.clientY,
        left: event.clientX,
        targetRectId: rect.id,
        targetRectOrder: rect.order
    };
};

const closeContextMenu = () => {
    if (contextMenu.value.visible) {
        contextMenu.value.visible = false;
        contextMenu.value.targetRectId = null;
        contextMenu.value.targetRectOrder = null;
    }
};

const handleEdit = () => {
    if (contextMenu.value.targetRectId) {
        const rectToEdit = drawnRectangles.value.find(r => r.id === contextMenu.value.targetRectId);
        if (rectToEdit) openEditModal(rectToEdit);
    }
    closeContextMenu();
};

const handleDelete = () => {
    const idToDelete = contextMenu.value.targetRectId;
    closeContextMenu();
    if (idToDelete !== null) {
        const indexToDelete = drawnRectangles.value.findIndex(r => r.id === idToDelete);
        if (indexToDelete > -1) {
            drawnRectangles.value.splice(indexToDelete, 1);
            const remainingSorted = drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
            remainingSorted.forEach((rect, index) => { rect.order = index + 1; });
            currentOrder.value = drawnRectangles.value.length + 1;
            // console.log(`Đã xóa hình ID: ${idToDelete}. Thứ tự cập nhật. Current order: ${currentOrder.value}`);
        }
    }
};

const openEditModal = (rect) => {
    if (!rect || draggingRectId.value !== null) return;
    closeContextMenu();
    try {
        editingRect.value = { ...rect, formData: structuredClone(rect.formData || {}) };
    } catch (e) {
        console.warn("structuredClone failed, using JSON fallback.");
        editingRect.value = { ...rect, formData: JSON.parse(JSON.stringify(rect.formData || {})) };
    }
    isModalVisible.value = true;
};

const saveForm = (updatedFormData) => {
    if (!editingRect.value) return;
    const originalRectIndex = drawnRectangles.value.findIndex(r => r.id === editingRect.value.id);
    if (originalRectIndex > -1) {
        // console.log("Lưu dữ liệu từ modal:", updatedFormData);
        try {
            drawnRectangles.value[originalRectIndex].formData = structuredClone(updatedFormData);
        } catch (e) {
            console.warn("structuredClone failed during save, using JSON fallback.");
            drawnRectangles.value[originalRectIndex].formData = JSON.parse(JSON.stringify(updatedFormData));
        }
    }
    cancelForm();
};

const cancelForm = () => {
    isModalVisible.value = false;
    editingRect.value = null;
};

const handleSourceDragStart = (event, item) => {
    closeContextMenu();
    // Truyền thông tin cần thiết, bao gồm cả filename
    const dataToTransfer = {
        schemaId: item.schemaId,
        color: item.color,
        filename: item.filename // Quan trọng: truyền filename
    };
    try {
        const dataStr = JSON.stringify(dataToTransfer);
        event.dataTransfer.setData(SOURCE_ITEM_DATA_TYPE, dataStr);
        event.dataTransfer.effectAllowed = 'copy';
        draggingRectId.value = null;
        // console.log('Source Drag Start - Data:', dataStr);
    } catch (e) {
        console.error("Source Drag Start Error:", e, dataToTransfer);
    }
};

const handleRectDragStart = (event, rect) => {
    if (contextMenu.value.visible) closeContextMenu();
    if (isModalVisible.value) { event.preventDefault(); return; }
    try {
        event.dataTransfer.setData(RECT_ID_DATA_TYPE, rect.id.toString());
        const offsetX = event.offsetX;
        const offsetY = event.offsetY;
        const offsetData = JSON.stringify({ x: offsetX, y: offsetY });
        event.dataTransfer.setData(DRAG_OFFSET_DATA_TYPE, offsetData);
        event.dataTransfer.effectAllowed = 'move';
        draggingRectId.value = rect.id;
        // console.log(`Bắt đầu kéo hình ID: ${rect.id} với offset:`, offsetData);
    } catch (e) {
        console.error("Rect Drag Start Error:", e);
        event.preventDefault();
    }
};

const handleRectDragEnd = (event) => {
    draggingRectId.value = null;
    // console.log(`Kết thúc kéo hình`);
};

const handleDragOver = (event) => {
    event.preventDefault();
    if (event.dataTransfer.types.includes(RECT_ID_DATA_TYPE)) {
        event.dataTransfer.dropEffect = "move";
    } else if (event.dataTransfer.types.includes(SOURCE_ITEM_DATA_TYPE)) {
        event.dataTransfer.dropEffect = "copy";
    } else {
        event.dataTransfer.dropEffect = "none";
    }
};

// handleDrop cần sửa đổi để load schema khi cần
const handleDrop = async (event) => { // Chuyển thành async
    event.preventDefault();
    closeContextMenu();
    const canvasRect = canvasRef.value?.getBoundingClientRect();
    if (!canvasRect) { console.error('Drop Error: Cannot get canvas bounds.'); draggingRectId.value = null; return; }

    const dropX = event.clientX - canvasRect.left;
    const dropY = event.clientY - canvasRect.top;

    const draggedRectIdStr = event.dataTransfer.getData(RECT_ID_DATA_TYPE);

    // --- MOVE --- (Không đổi)
    if (draggedRectIdStr) {
        // ... (logic di chuyển cũ)
        try {
            const draggedRectId = parseInt(draggedRectIdStr, 10);
            const offsetData = event.dataTransfer.getData(DRAG_OFFSET_DATA_TYPE);
            let offsetX = 0, offsetY = 0;
            try { const offset = JSON.parse(offsetData || '{}'); offsetX = offset.x || 0; offsetY = offset.y || 0; }
            catch (e) { console.warn('Could not parse drag offset data:', offsetData, e); }
            const rectToMove = drawnRectangles.value.find(r => r.id === draggedRectId);
            if (rectToMove) { rectToMove.x = dropX - offsetX; rectToMove.y = dropY - offsetY; }
            else { console.error(`Move Error: Cannot find rect with ID ${draggedRectId}.`); }
        } catch (e) { console.error("Error processing move drop:", e); }

    }
    // --- CREATE NEW --- (Sửa đổi để load schema)
    else {
        const sourceItemDataStr = event.dataTransfer.getData(SOURCE_ITEM_DATA_TYPE);
        if (sourceItemDataStr) {
            let sourceItemData;
            try {
                sourceItemData = JSON.parse(sourceItemDataStr);
                console.log('Handling CREATE NEW for:', sourceItemData);

                // --- Load Schema On Demand ---
                isSchemaLoading.value = true; // Bắt đầu loading
                let formSchema = null;
                try {
                    // Gọi hàm để lấy/load formSchema dựa trên schemaId
                    formSchema = await getOrLoadFormSchema(sourceItemData.schemaId);
                } finally {
                    isSchemaLoading.value = false; // Kết thúc loading
                }
                // -----------------------------

                if (formSchema === null) {
                     // Xử lý trường hợp không load được schema (ví dụ: dùng schema rỗng)
                     console.error(`Failed to load formSchema for ${sourceItemData.schemaId}. Creating rect with empty formData.`);
                     formSchema = {}; // Hoặc không tạo rect nữa tùy yêu cầu
                }

                // Tạo formData từ schema đã load (hoặc schema rỗng nếu lỗi)
                // Cần clone để mỗi hình chữ nhật có bản sao riêng
                let initialFormData;
                 try {
                    initialFormData = structuredClone(formSchema);
                 } catch(e) {
                    console.warn("structuredClone failed for initial form data, using JSON fallback.");
                    initialFormData = JSON.parse(JSON.stringify(formSchema));
                 }


                const newRect = {
                    id: Date.now(),
                    color: sourceItemData.color,
                    schemaId: sourceItemData.schemaId,
                    x: dropX - defaultRectWidth / 2,
                    y: dropY - defaultRectHeight / 2,
                    width: defaultRectWidth,
                    height: defaultRectHeight,
                    order: currentOrder.value,
                    formData: initialFormData // Sử dụng formData từ schema đã load
                };
                drawnRectangles.value.push(newRect);
                currentOrder.value++;

            } catch (e) {
                console.error("Drop Error: Failed to process source item or load schema:", e, sourceItemDataStr);
                 isSchemaLoading.value = false; // Đảm bảo tắt loading nếu có lỗi sớm
            }
        } else {
            console.warn('Drop Warning: No valid data found.');
        }
    }
    draggingRectId.value = null;
};
</script>

<style scoped>

/* Thêm style cho overlay loading schema */
.schema-loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.2em;
    color: #333;
    z-index: 10; /* Đảm bảo nó nổi lên trên */
}

.loading-indicator,
.error-message {
    padding: 2rem;
    text-align: center;
    font-style: italic;
    color: #666;
}

.error-message {
    color: red;
    font-weight: bold;
}

/* CSS không đổi */
.drawing-app {
    display: flex;
    gap: 2rem;
    font-family: sans-serif;
}

.palette {
    border: 1px solid #ccc;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    background-color: #f8f8f8;
    height: fit-content;
}

.palette h3 {
    margin: 0 0 0.5rem 0;
    font-size: 0.9em;
    color: #555;
}

.source-rect {
    width: 50px;
    height: 50px;
    border: 1px solid #eee;
    cursor: grab;
    transition: transform 0.2s ease;
}

.source-rect:active {
    cursor: grabbing;
    transform: scale(1.1);
}

.canvas {
    border: 2px dashed #007bff;
    width: 100%;
    height: 500px;
    position: relative;
    background-color: #e9ecef;
    overflow: hidden;
}

.canvas h3 {
    position: absolute;
    top: 5px;
    left: 10px;
    margin: 0;
    font-size: 0.9em;
    color: #6c757d;
    pointer-events: none;
}

.connection-lines {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
}
</style>
Các thay đổi chính:

Import paletteItems: Dòng import { paletteItems, ... } from '../../data/drawingSchemas.js'; đã được thêm vào.
Sử dụng paletteItems trong v-for: Dòng <div v-for="item in sourceData" ...> đã được sửa thành <div v-for="item in paletteItems" ...>.
Với những thay đổi này, component sẽ hoạt động như mong đợi: tải danh sách các mục palette từ manifest.json khi mount, hiển thị chúng, và sau đó tải cấu hình XML chi tiết chỉ khi một mục được thả vào canvas.

Rate this answer: 

Tùng Giang Lâm
hãy bắt đầu hiệu chỉnh cấu trúc các file cấu hình hộp thoại. Hiện tại chỉ có nhãn và giá trị, tôi muốn thay đổi cấu trúc, xác định loại dữ liệu cập nhật (chữ, số, ngày tháng,...) như vậy cần phải sửa các file XML và các file code như thế nào


Gemini
Ok, việc thêm loại dữ liệu cho các trường nhập liệu trong hộp thoại là một cải tiến rất hữu ích. Chúng ta sẽ cần sửa đổi ở 3 nơi chính:

Cấu trúc file XML: Thêm một thuộc tính (ví dụ: type) vào thẻ <field> để chỉ định loại dữ liệu.
Logic Parse XML (drawingSchemas.js): Cập nhật hàm parseSingleTemplateXML để đọc thuộc tính type mới này và lưu trữ nó cùng với giá trị. Cấu trúc dữ liệu của formSchema sẽ thay đổi.
Component EditFormModal.vue: Cập nhật component này để đọc thông tin type và hiển thị đúng loại thẻ input HTML (<input type="text">, <input type="number">, <input type="date">, <textarea>, etc.).
Bước 1: Cập nhật cấu trúc các file XML mẫu

Chúng ta sẽ thêm thuộc tính type vào mỗi thẻ <field>. Các giá trị type phổ biến có thể là: text, number, date, textarea, boolean (cho checkbox), email, url, etc.

Ví dụ cập nhật các file XML:

e:\Vue25\vue3-dnd-project\public\templates\red_shape.xml

xml
<?xml version="1.0" encoding="UTF-8"?>
<sourceItem>
  <item schemaId="schema_red" color="#ff6b6b">
    <formSchema>
      <field key="Tên" type="text">Hình đỏ</field>
      <field key="Mô tả" type="textarea">Một hình chữ nhật màu đỏ</field>
      <field key="Giá trị" type="number">10</field>
      <field key="Trạng thái" type="text">Hoạt động</field> <!-- Giữ là text hoặc có thể là select/boolean sau này -->
      <field key="Ghi chú" type="textarea">Không có</field>
      <field key="Ưu tiên" type="text">Thấp</field> <!-- Giữ là text hoặc có thể là select sau này -->
      <field key="Ngày tạo" type="date"></field> <!-- Thêm ví dụ date -->
      <field key="Đã duyệt" type="boolean">false</field> <!-- Thêm ví dụ boolean -->
    </formSchema>
  </item>
</sourceItem>
e:\Vue25\vue3-dnd-project\public\templates\teal_shape.xml

xml
<?xml version="1.0" encoding="UTF-8"?>
<sourceItem>
  <item schemaId="schema_teal" color="#4ecdc4">
    <formSchema>
      <field key="Đối tượng" type="text">Khối Teal</field>
      <field key="Trạng thái" type="text">Hoạt động</field>
      <field key="Số lượng" type="number">5</field> <!-- Thêm ví dụ number -->
    </formSchema>
  </item>
</sourceItem>
e:\Vue25\vue3-dnd-project\public\templates\blue_shape.xml

xml
<?xml version="1.0" encoding="UTF-8"?>
<sourceItem>
  <item schemaId="schema_blue" color="#45b7d1">
    <formSchema>
      <field key="ID Người dùng" type="text"></field>
      <field key="Ghi chú" type="textarea">Không có</field>
      <field key="Ưu tiên" type="text">Trung bình</field>
      <field key="Trạng thái" type="text">Hoạt động</field>
      <field key="Email liên hệ" type="email"></field> <!-- Thêm ví dụ email -->
    </formSchema>
  </item>
</sourceItem>
(Lưu ý: Bạn cần cập nhật tất cả các file XML mẫu của mình theo cấu trúc này).

Bước 2: Cập nhật Logic Parse XML (drawingSchemas.js)

Sửa đổi hàm parseSingleTemplateXML để đọc thuộc tính type và thay đổi cấu trúc của formSchema trả về. Thay vì key: value, chúng ta sẽ dùng key: { value: ..., type: ... }.

javascript
// src/data/drawingSchemas.js
import { ref, reactive } from 'vue';

export const paletteItems = ref([]);
const loadedSchemasCache = reactive({});

/**
 * Helper function để parse nội dung XML của một file template duy nhất.
 * @param {string} xmlText Nội dung XML của file.
 * @param {string} filename Tên file (để log lỗi).
 * @returns {object | null} Đối tượng template đã parse hoặc null nếu lỗi.
 */
const parseSingleTemplateXML = (xmlText, filename) => {
    try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "application/xml");

        const parserErrors = xmlDoc.getElementsByTagName("parsererror");
        if (parserErrors.length > 0) {
            console.error(`XML Parsing Error in ${filename}:`, parserErrors[0].textContent);
            return null;
        }
        const itemNode = xmlDoc.querySelector("sourceItem > item");
         if (!itemNode) {
             console.warn(`Could not find <item> node within <sourceItem> in ${filename}`);
             return null;
        }

        const schemaId = itemNode.getAttribute('schemaId');
        const color = itemNode.getAttribute('color');
        const formSchemaNode = itemNode.querySelector("formSchema");
        // Thay đổi cấu trúc formSchema: { key: { value: ..., type: ... } }
        const formSchema = {};

        if (formSchemaNode) {
            const fieldNodes = formSchemaNode.querySelectorAll("field");
            fieldNodes.forEach(fieldNode => {
                const key = fieldNode.getAttribute('key');
                // Lấy type, mặc định là 'text' nếu không có
                const type = fieldNode.getAttribute('type') || 'text';
                // Lấy giá trị gốc từ XML (thường là string)
                let value = fieldNode.textContent || "";

                // Xử lý giá trị ban đầu cho một số type đặc biệt nếu cần
                if (type === 'boolean') {
                    // Chuyển đổi 'true'/'false' string thành boolean thực sự
                    value = value.toLowerCase() === 'true';
                }
                // Có thể thêm xử lý cho number nếu muốn giá trị ban đầu là number thay vì string
                // else if (type === 'number') {
                //     const numVal = parseFloat(value);
                //     value = isNaN(numVal) ? 0 : numVal; // Hoặc null, hoặc giữ string tùy logic v-model
                // }

                if (key) {
                    // Lưu cả giá trị và type
                    formSchema[key] = { value: value, type: type };
                }
            });
        }

        if (schemaId && color) {
            // Trả về đối tượng đầy đủ bao gồm cả formSchema với cấu trúc mới
            return { schemaId, color, formSchema };
        } else {
            console.warn(`Skipping item from ${filename} due to missing schemaId or color.`);
            return null;
        }

    } catch (error) {
        console.error(`Error parsing XML from ${filename}:`, error);
        return null;
    }
};


/**
 * Hàm bất đồng bộ để tải thông tin cơ bản cho palette từ manifest.
 * (Hàm này không thay đổi)
 */
export const loadPaletteData = async (manifestPath) => {
    // ... (logic cũ không đổi) ...
     console.log(`Attempting to load palette data from manifest: ${manifestPath}`);
    try {
        const response = await fetch(manifestPath);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status} while fetching ${manifestPath}`);
        }
        const manifestData = await response.json();

        if (!Array.isArray(manifestData)) {
            throw new Error(`Manifest file ${manifestPath} did not contain a valid JSON array.`);
        }
        paletteItems.value = manifestData.map(item => ({
            schemaId: item.schemaId,
            color: item.color,
            filename: item.filename
        }));
        console.log('Successfully loaded palette data:', paletteItems.value);
    } catch (error) {
        console.error("Error loading or parsing manifest file:", error);
        paletteItems.value = [];
        throw error;
    }
};

/**
 * Hàm bất đồng bộ để lấy hoặc tải cấu hình đầy đủ (bao gồm formSchema) của một schemaId.
 * (Hàm này không thay đổi, vì nó sử dụng parseSingleTemplateXML đã được cập nhật)
 */
export const getOrLoadFormSchema = async (schemaId) => {
    // ... (logic cũ không đổi, sẽ trả về formSchema với cấu trúc mới) ...
     if (loadedSchemasCache[schemaId]) {
        console.log(`Schema ${schemaId} found in cache.`);
        return loadedSchemasCache[schemaId].formSchema;
    }
    const itemInfo = paletteItems.value.find(p => p.schemaId === schemaId);
    if (!itemInfo || !itemInfo.filename) {
        console.error(`Schema info or filename not found for schemaId: ${schemaId} in paletteItems.`);
        return null;
    }
    const xmlFilePath = `/templates/${itemInfo.filename}`;
    console.log(`Schema ${schemaId} not in cache. Loading from ${xmlFilePath}...`);
    try {
        const response = await fetch(xmlFilePath);
        if (!response.ok) {
            console.error(`HTTP error! status: ${response.status} while fetching ${xmlFilePath}`);
            return null;
        }
        const xmlText = await response.text();
        const fullSchemaData = parseSingleTemplateXML(xmlText, itemInfo.filename);

        if (fullSchemaData && fullSchemaData.formSchema) {
            loadedSchemasCache[schemaId] = fullSchemaData;
            console.log(`Schema ${schemaId} loaded and cached.`);
            return fullSchemaData.formSchema;
        } else {
            console.error(`Failed to parse valid schema data from ${xmlFilePath}`);
            return null;
        }
    } catch (error) {
        console.error(`Error fetching or processing ${xmlFilePath}:`, error);
        return null;
    }
};

/**
 * Helper để lấy formSchema đã được load (chỉ từ cache).
 * (Hàm này không thay đổi, sẽ trả về formSchema với cấu trúc mới)
 */
export const getCachedSchemaById = (schemaId) => {
    const cachedData = loadedSchemasCache[schemaId];
    // Trả về một bản sao sâu của formSchema để tránh sửa đổi cache
     try {
        return cachedData ? structuredClone(cachedData.formSchema) : {};
    } catch (e) {
        console.warn("structuredClone failed in getCachedSchemaById, using JSON fallback.");
        return cachedData ? JSON.parse(JSON.stringify(cachedData.formSchema)) : {};
    }
};
Bước 3: Cập nhật Component EditFormModal.vue

Đây là nơi thay đổi nhiều nhất. Chúng ta cần render đúng input dựa trên fieldData.type.

vue
// src/components/drawing/EditFormModal.vue
<template>
    <div v-if="visible" class="modal-overlay" @click.self="handleCancel">
        <div class="modal-content">
            <h2>Chỉnh sửa thông tin</h2>
            <form @submit.prevent="handleSave">
                <!-- Lặp qua schema để tạo form fields -->
                <div v-for="(fieldData, key) in schema" :key="key" class="form-group">
                    <label :for="'field-' + key">{{ key }}:</label>

                    <!-- Input Text -->
                    <input
                        v-if="fieldData.type === 'text'"
                        type="text"
                        :id="'field-' + key"
                        v-model="formData[key]"
                    />

                    <!-- Input Number -->
                    <input
                        v-else-if="fieldData.type === 'number'"
                        type="number"
                        :id="'field-' + key"
                        v-model.number="formData[key]" <!-- Sử dụng .number modifier -->
                    />

                    <!-- Input Date -->
                    <input
                        v-else-if="fieldData.type === 'date'"
                        type="date"
                        :id="'field-' + key"
                        v-model="formData[key]"
                    />

                    <!-- Textarea -->
                    <textarea
                        v-else-if="fieldData.type === 'textarea'"
                        :id="'field-' + key"
                        v-model="formData[key]"
                        rows="3"
                    ></textarea>

                    <!-- Checkbox (Boolean) -->
                    <input
                        v-else-if="fieldData.type === 'boolean'"
                        type="checkbox"
                        :id="'field-' + key"
                        v-model="formData[key]"
                        class="form-checkbox"
                    />

                    <!-- Input Email -->
                     <input
                        v-else-if="fieldData.type === 'email'"
                        type="email"
                        :id="'field-' + key"
                        v-model="formData[key]"
                    />

                     <!-- Input URL -->
                     <input
                        v-else-if="fieldData.type === 'url'"
                        type="url"
                        :id="'field-' + key"
                        v-model="formData[key]"
                    />

                    <!-- Fallback cho các type không xác định -->
                    <input
                        v-else
                        type="text"
                        :id="'field-' + key"
                        v-model="formData[key]"
                        :placeholder="`Unknown type: ${fieldData.type}`"
                    />
                </div>

                <div class="modal-actions">
                    <button type="submit" class="btn btn-save">Lưu</button>
                    <button type="button" @click="handleCancel" class="btn btn-cancel">Hủy</button>
                </div>
            </form>
        </div>
    </div>
</template>

<script setup>
import { ref, watch } from 'vue';

const props = defineProps({
    visible: Boolean,
    // rectData chứa dữ liệu hiện tại của hình chữ nhật, bao gồm cả formData gốc
    rectData: Object,
    // schema giờ có cấu trúc: { key: { value: ..., type: ... } }
    schema: Object
});

const emit = defineEmits(['save', 'cancel']);

// formData sẽ chỉ lưu trữ các giá trị để binding với v-model
const formData = ref({});

// Watch sự thay đổi của rectData (khi modal mở với rect khác) hoặc schema
watch(() => [props.rectData, props.schema], ([newRectData, newSchema]) => {
    // console.log("Modal Watch Triggered. RectData:", newRectData, "Schema:", newSchema);
    if (newRectData && newSchema && Object.keys(newSchema).length > 0) {
        const initialData = {};
        // Duyệt qua schema để lấy giá trị ban đầu
        for (const key in newSchema) {
            // Ưu tiên lấy giá trị hiện tại từ rectData.formData nếu có
            // Nếu không, lấy giá trị mặc định từ schema[key].value
            initialData[key] = newRectData.formData?.[key] !== undefined
                               ? newRectData.formData[key]
                               : newSchema[key]?.value ?? ''; // Dùng ?? để xử lý null/undefined
             // console.log(`Initializing formData[${key}] =`, initialData[key]);
        }
        formData.value = initialData;
    } else {
        // console.log("Resetting formData");
        formData.value = {}; // Reset nếu không có dữ liệu hoặc schema
    }
}, { immediate: true, deep: true }); // immediate: chạy ngay khi component mount, deep: theo dõi sâu

const handleSave = () => {
    // console.log("Saving formData:", { ...formData.value });
    // Emit chỉ các giá trị đã được cập nhật trong form
    emit('save', { ...formData.value });
};

const handleCancel = () => {
    emit('cancel');
};
</script>

<style scoped>
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.modal-content {
    background-color: #fff;
    padding: 25px;
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    min-width: 350px;
    max-width: 500px;
}

h2 {
    margin-top: 0;
    margin-bottom: 20px;
    color: #333;
    text-align: center;
}

.form-group {
    margin-bottom: 15px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
    color: #555;
}

.form-group input[type="text"],
.form-group input[type="number"],
.form-group input[type="date"],
.form-group input[type="email"],
.form-group input[type="url"],
.form-group textarea {
    width: 100%;
    padding: 8px 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-sizing: border-box; /* Important */
    font-size: 1rem;
}
.form-group textarea {
    resize: vertical; /* Allow vertical resize */
}

.form-group input[type="checkbox"].form-checkbox {
     width: auto; /* Checkbox không cần full width */
     margin-right: 5px;
     vertical-align: middle;
}
/* Căn chỉnh label cho checkbox */
.form-group input[type="checkbox"].form-checkbox + label,
.form-group label[for*='field-'][type="boolean"] /* Heuristic for boolean label */
{
    display: inline-block;
    margin-bottom: 0;
    vertical-align: middle;
}


.modal-actions {
    margin-top: 25px;
    text-align: right;
}

.btn {
    padding: 10px 18px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    margin-left: 10px;
    transition: background-color 0.2s ease;
}

.btn-save {
    background-color: #28a745;
    color: white;
}
.btn-save:hover {
    background-color: #218838;
}

.btn-cancel {
    background-color: #6c757d;
    color: white;
}
.btn-cancel:hover {
    background-color: #5a6268;
}
</style>
Giải thích thay đổi trong EditFormModal.vue:

Template:
Sử dụng v-for="(fieldData, key) in schema" để lặp qua cấu trúc schema mới.
Sử dụng v-if/v-else-if để kiểm tra fieldData.type và render đúng loại input:
text, number, date, email, url sử dụng <input> với type tương ứng.
textarea sử dụng thẻ <textarea>.
boolean sử dụng <input type="checkbox">.
v-model giờ đây binding với formData[key]. Lưu ý v-model.number được dùng cho type="number" để tự động chuyển đổi giá trị.
Thêm fallback cho các type không xác định (render như text).
Script:
props.schema giờ nhận cấu trúc { key: { value: ..., type: ... } }.
formData (ref) được dùng để lưu trữ chỉ các giá trị của form, giúp v-model hoạt động đơn giản.
watch được cập nhật để khởi tạo formData từ props.rectData.formData (nếu có) hoặc từ giá trị mặc định trong props.schema[key].value. Điều này đảm bảo khi mở lại modal, giá trị đã lưu sẽ được hiển thị.
handleSave emit ra đối tượng formData.value (chứa các giá trị đã cập nhật).
Bước 4: Đảm bảo DrawingCanvas.vue xử lý đúng

handleDrop (CREATE NEW): Logic tạo initialFormData cần được cập nhật để trích xuất đúng giá trị mặc định từ cấu trúc schema mới.
saveForm: Logic này trong DrawingCanvas.vue nhận dữ liệu từ modal (chỉ là các giá trị) và cập nhật drawnRectangles.value[originalRectIndex].formData. Logic này vẫn đúng vì formData trên drawnRectangle được mong đợi là một object chứa các giá trị.
Cập nhật handleDrop trong DrawingCanvas.vue:

javascript
// src/components/drawing/DrawingCanvas.vue

// ... (các phần khác)

const handleDrop = async (event) => { // Chuyển thành async
    event.preventDefault();
    closeContextMenu();
    const canvasRect = canvasRef.value?.getBoundingClientRect();
    if (!canvasRect) { /* ... lỗi ... */ return; }

    const dropX = event.clientX - canvasRect.left;
    const dropY = event.clientY - canvasRect.top;

    const draggedRectIdStr = event.dataTransfer.getData(RECT_ID_DATA_TYPE);

    // --- MOVE --- (Không đổi)
    if (draggedRectIdStr) {
        // ... (logic di chuyển cũ)
    }
    // --- CREATE NEW --- (Cập nhật tạo initialFormData)
    else {
        const sourceItemDataStr = event.dataTransfer.getData(SOURCE_ITEM_DATA_TYPE);
        if (sourceItemDataStr) {
            let sourceItemData;
            try {
                sourceItemData = JSON.parse(sourceItemDataStr);
                console.log('Handling CREATE NEW for:', sourceItemData);

                isSchemaLoading.value = true;
                let formSchema = null; // formSchema giờ có cấu trúc { key: { value: ..., type: ... } }
                try {
                    formSchema = await getOrLoadFormSchema(sourceItemData.schemaId);
                } finally {
                    isSchemaLoading.value = false;
                }

                if (formSchema === null) {
                     console.error(`Failed to load formSchema for ${sourceItemData.schemaId}. Creating rect with empty formData.`);
                     formSchema = {};
                }

                // --- CẬP NHẬT TẠO INITIAL FORM DATA ---
                // Tạo đối tượng chỉ chứa các giá trị ban đầu từ schema đã load
                const initialFormDataValues = {};
                for (const key in formSchema) {
                    // Lấy giá trị mặc định từ schema
                    initialFormDataValues[key] = formSchema[key]?.value ?? ''; // Dùng ?? để xử lý null/undefined
                }
                // --------------------------------------

                // Clone các giá trị ban đầu này cho hình chữ nhật mới
                let clonedInitialValues;
                 try {
                    clonedInitialValues = structuredClone(initialFormDataValues);
                 } catch(e) {
                    console.warn("structuredClone failed for initial form data values, using JSON fallback.");
                    clonedInitialValues = JSON.parse(JSON.stringify(initialFormDataValues));
                 }


                const newRect = {
                    id: Date.now(),
                    color: sourceItemData.color,
                    schemaId: sourceItemData.schemaId,
                    x: dropX - defaultRectWidth / 2,
                    y: dropY - defaultRectHeight / 2,
                    width: defaultRectWidth,
                    height: defaultRectHeight,
                    order: currentOrder.value,
                    // formData trên hình chữ nhật vẫn lưu các giá trị key-value
                    formData: clonedInitialValues
                };
                drawnRectangles.value.push(newRect);
                currentOrder.value++;

            } catch (e) {
                console.error("Drop Error: Failed to process source item or load schema:", e, sourceItemDataStr);
                 isSchemaLoading.value = false;
            }
        } else {
            console.warn('Drop Warning: No valid data found.');
        }
    }
    draggingRectId.value = null;
};

// ... (phần còn lại của script)
Bây giờ, bạn đã có hệ thống cho phép định nghĩa loại input trong file XML và hiển thị đúng trong modal chỉnh sửa.

Rate this answer: 

Tùng Giang Lâm
để lưu lại kết quả hiện tại, tôi muốn xây dựng các file cấu hình mới, thư viện load cấu hình mới, các file vue trong thư mục khác có tính năng tương tự


Gemini
Ok, tôi hiểu. Bạn muốn tạo một cơ chế để lưu trạng thái hiện tại của canvas (các hình chữ nhật đã vẽ, vị trí, thứ tự, dữ liệu form của chúng) vào một file và tải lại trạng thái đó từ file. Đồng thời, bạn muốn cấu trúc code này một cách tách biệt, có thể coi như một "thư viện" hoặc service riêng và có thể sử dụng các component Vue riêng cho chức năng này.

Đây là một cách tiếp cận tốt để tách biệt logic lưu/tải khỏi logic vẽ chính. Chúng ta sẽ thực hiện theo các bước:

Xác định Định dạng File Lưu Trạng Thái: JSON là lựa chọn tự nhiên và đơn giản nhất vì nó ánh xạ trực tiếp tới cấu trúc dữ liệu JavaScript (drawnRectangles).
Tạo "Thư viện" Lưu/Tải (Service): Tạo một file JavaScript mới (ví dụ: src/services/canvasStateService.js) chứa các hàm để:
Chuyển đổi dữ liệu drawnRectangles thành JSON và kích hoạt tải xuống file .json.
Mở hộp thoại chọn file, đọc nội dung file .json đã chọn, parse JSON và trả về dữ liệu.
Tạo Component Giao diện Lưu/Tải (Optional nhưng nên có): Tạo một component Vue mới (ví dụ: src/components/state/SaveLoadControls.vue) chứa các nút "Lưu trạng thái" và "Tải trạng thái". Component này sẽ gọi các hàm từ service.
Tích hợp vào DrawingCanvas.vue:
Import và sử dụng component SaveLoadControls.vue.
Truyền dữ liệu drawnRectangles xuống SaveLoadControls (nếu cần lưu) hoặc nhận dữ liệu đã tải lên từ SaveLoadControls để cập nhật drawnRectangles.
Bước 1: Định dạng File Lưu Trạng Thái (JSON)

File lưu trạng thái (ví dụ: my_drawing.json) sẽ có cấu trúc đơn giản là một mảng các đối tượng, giống hệt như drawnRectangles.value:

json
[
  {
    "id": 1678886400000,
    "color": "#ff6b6b",
    "schemaId": "schema_red",
    "x": 150.5,
    "y": 80.2,
    "width": 50,
    "height": 50,
    "order": 1,
    "formData": {
      "Tên": "Hình Đỏ Đã Sửa",
      "Mô tả": "Nội dung mô tả...",
      "Giá trị": 15,
      "Trạng thái": "Đang chờ",
      "Ghi chú": "...",
      "Ưu tiên": "Cao",
      "Ngày tạo": "2023-10-27",
      "Đã duyệt": true
    }
  },
  {
    "id": 1678886405000,
    "color": "#4ecdc4",
    "schemaId": "schema_teal",
    "x": 300,
    "y": 150,
    "width": 50,
    "height": 50,
    "order": 2,
    "formData": {
      "Đối tượng": "Khối Teal Mới",
      "Trạng thái": "Hoàn thành",
      "Số lượng": 8
    }
  }
  // ... các hình chữ nhật khác
]
Bước 2: Tạo Service Lưu/Tải (src/services/canvasStateService.js)

Tạo thư mục src/services nếu chưa có và tạo file canvasStateService.js:

javascript
// src/services/canvasStateService.js

/**
 * Lưu trạng thái các hình chữ nhật vào file JSON và kích hoạt tải xuống.
 * @param {Array<object>} rectanglesData Mảng dữ liệu drawnRectangles.
 * @param {string} [filename='drawing_state.json'] Tên file để lưu.
 */
export function saveCanvasStateToFile(rectanglesData, filename = 'drawing_state.json') {
    try {
        // 1. Chuyển đổi sang JSON (với định dạng đẹp để dễ đọc)
        const jsonString = JSON.stringify(rectanglesData, null, 2); // null, 2 để thụt lề

        // 2. Tạo Blob (Binary Large Object) từ chuỗi JSON
        const blob = new Blob([jsonString], { type: 'application/json' });

        // 3. Tạo URL tạm thời cho Blob
        const url = URL.createObjectURL(blob);

        // 4. Tạo một thẻ <a> ẩn để kích hoạt tải xuống
        const a = document.createElement('a');
        a.href = url;
        a.download = filename; // Đặt tên file tải xuống
        document.body.appendChild(a); // Cần thêm vào DOM để hoạt động trên Firefox
        a.click(); // Kích hoạt click để tải file

        // 5. Dọn dẹp: Xóa thẻ <a> và thu hồi URL tạm thời
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        console.log(`State saved to ${filename}`);

    } catch (error) {
        console.error("Error saving canvas state:", error);
        alert("Đã xảy ra lỗi khi lưu trạng thái. Vui lòng kiểm tra console.");
    }
}

/**
 * Mở hộp thoại chọn file và đọc trạng thái từ file JSON.
 * @returns {Promise<Array<object> | null>} Promise trả về mảng dữ liệu đã load hoặc null nếu hủy/lỗi.
 */
export function loadCanvasStateFromFile() {
    return new Promise((resolve, reject) => {
        // 1. Tạo một input type="file" ẩn
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json'; // Chỉ chấp nhận file JSON

        // 2. Lắng nghe sự kiện 'change' (khi người dùng chọn file)
        input.onchange = (event) => {
            const file = event.target.files?.[0];
            if (!file) {
                console.log("No file selected or operation cancelled.");
                resolve(null); // Người dùng hủy
                return;
            }

            // 3. Sử dụng FileReader để đọc nội dung file
            const reader = new FileReader();

            reader.onload = (e) => {
                try {
                    const jsonString = e.target?.result;
                    if (typeof jsonString !== 'string') {
                         throw new Error("Failed to read file content as string.");
                    }
                    // 4. Parse JSON
                    const loadedData = JSON.parse(jsonString);

                    // 5. Kiểm tra cơ bản xem có phải là mảng không
                    if (!Array.isArray(loadedData)) {
                        throw new Error("Loaded file does not contain a valid JSON array.");
                    }

                    console.log("State loaded successfully:", loadedData);
                    resolve(loadedData); // Trả về dữ liệu đã load thành công

                } catch (error) {
                    console.error("Error parsing loaded JSON file:", error);
                    alert("Lỗi đọc hoặc phân tích file trạng thái. File có thể không đúng định dạng JSON hoặc bị hỏng.");
                    reject(error); // Báo lỗi
                }
            };

            reader.onerror = (error) => {
                console.error("Error reading file:", error);
                alert("Đã xảy ra lỗi khi đọc file.");
                reject(error); // Báo lỗi
            };

            // Bắt đầu đọc file dưới dạng text
            reader.readAsText(file);
        };

        // 4. Kích hoạt click vào input để mở hộp thoại chọn file
        input.click();
    });
}
Bước 3: Tạo Component SaveLoadControls.vue

Tạo thư mục src/components/state nếu chưa có và tạo file SaveLoadControls.vue:

vue
// src/components/state/SaveLoadControls.vue
<template>
    <div class="save-load-controls">
        <button @click="handleSave" class="btn btn-save-state" :disabled="!canSave">Lưu trạng thái</button>
        <button @click="handleLoad" class="btn btn-load-state">Tải trạng thái</button>
    </div>
</template>

<script setup>
import {  computed } from 'vue';
import { saveCanvasStateToFile, loadCanvasStateFromFile } from '../../services/canvasStateService.js'; // Import service

const props = defineProps({
    // Nhận dữ liệu hiện tại để có thể lưu
    currentRectangles: {
        type: Array,
        required: true
    }
});

const emit = defineEmits(['stateLoaded']); // Emit sự kiện khi load xong

// Chỉ cho phép lưu nếu có ít nhất 1 hình chữ nhật
const canSave = computed(() => props.currentRectangles && props.currentRectangles.length > 0);

const handleSave = () => {
    if (!canSave.value) return;
    // Đặt tên file động nếu muốn, ví dụ: `drawing_${Date.now()}.json`
    saveCanvasStateToFile(props.currentRectangles, 'my_drawing.json');
};

const handleLoad = async () => {
    try {
        const loadedData = await loadCanvasStateFromFile();
        if (loadedData) {
            // Emit dữ liệu đã load lên component cha (DrawingCanvas)
            emit('stateLoaded', loadedData);
        }
        // Nếu loadedData là null (người dùng hủy), không làm gì cả
    } catch (error) {
        // Lỗi đã được xử lý và log trong service, có thể thêm thông báo ở đây nếu muốn
        console.error("Load operation failed in component:", error);
        alert("Tải trạng thái thất bại.");
    }
};
</script>

<style scoped>
.save-load-controls {
    margin-top: 1rem; /* Khoảng cách với các phần tử khác */
    padding: 0.5rem;
    background-color: #f0f0f0;
    border-radius: 4px;
    display: flex;
    gap: 10px; /* Khoảng cách giữa các nút */
    justify-content: center; /* Căn giữa các nút */
}

.btn {
    padding: 8px 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: background-color 0.2s ease, opacity 0.2s ease;
}

.btn-save-state {
    background-color: #007bff;
    color: white;
}
.btn-save-state:hover {
    background-color: #0056b3;
}
.btn-save-state:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
    opacity: 0.7;
}


.btn-load-state {
    background-color: #ffc107;
    color: #333;
}
.btn-load-state:hover {
    background-color: #e0a800;
}
</style>
Bước 4: Tích hợp vào DrawingCanvas.vue

vue
// src/components/drawing/DrawingCanvas.vue
<template>
    <!-- ... (phần loading palette) ... -->

    <div v-else class="drawing-app-container"> <!-- Thêm container bao ngoài -->
        <div class="drawing-app">
            <!-- Palette -->
            <div class="palette">
                <!-- ... (nội dung palette) ... -->
            </div>

            <!-- Canvas -->
            <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
                <!-- ... (nội dung canvas, svg, rectangles) ... -->
            </div>
        </div>

        <!-- Component Save/Load Controls -->
        <SaveLoadControls
            :current-rectangles="drawnRectangles"
            @state-loaded="onStateLoaded"
            class="controls-container"
        />

        <!-- Modal (nằm ngoài .drawing-app để không bị ảnh hưởng bởi flex) -->
        <ContextMenu :visible="contextMenu.visible" :top="contextMenu.top" :left="contextMenu.left" @edit="handleEdit"
            @delete="handleDelete" ref="contextMenuRef" />
        <EditFormModal :visible="isModalVisible" :rect-data="editingRect" :schema="getCachedSchemaForRect(editingRect)"
            @save="saveForm" @cancel="cancelForm" />

    </div> <!-- Đóng drawing-app-container -->
</template>

<script setup>
/* eslint-disable */
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { debounce } from 'lodash-es';
import DrawnRectangle from './DrawnRectangle.vue';
import ContextMenu from './ContextMenu.vue';
import EditFormModal from './EditFormModal.vue';
// Import component mới
import SaveLoadControls from '../state/SaveLoadControls.vue';
// Import các service và data như cũ
import { paletteItems, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawingSchemas.js';
import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';

// ... (các state isLoading, loadError, isSchemaLoading, drawnRectangles, etc. như cũ) ...
const isLoading = ref(true);
const loadError = ref(false);
const isSchemaLoading = ref(false);
const drawnRectangles = ref([]);
const canvasRef = ref(null);
const defaultRectWidth = 50;
const defaultRectHeight = 50;
const draggingRectId = ref(null);
const currentOrder = ref(1);
const contextMenuRef = ref(null);
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null });
const isModalVisible = ref(false);
const editingRect = ref(null);


// --- Computed --- (như cũ)
const sortedRectangles = computed(() => { /* ... */ });

// --- Helpers --- (như cũ)
const getCachedSchemaForRect = (rect) => { /* ... */ };
const calculateElbowPoints = (rectA, rectB) => { /* ... */ };

// --- Event Handlers --- (như cũ)
const handleWindowChange = debounce(() => { /* ... */ }, 150);

// --- Lifecycle Hooks --- (như cũ)
onMounted(async () => { /* ... */ });
onUnmounted(() => { /* ... */ });

// --- Event Handlers ---

// Hàm xử lý khi nhận dữ liệu trạng thái đã load từ component con
const onStateLoaded = (loadedRectangles) => {
    console.log("Received loaded state:", loadedRectangles);
    // 1. Thay thế hoàn toàn dữ liệu hiện tại
    drawnRectangles.value = loadedRectangles;

    // 2. Tính toán lại currentOrder
    if (loadedRectangles.length > 0) {
        // Tìm order lớn nhất và cộng 1
        currentOrder.value = Math.max(...loadedRectangles.map(r => r.order)) + 1;
    } else {
        currentOrder.value = 1; // Reset về 1 nếu không có hình nào
    }
    console.log("Canvas state restored. New currentOrder:", currentOrder.value);

    // 3. (Tùy chọn) Pre-load các schema cần thiết vào cache
    // Duyệt qua các schemaId trong loadedRectangles và gọi getOrLoadFormSchema
    // để đảm bảo chúng có trong cache trước khi người dùng mở modal chỉnh sửa.
    // Điều này có thể cải thiện trải nghiệm người dùng sau khi load.
    const uniqueSchemaIds = [...new Set(loadedRectangles.map(r => r.schemaId))];
    console.log("Pre-loading schemas for IDs:", uniqueSchemaIds);
    uniqueSchemaIds.forEach(id => {
        getOrLoadFormSchema(id).catch(err => {
            console.error(`Failed to pre-load schema ${id} after state load:`, err);
        });
    });
};


// ... (Các handlers khác: handleClickOutside, showContextMenu, ..., handleDrop như cũ) ...
const handleClickOutside = (event) => { /* ... */ };
const showContextMenu = (event, rect) => { /* ... */ };
const closeContextMenu = () => { /* ... */ };
const handleEdit = () => { /* ... */ };
const handleDelete = () => { /* ... */ };
const openEditModal = (rect) => { /* ... */ };
const saveForm = (updatedFormData) => { /* ... */ };
const cancelForm = () => { /* ... */ };
const handleSourceDragStart = (event, item) => { /* ... */ };
const handleRectDragStart = (event, rect) => { /* ... */ };
const handleRectDragEnd = (event) => { /* ... */ };
const handleDragOver = (event) => { /* ... */ };
const handleDrop = async (event) => { /* ... */ };

</script>

<style scoped>
/* Thêm style cho container bao ngoài nếu cần */
.drawing-app-container {
    display: flex;
    flex-direction: column; /* Sắp xếp drawing-app và controls theo chiều dọc */
    /* Hoặc bạn có thể đặt controls ở vị trí khác */
}

.drawing-app {
    display: flex;
    gap: 2rem;
    font-family: sans-serif;
    /* Có thể cần điều chỉnh width/height nếu container cha thay đổi */
}

.controls-container {
     margin: 1rem auto; /* Căn giữa và tạo khoảng cách */
     width: fit-content; /* Chỉ rộng bằng nội dung */
}

/* ... (Các style cũ: .palette, .canvas, .connection-lines, etc.) ... */
.schema-loading-overlay { /* ... */ }
.loading-indicator, .error-message { /* ... */ }
.palette { /* ... */ }
.source-rect { /* ... */ }
.canvas { /* ... */ }
.connection-lines { /* ... */ }

</style>
Giải thích thay đổi trong DrawingCanvas.vue:

Import SaveLoadControls: Component mới được import.
Sử dụng SaveLoadControls: Component được đặt trong template, bên dưới khu vực canvas chính.
:current-rectangles="drawnRectangles": Truyền dữ liệu hiện tại xuống để component con có thể lưu.
@state-loaded="onStateLoaded": Lắng nghe sự kiện stateLoaded được emit từ component con khi tải file thành công.
Hàm onStateLoaded:
Nhận loadedRectangles từ sự kiện.
Gán trực tiếp loadedRectangles cho drawnRectangles.value để cập nhật trạng thái canvas.
Tính toán lại currentOrder dựa trên order lớn nhất trong dữ liệu đã load.
(Tùy chọn) Gọi getOrLoadFormSchema cho các schemaId duy nhất trong dữ liệu đã load để đưa chúng vào cache, giúp việc mở modal chỉnh sửa sau này nhanh hơn.
Cấu trúc Template: Thêm một div.drawing-app-container bao ngoài để dễ dàng sắp xếp div.drawing-app và SaveLoadControls.
Bây giờ bạn đã có chức năng lưu và tải trạng thái canvas vào/từ file JSON, được cấu trúc thành service và component riêng biệt.

Rate this answer: 

Tùng Giang Lâm
Không phải, tôi muốn tạo thêm một giao diện giống DrawingCanvas đã xây dựng, nhưng thành một giao diện khác để tiếp tục cải tiến chức năng, nhưng vẫn giữ DrawingCanvas


Gemini
Ah, tôi hiểu rồi! Cảm ơn bạn đã làm rõ. Bạn muốn tạo một bản sao của giao diện DrawingCanvas hiện tại, đặt nó vào một route (đường dẫn) khác, để bạn có thể thử nghiệm và phát triển các tính năng mới trên bản sao đó mà không ảnh hưởng đến bản gốc đang hoạt động.

Đây là một cách làm rất hợp lý để quản lý quá trình phát triển. Dưới đây là các bước chi tiết để thực hiện điều đó:

Bước 1: Nhân bản Component DrawingCanvas.vue

Sao chép file: Trong thư mục src/components/drawing/, tạo một bản sao của file DrawingCanvas.vue.
Đổi tên file mới: Đặt tên cho file mới một cách rõ ràng, ví dụ: ExperimentalCanvas.vue hoặc DrawingCanvasV2.vue. (Tôi sẽ dùng ExperimentalCanvas.vue làm ví dụ).
(Quan trọng nếu dùng Options API): Mở file ExperimentalCanvas.vue và đổi tên component trong phần export default { name: '...' } (nếu bạn đang dùng Options API). Với <script setup>, việc này ít quan trọng hơn, nhưng tên file rõ ràng là tốt.
Bước 2: Xem xét các Component Con

DrawingCanvas sử dụng các component con như DrawnRectangle.vue, ContextMenu.vue, EditFormModal.vue, và SaveLoadControls.vue.

Câu hỏi: Bạn có cần các phiên bản riêng biệt của những component con này cho ExperimentalCanvas không?

Nếu KHÔNG: ExperimentalCanvas.vue có thể tiếp tục import và sử dụng các component con hiện có. Đây là cách đơn giản nhất nếu bạn chưa có kế hoạch thay đổi lớn trong các component con đó.
Nếu CÓ: (Ví dụ: bạn muốn EditFormModal hoạt động khác đi trong bản thử nghiệm), bạn cũng cần nhân bản, đổi tên (ví dụ: EditFormModalV2.vue), và cập nhật import trong ExperimentalCanvas.vue để sử dụng phiên bản mới.
Khuyến nghị ban đầu: Giữ nguyên việc sử dụng các component con hiện có, trừ khi bạn biết chắc chắn cần thay đổi chúng cho phiên bản thử nghiệm.

Bước 3: Xem xét Services và Dữ liệu (drawingSchemas.js, canvasStateService.js)

Các hàm trong drawingSchemas.js (như loadPaletteData, getOrLoadFormSchema, getCachedSchemaById) và canvasStateService.js (như saveCanvasStateToFile, loadCanvasStateFromFile) có vẻ khá chung chung.
Rất có thể bạn có thể tái sử dụng các service này cho cả DrawingCanvas.vue và ExperimentalCanvas.vue mà không cần thay đổi. Trạng thái chính (drawnRectangles, paletteItems, loadedSchemasCache) được quản lý riêng biệt trong mỗi instance của component hoặc trong các ref/reactive được export, nên chúng không nên xung đột trực tiếp.
Lưu ý về Cache: loadedSchemasCache trong drawingSchemas.js sẽ được chia sẻ giữa cả hai canvas. Điều này thường là tốt (load một lần, dùng nhiều nơi), nhưng hãy lưu ý nếu bạn có ý định thay đổi cấu trúc schema một cách drastis trong bản thử nghiệm.
Bước 4: Thêm Route Mới trong Router

Mở file src/router/index.js và thêm một định nghĩa route mới cho component ExperimentalCanvas.vue.

javascript
// src/router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import HelloWorld from '../components/HelloWorld.vue'
import DrawingCanvas from '../components/drawing/DrawingCanvas.vue'
// 1. Import component mới
import ExperimentalCanvas from '../components/drawing/ExperimentalCanvas.vue' // Đường dẫn có thể khác nếu bạn đặt file ở chỗ khác

const routes = [
  {
    path: '/',
    name: 'HelloWorld',
    component: HelloWorld
  },
  {
    path: '/drawing', // Route cho bản gốc
    name: 'DrawingCanvas',
    component: DrawingCanvas
  },
  // 2. Thêm route mới
  {
    path: '/drawing-exp', // Chọn một đường dẫn khác (ví dụ: /drawing-experimental)
    name: 'ExperimentalCanvas', // Đặt tên route khác
    component: ExperimentalCanvas // Trỏ đến component mới
  },
  // ... các routes khác nếu có
]

const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes
})

export default router
Bước 5: Thêm Liên kết Điều hướng (Navigation)

Để người dùng có thể truy cập giao diện mới, bạn cần thêm một liên kết vào đâu đó trong ứng dụng, ví dụ trong App.vue hoặc một thanh điều hướng riêng.

vue
// src/App.vue (Ví dụ)
<template>
  <nav>
    <router-link to="/">Home</router-link> |
    <router-link to="/drawing">Bản vẽ gốc</router-link> |
    <router-link to="/drawing-exp">Bản vẽ thử nghiệm</router-link> <!-- Thêm liên kết mới -->
  </nav>
  <router-view/>
</template>

<style>
/* ... CSS của bạn ... */
nav {
  padding: 30px;
}

nav a {
  font-weight: bold;
  color: #2c3e50;
}

nav a.router-link-exact-active {
  color: #42b983;
}
</style>
Kết quả:

Sau khi thực hiện các bước trên:

Bạn sẽ có một component ExperimentalCanvas.vue là bản sao của DrawingCanvas.vue.
Bạn có thể truy cập giao diện gốc tại địa chỉ /drawing.
Bạn có thể truy cập giao diện thử nghiệm mới tại địa chỉ /drawing-exp.
Bạn có thể bắt đầu chỉnh sửa ExperimentalCanvas.vue (và các component con/service nếu cần) để thêm/thay đổi chức năng mà không làm ảnh hưởng đến /drawing.
Bây giờ bạn đã sẵn sàng để cải tiến chức năng trên giao diện mới!

Rate this answer: 

Tùng Giang Lâm
hãy duplicate lại các file đang dùng để tôi sử dụng trong thư mục khác tên DrawProcess, với các file vue, xml , json, js để có trang chức năng tương tự DrawingCanvas


Gemini
Ok, đã hiểu. Chúng ta sẽ tạo một bản sao hoàn chỉnh của chức năng vẽ hiện tại, bao gồm các component Vue, file cấu hình XML/JSON, và logic JavaScript, đặt chúng vào một cấu trúc thư mục mới dưới tên DrawProcess.

Các bước thực hiện:

Tạo cấu trúc thư mục mới.
Sao chép và đổi tên các component Vue.
Sao chép và đổi tên các file cấu hình (XML, JSON).
Sao chép và đổi tên các file logic JavaScript (schemas, types).
Giữ lại các service dùng chung (state saving).
Cập nhật đường dẫn import và các đường dẫn file trong code.
Thêm route mới cho chức năng DrawProcess.
Thêm liên kết điều hướng.
Bước 1: Tạo Cấu trúc Thư mục Mới

Tạo các thư mục sau trong dự án của bạn:

src/components/DrawProcess/
public/process_templates/
src/data/ (Nếu chưa có)
Bước 2: Sao chép và Đổi tên Component Vue

Sao chép các file sau và đổi tên chúng:

src/components/drawing/DrawingCanvas.vue -> src/components/DrawProcess/DrawProcessCanvas.vue
src/components/drawing/DrawnRectangle.vue -> src/components/DrawProcess/DrawProcessRectangle.vue
src/components/drawing/ContextMenu.vue -> src/components/DrawProcess/DrawProcessContextMenu.vue
src/components/drawing/EditFormModal.vue -> src/components/DrawProcess/DrawProcessEditFormModal.vue
src/components/state/SaveLoadControls.vue -> src/components/DrawProcess/DrawProcessSaveLoadControls.vue (Quyết định sao chép để tách biệt hoàn toàn)
Bước 3: Sao chép File Cấu hình

Sao chép các file sau:

public/templates/manifest.json -> public/process_templates/manifest.json
Sao chép tất cả các file *.xml từ public/templates/ vào public/process_templates/.
Bước 4: Sao chép và Đổi tên File Logic JavaScript

Sao chép và đổi tên file sau:

src/data/drawingSchemas.js -> src/data/drawProcessSchemas.js
Bước 5: Giữ lại các Service/Types Dùng Chung

Các file này có thể được sử dụng lại vì logic của chúng khá chung chung:

src/services/canvasStateService.js (Logic lưu/tải file JSON)
src/types/drawingTypes.js (Các hằng số kiểu dữ liệu)
Bước 6: Cập nhật Nội dung các File Đã Sao chép

Đây là bước quan trọng nhất để đảm bảo sự tách biệt.

src/data/drawProcessSchemas.js:

Mở file này.
Tìm và thay thế tất cả các chuỗi đường dẫn /templates/ thành /process_templates/. Điều này đặc biệt quan trọng trong các hàm loadPaletteData (khi fetch manifest) và getOrLoadFormSchema (khi fetch file XML).
(Tùy chọn) Bạn có thể đổi tên các biến export như paletteItems thành processPaletteItems, loadedSchemasCache thành processSchemasCache nếu muốn rõ ràng hơn, nhưng không bắt buộc nếu chúng chỉ được import vào DrawProcessCanvas. Để đơn giản, chúng ta giữ nguyên tên nhưng đảm bảo đường dẫn đã đúng.
javascript
// src/data/drawProcessSchemas.js (Ví dụ các chỗ cần sửa)
// ... imports ...

export const paletteItems = ref([]); // Giữ tên hoặc đổi thành processPaletteItems
const loadedSchemasCache = reactive({}); // Giữ tên hoặc đổi thành processSchemasCache

// ... parseSingleTemplateXML ...

export const loadPaletteData = async (manifestPath = '/process_templates/manifest.json') => { // SỬA ĐƯỜNG DẪN MẶC ĐỊNH
    console.log(`Attempting to load palette data from manifest: ${manifestPath}`);
    try {
        const response = await fetch(manifestPath); // Fetch từ đường dẫn được truyền vào
        // ... (phần còn lại của hàm)
    } catch (error) { // ... }
};

export const getOrLoadFormSchema = async (schemaId) => {
    if (loadedSchemasCache[schemaId]) { /* ... cache ... */ }

    const itemInfo = paletteItems.value.find(p => p.schemaId === schemaId);
    if (!itemInfo || !itemInfo.filename) { /* ... lỗi ... */ }

    // SỬA ĐƯỜNG DẪN KHI FETCH XML
    const xmlFilePath = `/process_templates/${itemInfo.filename}`;
    console.log(`Schema ${schemaId} not in cache. Loading from ${xmlFilePath}...`);
    try {
        const response = await fetch(xmlFilePath);
        // ... (phần còn lại của hàm)
    } catch (error) { // ... }
};

export const getCachedSchemaById = (schemaId) => {
    // ... (logic cũ không đổi)
};
src/components/DrawProcess/DrawProcessCanvas.vue:

Mở file này.
Cập nhật tất cả các dòng import để trỏ đến các component con mới trong cùng thư mục (./DrawProcessRectangle.vue, ./DrawProcessContextMenu.vue, etc.) và component DrawProcessSaveLoadControls.vue.
Cập nhật dòng import logic schema để trỏ đến src/data/drawProcessSchemas.js.
Đảm bảo dòng import types trỏ đến src/types/drawingTypes.js (dùng chung).
Đảm bảo bạn đang import và sử dụng đúng các biến/hàm từ drawProcessSchemas.js (ví dụ: paletteItems, getOrLoadFormSchema, getCachedSchemaById).
Quan trọng: Sửa đổi lệnh gọi loadPaletteData trong onMounted để sử dụng đường dẫn manifest mới: await loadPaletteData('/process_templates/manifest.json');
vue
// src/components/DrawProcess/DrawProcessCanvas.vue
<script setup>
// ... imports (ref, computed, etc.) ...
import DrawProcessRectangle from './DrawProcessRectangle.vue'; // Sửa import
import DrawProcessContextMenu from './DrawProcessContextMenu.vue'; // Sửa import
import DrawProcessEditFormModal from './DrawProcessEditFormModal.vue'; // Sửa import
import DrawProcessSaveLoadControls from './DrawProcessSaveLoadControls.vue'; // Sửa import

// Sửa import schema logic
import { paletteItems, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawProcessSchemas.js';
// Import types (dùng chung)
import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';

// ... (phần còn lại của script setup) ...

onMounted(async () => {
    try {
        // SỬA ĐƯỜNG DẪN MANIFEST
        await loadPaletteData('/process_templates/manifest.json');
        loadError.value = false;
    } catch (error) {
        // ... xử lý lỗi ...
    } finally {
        isLoading.value = false;
    }
    // ... add event listeners ...
});

// ... (các hàm khác) ...
</script>
src/components/DrawProcess/DrawProcessSaveLoadControls.vue:

Mở file này.
Đảm bảo dòng import service trỏ đến file dùng chung: import { saveCanvasStateToFile, loadCanvasStateFromFile } from '../../services/canvasStateService.js';
Các component con khác (DrawProcessRectangle, DrawProcessContextMenu, DrawProcessEditFormModal):

Mở từng file và kiểm tra các dòng import. Hầu hết chúng có thể không import gì nhiều hoặc chỉ import types. Đảm bảo import types trỏ đúng đến src/types/drawingTypes.js.
Bước 7: Thêm Route Mới

Mở file src/router/index.js:

javascript
// src/router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import HelloWorld from '../components/HelloWorld.vue'
import DrawingCanvas from '../components/drawing/DrawingCanvas.vue'
// Import component canvas mới
import DrawProcessCanvas from '../components/DrawProcess/DrawProcessCanvas.vue'

const routes = [
  { path: '/', name: 'HelloWorld', component: HelloWorld },
  { path: '/drawing', name: 'DrawingCanvas', component: DrawingCanvas },
  // Thêm route mới cho DrawProcess
  {
    path: '/process', // Chọn đường dẫn mới, ví dụ: /process
    name: 'DrawProcessCanvas',
    component: DrawProcessCanvas
  },
]

const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes
})

export default router
Bước 8: Thêm Liên kết Điều hướng

Mở App.vue (hoặc nơi bạn đặt điều hướng) và thêm liên kết:

vue
// src/App.vue (Ví dụ)
<template>
  <nav>
    <router-link to="/">Home</router-link> |
    <router-link to="/drawing">Bản vẽ gốc</router-link> |
    <router-link to="/process">Quy trình mới</router-link> <!-- Liên kết mới -->
  </nav>
  <router-view/>
</template>
Kiểm tra:

Chạy lại ứng dụng (npm run serve hoặc yarn serve).
Kiểm tra xem có lỗi import nào trong console không.
Truy cập /drawing và đảm bảo nó vẫn hoạt động như cũ.
Truy cập /process và kiểm tra:
Palette có hiển thị các mục từ public/process_templates/manifest.json không?
Kéo thả có hoạt động và load schema từ các file XML trong public/process_templates/ không?
Chỉnh sửa, kết nối, lưu/tải trạng thái có hoạt động độc lập với trang /drawing không?
Bây giờ bạn đã có một bản sao đầy đủ và độc lập của chức năng vẽ trong thư mục DrawProcess, sẵn sàng để bạn tùy chỉnh và phát triển thêm.

Rate this answer: 

Tùng Giang Lâm
tôi muốn bạn làm thay tôi các bước đã nêu và tạo code full cho các file


Gemini
Ok, tôi sẽ thực hiện các bước đã nêu và cung cấp code đầy đủ cho các file mới hoặc file cần sửa đổi đáng kể.

Giả định: Cấu trúc thư mục gốc của bạn là chuẩn Vue CLI (có src/, public/).

1. Cấu trúc thư mục mới:

Đảm bảo bạn đã tạo các thư mục:

src/components/DrawProcess/
public/process_templates/
src/data/
src/services/ (Nếu chưa có)
src/types/ (Nếu chưa có)
2 & 3. Sao chép và Đổi tên File:

Components: Sao chép các file từ src/components/drawing/ và src/components/state/ vào src/components/DrawProcess/ và đổi tên như sau:
DrawProcessCanvas.vue
DrawProcessRectangle.vue
DrawProcessContextMenu.vue
DrawProcessEditFormModal.vue
DrawProcessSaveLoadControls.vue
Config: Sao chép manifest.json và tất cả *.xml từ public/templates/ vào public/process_templates/.
Logic: Sao chép src/data/drawingSchemas.js thành src/data/drawProcessSchemas.js.
Shared: Giữ nguyên src/services/canvasStateService.js và src/types/drawingTypes.js.
4. Code cho các File Mới/Sửa đổi:

src/data/drawProcessSchemas.js (Bản sao của drawingSchemas.js với đường dẫn đã sửa)

javascript
// src/data/drawProcessSchemas.js
import { ref, reactive } from 'vue';

// Ref này chứa thông tin cơ bản cho palette của DrawProcess
export const paletteItems = ref([]);

// Cache để lưu trữ các schema đã được load đầy đủ cho DrawProcess
const loadedSchemasCache = reactive({});

/**
 * Helper function để parse nội dung XML của một file template duy nhất.
 * (Giữ nguyên logic parse từ phiên bản trước)
 * @param {string} xmlText Nội dung XML của file.
 * @param {string} filename Tên file (để log lỗi).
 * @returns {object | null} Đối tượng template đã parse hoặc null nếu lỗi.
 */
const parseSingleTemplateXML = (xmlText, filename) => {
    try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "application/xml");

        const parserErrors = xmlDoc.getElementsByTagName("parsererror");
        if (parserErrors.length > 0) {
            console.error(`XML Parsing Error in ${filename}:`, parserErrors[0].textContent);
            return null;
        }
        const itemNode = xmlDoc.querySelector("sourceItem > item");
         if (!itemNode) {
             console.warn(`Could not find <item> node within <sourceItem> in ${filename}`);
             return null;
        }

        const schemaId = itemNode.getAttribute('schemaId');
        const color = itemNode.getAttribute('color');
        const formSchemaNode = itemNode.querySelector("formSchema");
        const formSchema = {}; // Cấu trúc: { key: { value: ..., type: ... } }

        if (formSchemaNode) {
            const fieldNodes = formSchemaNode.querySelectorAll("field");
            fieldNodes.forEach(fieldNode => {
                const key = fieldNode.getAttribute('key');
                const type = fieldNode.getAttribute('type') || 'text';
                let value = fieldNode.textContent || "";

                if (type === 'boolean') {
                    value = value.toLowerCase() === 'true';
                }
                // Thêm xử lý type khác nếu cần

                if (key) {
                    formSchema[key] = { value: value, type: type };
                }
            });
        }

        if (schemaId && color) {
            return { schemaId, color, formSchema };
        } else {
            console.warn(`Skipping item from ${filename} due to missing schemaId or color.`);
            return null;
        }

    } catch (error) {
        console.error(`Error parsing XML from ${filename}:`, error);
        return null;
    }
};


/**
 * Hàm bất đồng bộ để tải thông tin cơ bản cho palette từ manifest.
 * @param {string} manifestPath Đường dẫn đến file manifest JSON
 * @returns {Promise<void>}
 * @throws {Error} Nếu có lỗi khi fetch manifest.
 */
export const loadPaletteData = async (manifestPath = '/process_templates/manifest.json') => { // SỬA ĐƯỜNG DẪN MẶC ĐỊNH
    console.log(`[DrawProcess] Attempting to load palette data from manifest: ${manifestPath}`);
    try {
        const response = await fetch(manifestPath);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status} while fetching ${manifestPath}`);
        }
        const manifestData = await response.json();

        if (!Array.isArray(manifestData)) {
            throw new Error(`Manifest file ${manifestPath} did not contain a valid JSON array.`);
        }

        paletteItems.value = manifestData.map(item => ({
            schemaId: item.schemaId,
            color: item.color,
            filename: item.filename
        }));

        console.log('[DrawProcess] Successfully loaded palette data:', paletteItems.value);

    } catch (error) {
        console.error("[DrawProcess] Error loading or parsing manifest file:", error);
        paletteItems.value = [];
        throw error;
    }
};

/**
 * Hàm bất đồng bộ để lấy hoặc tải cấu hình đầy đủ (bao gồm formSchema) của một schemaId.
 * @param {string} schemaId ID của schema cần lấy/load.
 * @returns {Promise<object | null>} Promise trả về đối tượng formSchema hoặc null nếu lỗi/không tìm thấy.
 */
export const getOrLoadFormSchema = async (schemaId) => {
    if (loadedSchemasCache[schemaId]) {
        console.log(`[DrawProcess] Schema ${schemaId} found in cache.`);
        return loadedSchemasCache[schemaId].formSchema;
    }

    const itemInfo = paletteItems.value.find(p => p.schemaId === schemaId);
    if (!itemInfo || !itemInfo.filename) {
        console.error(`[DrawProcess] Schema info or filename not found for schemaId: ${schemaId} in paletteItems.`);
        return null;
    }

    // SỬA ĐƯỜNG DẪN KHI FETCH XML
    const xmlFilePath = `/process_templates/${itemInfo.filename}`;
    console.log(`[DrawProcess] Schema ${schemaId} not in cache. Loading from ${xmlFilePath}...`);
    try {
        const response = await fetch(xmlFilePath);
        if (!response.ok) {
            console.error(`[DrawProcess] HTTP error! status: ${response.status} while fetching ${xmlFilePath}`);
            return null;
        }
        const xmlText = await response.text();
        const fullSchemaData = parseSingleTemplateXML(xmlText, itemInfo.filename);

        if (fullSchemaData && fullSchemaData.formSchema) {
            loadedSchemasCache[schemaId] = fullSchemaData;
            console.log(`[DrawProcess] Schema ${schemaId} loaded and cached.`);
            return fullSchemaData.formSchema;
        } else {
            console.error(`[DrawProcess] Failed to parse valid schema data from ${xmlFilePath}`);
            return null;
        }
    } catch (error) {
        console.error(`[DrawProcess] Error fetching or processing ${xmlFilePath}:`, error);
        return null;
    }
};

/**
 * Helper để lấy formSchema đã được load (chỉ từ cache).
 * @param {string} schemaId
 * @returns {object} formSchema hoặc {} nếu không có trong cache.
 */
export const getCachedSchemaById = (schemaId) => {
    const cachedData = loadedSchemasCache[schemaId];
     try {
        return cachedData ? structuredClone(cachedData.formSchema) : {};
    } catch (e) {
        console.warn("[DrawProcess] structuredClone failed in getCachedSchemaById, using JSON fallback.");
        return cachedData ? JSON.parse(JSON.stringify(cachedData.formSchema)) : {};
    }
};
src/components/DrawProcess/DrawProcessCanvas.vue (Bản sao của DrawingCanvas.vue với import và đường dẫn đã sửa)

vue
<template>
    <div v-if="isLoading" class="loading-indicator">
        Đang tải dữ liệu quy trình...
    </div>
    <div v-else-if="loadError" class="error-message">
        Lỗi tải dữ liệu quy trình. Vui lòng thử lại.
    </div>

    <div v-else class="draw-process-app-container"> <!-- Đổi tên class container -->
        <div class="draw-process-app"> <!-- Đổi tên class app -->
            <!-- Palette -->
            <div class="palette">
                <h3>Kéo mẫu quy trình:</h3>
                <div v-for="item in paletteItems" :key="item.schemaId" class="source-rect"
                    :style="{ backgroundColor: item.color }" draggable="true"
                    @dragstart="handleSourceDragStart($event, item)"></div>
            </div>

            <!-- Canvas -->
            <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
                <h3>Thả vào đây để vẽ quy trình:</h3>

                <!-- SVG Layer -->
                <svg class="connection-lines">
                    <defs>
                        <marker id="proc-arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3"
                            orient="auto-start-reverse" markerUnits="strokeWidth">
                            <path d="M0,0 L8,3 L0,6 Z" fill="#555" />
                        </marker>
                    </defs>
                    <g>
                        <template v-for="(rect, index) in sortedRectangles" :key="rect.id + '-proc-elbow'">
                            <template v-if="index < sortedRectangles.length - 1">
                                <polyline :points="calculateElbowPoints(rect, sortedRectangles[index + 1])" fill="none"
                                    stroke="#555" stroke-width="1.5" stroke-dasharray="4, 4" marker-end="url(#proc-arrowhead)" />
                            </template>
                        </template>
                    </g>
                </svg>

                <!-- Component Rectangle -->
                <!-- Sử dụng component đã đổi tên -->
                <DrawProcessRectangle v-for="rect in drawnRectangles" :key="rect.id" :rect="rect" :prevent-drag="isModalVisible"
                    @dragstart.stop="handleRectDragStart($event, rect)" @dragend="handleRectDragEnd"
                    @contextmenu="showContextMenu($event, rect)" @open-edit="openEditModal" />

                <!-- Loading Overlay -->
                <div v-if="isSchemaLoading" class="schema-loading-overlay">
                    Đang tải cấu hình...
                </div>
            </div>
        </div>

        <!-- Component Save/Load Controls -->
        <!-- Sử dụng component đã đổi tên -->
        <DrawProcessSaveLoadControls
            :current-rectangles="drawnRectangles"
            @state-loaded="onStateLoaded"
            class="controls-container"
        />

        <!-- Modals -->
        <!-- Sử dụng component đã đổi tên -->
        <DrawProcessContextMenu :visible="contextMenu.visible" :top="contextMenu.top" :left="contextMenu.left" @edit="handleEdit"
            @delete="handleDelete" ref="contextMenuRef" />
        <DrawProcessEditFormModal :visible="isModalVisible" :rect-data="editingRect" :schema="getCachedSchemaForRect(editingRect)"
            @save="saveForm" @cancel="cancelForm" />

    </div>
</template>

<script setup>
/* eslint-disable */
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { debounce } from 'lodash-es';
// Sửa import component con
import DrawProcessRectangle from './DrawProcessRectangle.vue';
import DrawProcessContextMenu from './DrawProcessContextMenu.vue';
import DrawProcessEditFormModal from './DrawProcessEditFormModal.vue';
import DrawProcessSaveLoadControls from './DrawProcessSaveLoadControls.vue';

// Sửa import schema logic
import { paletteItems, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawProcessSchemas.js';
// Import types (dùng chung)
import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';

// --- State --- (Giữ nguyên tên biến, nhưng chúng thuộc về instance này)
const isLoading = ref(true);
const loadError = ref(false);
const isSchemaLoading = ref(false);
const drawnRectangles = ref([]);
const canvasRef = ref(null);
const defaultRectWidth = 50;
const defaultRectHeight = 50;
const draggingRectId = ref(null);
const currentOrder = ref(1);
const contextMenuRef = ref(null);
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null });
const isModalVisible = ref(false);
const editingRect = ref(null);

// --- Computed ---
const sortedRectangles = computed(() => {
    return drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
});

// --- Helpers ---
const getCachedSchemaForRect = (rect) => {
    return rect ? getCachedSchemaById(rect.schemaId) : {};
};

const calculateElbowPoints = (rectA, rectB) => {
    if (!rectA || !rectB) return "";
    let startX, endX;
    const startY = rectA.y + rectA.height / 2;
    const endY = rectB.y + rectB.height / 2;
    if (rectB.x >= rectA.x + rectA.width) {
        startX = rectA.x + rectA.width; endX = rectB.x;
    } else if (rectB.x + rectB.width <= rectA.x) {
        startX = rectA.x; endX = rectB.x + rectB.width;
    } else {
        startX = rectA.x + rectA.width; endX = rectB.x;
    }
    const midX = (startX + endX) / 2;
    return `${startX},${startY} ${midX},${startY} ${midX},${endY} ${endX},${endY}`;
};

// --- Event Handlers ---
const handleWindowChange = debounce(() => {
    if (contextMenu.value.visible) closeContextMenu();
}, 150);

// --- Lifecycle Hooks ---
onMounted(async () => {
    try {
        // SỬA ĐƯỜNG DẪN MANIFEST
        await loadPaletteData('/process_templates/manifest.json');
        loadError.value = false;
    } catch (error) {
        console.error("[DrawProcess] Failed to initialize due to palette data loading error:", error);
        loadError.value = true;
    } finally {
        isLoading.value = false;
    }
    window.addEventListener('click', handleClickOutside);
    window.addEventListener('resize', handleWindowChange);
    window.addEventListener('scroll', handleWindowChange, true);
});

onUnmounted(() => {
    window.removeEventListener('click', handleClickOutside);
    window.removeEventListener('resize', handleWindowChange);
    window.removeEventListener('scroll', handleWindowChange, true);
    handleWindowChange.cancel?.();
});

// --- Event Handlers ---

const onStateLoaded = (loadedRectangles) => {
    console.log("[DrawProcess] Received loaded state:", loadedRectangles);
    drawnRectangles.value = loadedRectangles;
    currentOrder.value = loadedRectangles.length > 0 ? Math.max(...loadedRectangles.map(r => r.order)) + 1 : 1;
    console.log("[DrawProcess] Canvas state restored. New currentOrder:", currentOrder.value);
    const uniqueSchemaIds = [...new Set(loadedRectangles.map(r => r.schemaId))];
    console.log("[DrawProcess] Pre-loading schemas for IDs:", uniqueSchemaIds);
    uniqueSchemaIds.forEach(id => {
        getOrLoadFormSchema(id).catch(err => {
            console.error(`[DrawProcess] Failed to pre-load schema ${id} after state load:`, err);
        });
    });
};

const handleClickOutside = (event) => {
    const contextMenuElement = contextMenuRef.value?.$el || contextMenuRef.value;
    const isClickInsideMenu = contextMenuElement instanceof Element && contextMenuElement.contains(event.target);
    if (contextMenu.value.visible && !isClickInsideMenu) closeContextMenu();
};

const showContextMenu = (event, rect) => {
    if (isModalVisible.value) return;
    if (contextMenu.value.visible) closeContextMenu();
    event.preventDefault();
    contextMenu.value = { visible: true, top: event.clientY, left: event.clientX, targetRectId: rect.id, targetRectOrder: rect.order };
};

const closeContextMenu = () => {
    if (contextMenu.value.visible) {
        contextMenu.value = { visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null };
    }
};

const handleEdit = () => {
    if (contextMenu.value.targetRectId) {
        const rectToEdit = drawnRectangles.value.find(r => r.id === contextMenu.value.targetRectId);
        if (rectToEdit) openEditModal(rectToEdit);
    }
    closeContextMenu();
};

const handleDelete = () => {
    const idToDelete = contextMenu.value.targetRectId;
    closeContextMenu();
    if (idToDelete !== null) {
        const indexToDelete = drawnRectangles.value.findIndex(r => r.id === idToDelete);
        if (indexToDelete > -1) {
            drawnRectangles.value.splice(indexToDelete, 1);
            const remainingSorted = drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
            remainingSorted.forEach((rect, index) => { rect.order = index + 1; });
            currentOrder.value = drawnRectangles.value.length + 1;
        }
    }
};

const openEditModal = (rect) => {
    if (!rect || draggingRectId.value !== null) return;
    closeContextMenu();
    try {
        editingRect.value = { ...rect, formData: structuredClone(rect.formData || {}) };
    } catch (e) {
        editingRect.value = { ...rect, formData: JSON.parse(JSON.stringify(rect.formData || {})) };
    }
    isModalVisible.value = true;
};

const saveForm = (updatedFormData) => {
    if (!editingRect.value) return;
    const originalRectIndex = drawnRectangles.value.findIndex(r => r.id === editingRect.value.id);
    if (originalRectIndex > -1) {
        try {
            drawnRectangles.value[originalRectIndex].formData = structuredClone(updatedFormData);
        } catch (e) {
            drawnRectangles.value[originalRectIndex].formData = JSON.parse(JSON.stringify(updatedFormData));
        }
    }
    cancelForm();
};

const cancelForm = () => {
    isModalVisible.value = false;
    editingRect.value = null;
};

const handleSourceDragStart = (event, item) => {
    closeContextMenu();
    const dataToTransfer = { schemaId: item.schemaId, color: item.color, filename: item.filename };
    try {
        event.dataTransfer.setData(SOURCE_ITEM_DATA_TYPE, JSON.stringify(dataToTransfer));
        event.dataTransfer.effectAllowed = 'copy';
        draggingRectId.value = null;
    } catch (e) { console.error("[DrawProcess] Source Drag Start Error:", e, dataToTransfer); }
};

const handleRectDragStart = (event, rect) => {
    if (contextMenu.value.visible) closeContextMenu();
    if (isModalVisible.value) { event.preventDefault(); return; }
    try {
        event.dataTransfer.setData(RECT_ID_DATA_TYPE, rect.id.toString());
        const offsetData = JSON.stringify({ x: event.offsetX, y: event.offsetY });
        event.dataTransfer.setData(DRAG_OFFSET_DATA_TYPE, offsetData);
        event.dataTransfer.effectAllowed = 'move';
        draggingRectId.value = rect.id;
    } catch (e) { console.error("[DrawProcess] Rect Drag Start Error:", e); event.preventDefault(); }
};

const handleRectDragEnd = (event) => {
    draggingRectId.value = null;
};

const handleDragOver = (event) => {
    event.preventDefault();
    if (event.dataTransfer.types.includes(RECT_ID_DATA_TYPE)) event.dataTransfer.dropEffect = "move";
    else if (event.dataTransfer.types.includes(SOURCE_ITEM_DATA_TYPE)) event.dataTransfer.dropEffect = "copy";
    else event.dataTransfer.dropEffect = "none";
};

const handleDrop = async (event) => {
    event.preventDefault();
    closeContextMenu();
    const canvasRect = canvasRef.value?.getBoundingClientRect();
    if (!canvasRect) { console.error('[DrawProcess] Drop Error: Cannot get canvas bounds.'); draggingRectId.value = null; return; }
    const dropX = event.clientX - canvasRect.left;
    const dropY = event.clientY - canvasRect.top;
    const draggedRectIdStr = event.dataTransfer.getData(RECT_ID_DATA_TYPE);

    if (draggedRectIdStr) { // --- MOVE ---
        try {
            const draggedRectId = parseInt(draggedRectIdStr, 10);
            const offsetData = event.dataTransfer.getData(DRAG_OFFSET_DATA_TYPE);
            let offsetX = 0, offsetY = 0;
            try { const offset = JSON.parse(offsetData || '{}'); offsetX = offset.x || 0; offsetY = offset.y || 0; }
            catch (e) { console.warn('[DrawProcess] Could not parse drag offset data:', offsetData, e); }
            const rectToMove = drawnRectangles.value.find(r => r.id === draggedRectId);
            if (rectToMove) { rectToMove.x = dropX - offsetX; rectToMove.y = dropY - offsetY; }
            else { console.error(`[DrawProcess] Move Error: Cannot find rect with ID ${draggedRectId}.`); }
        } catch (e) { console.error("[DrawProcess] Error processing move drop:", e); }
    } else { // --- CREATE NEW ---
        const sourceItemDataStr = event.dataTransfer.getData(SOURCE_ITEM_DATA_TYPE);
        if (sourceItemDataStr) {
            let sourceItemData;
            try {
                sourceItemData = JSON.parse(sourceItemDataStr);
                console.log('[DrawProcess] Handling CREATE NEW for:', sourceItemData);
                isSchemaLoading.value = true;
                let formSchema = null;
                try { formSchema = await getOrLoadFormSchema(sourceItemData.schemaId); }
                finally { isSchemaLoading.value = false; }
                if (formSchema === null) {
                     console.error(`[DrawProcess] Failed to load formSchema for ${sourceItemData.schemaId}. Creating rect with empty formData.`);
                     formSchema = {};
                }
                const initialFormDataValues = {};
                for (const key in formSchema) initialFormDataValues[key] = formSchema[key]?.value ?? '';
                let clonedInitialValues;
                 try { clonedInitialValues = structuredClone(initialFormDataValues); }
                 catch(e) { clonedInitialValues = JSON.parse(JSON.stringify(initialFormDataValues)); }
                const newRect = {
                    id: Date.now(), color: sourceItemData.color, schemaId: sourceItemData.schemaId,
                    x: dropX - defaultRectWidth / 2, y: dropY - defaultRectHeight / 2,
                    width: defaultRectWidth, height: defaultRectHeight,
                    order: currentOrder.value, formData: clonedInitialValues
                };
                drawnRectangles.value.push(newRect);
                currentOrder.value++;
            } catch (e) { console.error("[DrawProcess] Drop Error:", e, sourceItemDataStr); isSchemaLoading.value = false; }
        } else { console.warn('[DrawProcess] Drop Warning: No valid data found.'); }
    }
    draggingRectId.value = null;
};
</script>

<style scoped>
/* Đổi tên class bao ngoài */
.draw-process-app-container {
    display: flex;
    flex-direction: column;
}

/* Đổi tên class app */
.draw-process-app {
    display: flex;
    gap: 2rem;
    font-family: sans-serif;
}

.controls-container {
     margin: 1rem auto;
     width: fit-content;
}

/* Các style khác giữ nguyên hoặc điều chỉnh nếu cần */
.schema-loading-overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(255, 255, 255, 0.7); display: flex;
    justify-content: center; align-items: center; font-size: 1.2em;
    color: #333; z-index: 10;
}
.loading-indicator, .error-message { padding: 2rem; text-align: center; font-style: italic; color: #666; }
.error-message { color: red; font-weight: bold; }
.palette { border: 1px solid #ccc; padding: 1rem; display: flex; flex-direction: column; align-items: center; gap: 0.5rem; background-color: #f8f8f8; height: fit-content; }
.palette h3 { margin: 0 0 0.5rem 0; font-size: 0.9em; color: #555; }
.source-rect { width: 50px; height: 50px; border: 1px solid #eee; cursor: grab; transition: transform 0.2s ease; }
.source-rect:active { cursor: grabbing; transform: scale(1.1); }
.canvas { border: 2px dashed #007bff; width: 100%; height: 500px; position: relative; background-color: #e9ecef; overflow: hidden; }
.canvas h3 { position: absolute; top: 5px; left: 10px; margin: 0; font-size: 0.9em; color: #6c757d; pointer-events: none; }
.connection-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
</style>
src/components/DrawProcess/DrawProcessRectangle.vue (Bản sao của DrawnRectangle.vue, chỉ cần kiểm tra import types)

vue
<template>
    <div
        class="drawn-rect"
        :style="rectStyle"
        :draggable="!preventDrag"
        @dragstart="handleDragStart"
        @dragend="handleDragEnd"
        @contextmenu.prevent="handleContextMenu"
        @click="handleClick"
    >
        <!-- Hiển thị tên hoặc ID nếu muốn -->
         <!-- <span class="rect-label">{{ rect.formData?.['Tên'] || rect.schemaId }}</span> -->
    </div>
</template>

<script setup>
import { computed } from 'vue';
// Đảm bảo import types đúng đường dẫn
// import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE } from '../../types/drawingTypes.js'; // Không cần trực tiếp ở đây

const props = defineProps({
    rect: {
        type: Object,
        required: true
    },
    preventDrag: { // Prop để ngăn kéo khi modal mở
        type: Boolean,
        default: false
    }
});

const emit = defineEmits(['dragstart', 'dragend', 'contextmenu', 'open-edit']);

const rectStyle = computed(() => ({
    position: 'absolute',
    left: `${props.rect.x}px`,
    top: `${props.rect.y}px`,
    width: `${props.rect.width}px`,
    height: `${props.rect.height}px`,
    backgroundColor: props.rect.color,
    border: '1px solid #333',
    cursor: props.preventDrag ? 'default' : 'grab',
    zIndex: 2, // Đảm bảo hình chữ nhật nổi trên đường kẻ SVG
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontSize: '10px',
    color: '#fff', // Màu chữ, có thể cần điều chỉnh
    overflow: 'hidden',
    userSelect: 'none' // Ngăn chọn text bên trong khi kéo
}));

const handleDragStart = (event) => {
    if (props.preventDrag) {
        event.preventDefault();
        return;
    }
    event.target.style.cursor = 'grabbing';
    emit('dragstart', event, props.rect); // Truyền cả event và rect lên cha
};

const handleDragEnd = (event) => {
     if (props.preventDrag) return;
    event.target.style.cursor = 'grab';
    emit('dragend', event);
};

const handleContextMenu = (event) => {
    emit('contextmenu', event, props.rect);
};

const handleClick = (event) => {
    // Ngăn chặn việc mở modal nếu đang kéo (mặc dù drag/drop thường ngăn click)
    if (props.preventDrag) return;
    // Có thể thêm logic double click ở đây nếu muốn
    // emit('open-edit', props.rect); // Quyết định xem click có mở edit không, hay chỉ context menu
};
</script>

<style scoped>
.drawn-rect {
    box-sizing: border-box;
}
.drawn-rect:active {
    /* cursor: grabbing; */ /* Đã xử lý bằng JS */
    /* Có thể thêm hiệu ứng khác khi active */
}
.rect-label {
    pointer-events: none; /* Để không cản trở drag */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    padding: 0 2px;
}
</style>
src/components/DrawProcess/DrawProcessContextMenu.vue (Bản sao của ContextMenu.vue)

vue
<template>
    <div v-if="visible" class="context-menu" :style="menuStyle">
        <ul>
            <li @click="handleEdit">Chỉnh sửa</li>
            <li @click="handleDelete">Xóa</li>
        </ul>
    </div>
</template>

<script setup>
import { computed } from 'vue';

const props = defineProps({
    visible: Boolean,
    top: Number,
    left: Number
});

const emit = defineEmits(['edit', 'delete']);

const menuStyle = computed(() => ({
    top: `${props.top}px`,
    left: `${props.left}px`,
}));

const handleEdit = () => {
    emit('edit');
};

const handleDelete = () => {
    emit('delete');
};
</script>

<style scoped>
.context-menu {
    position: fixed; /* Hoặc absolute tùy vào container cha */
    background-color: #fff;
    border: 1px solid #ccc;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.15);
    border-radius: 4px;
    z-index: 1001; /* Cao hơn modal overlay */
    min-width: 100px;
}

.context-menu ul {
    list-style: none;
    padding: 5px 0;
    margin: 0;
}

.context-menu li {
    padding: 8px 15px;
    cursor: pointer;
    font-size: 0.9rem;
}

.context-menu li:hover {
    background-color: #f0f0f0;
}
</style>
src/components/DrawProcess/DrawProcessEditFormModal.vue (Bản sao của EditFormModal.vue)

vue
<template>
    <div v-if="visible" class="modal-overlay" @click.self="handleCancel">
        <div class="modal-content">
            <h2>Chỉnh sửa thông tin quy trình</h2> <!-- Sửa tiêu đề -->
            <form @submit.prevent="handleSave">
                <div v-for="(fieldData, key) in schema" :key="key" class="form-group">
                    <label :for="'proc-field-' + key">{{ key }}:</label> <!-- Thêm prefix cho ID -->

                    <!-- Input Text -->
                    <input v-if="fieldData.type === 'text'" type="text" :id="'proc-field-' + key" v-model="formData[key]" />
                    <!-- Input Number -->
                    <input v-else-if="fieldData.type === 'number'" type="number" :id="'proc-field-' + key" v-model.number="formData[key]" />
                    <!-- Input Date -->
                    <input v-else-if="fieldData.type === 'date'" type="date" :id="'proc-field-' + key" v-model="formData[key]" />
                    <!-- Textarea -->
                    <textarea v-else-if="fieldData.type === 'textarea'" :id="'proc-field-' + key" v-model="formData[key]" rows="3"></textarea>
                    <!-- Checkbox (Boolean) -->
                    <input v-else-if="fieldData.type === 'boolean'" type="checkbox" :id="'proc-field-' + key" v-model="formData[key]" class="form-checkbox" />
                    <!-- Input Email -->
                     <input v-else-if="fieldData.type === 'email'" type="email" :id="'proc-field-' + key" v-model="formData[key]" />
                     <!-- Input URL -->
                     <input v-else-if="fieldData.type === 'url'" type="url" :id="'proc-field-' + key" v-model="formData[key]" />
                    <!-- Fallback -->
                    <input v-else type="text" :id="'proc-field-' + key" v-model="formData[key]" :placeholder="`Unknown type: ${fieldData.type}`" />
                </div>

                <div class="modal-actions">
                    <button type="submit" class="btn btn-save">Lưu</button>
                    <button type="button" @click="handleCancel" class="btn btn-cancel">Hủy</button>
                </div>
            </form>
        </div>
    </div>
</template>

<script setup>
import { ref, watch } from 'vue';

const props = defineProps({
    visible: Boolean,
    rectData: Object,
    schema: Object // { key: { value: ..., type: ... } }
});

const emit = defineEmits(['save', 'cancel']);
const formData = ref({});

watch(() => [props.rectData, props.schema], ([newRectData, newSchema]) => {
    if (newRectData && newSchema && Object.keys(newSchema).length > 0) {
        const initialData = {};
        for (const key in newSchema) {
            initialData[key] = newRectData.formData?.[key] !== undefined
                               ? newRectData.formData[key]
                               : newSchema[key]?.value ?? '';
        }
        formData.value = initialData;
    } else {
        formData.value = {};
    }
}, { immediate: true, deep: true });

const handleSave = () => {
    emit('save', { ...formData.value });
};

const handleCancel = () => {
    emit('cancel');
};
</script>

<style scoped>
/* Style giữ nguyên như EditFormModal gốc */
.modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
.modal-content { background-color: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); min-width: 350px; max-width: 500px; }
h2 { margin-top: 0; margin-bottom: 20px; color: #333; text-align: center; }
.form-group { margin-bottom: 15px; }
.form-group label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
.form-group input[type="text"], .form-group input[type="number"], .form-group input[type="date"], .form-group input[type="email"], .form-group input[type="url"], .form-group textarea { width: 100%; padding: 8px 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1rem; }
.form-group textarea { resize: vertical; }
.form-group input[type="checkbox"].form-checkbox { width: auto; margin-right: 5px; vertical-align: middle; }
.form-group input[type="checkbox"].form-checkbox + label { display: inline-block; margin-bottom: 0; vertical-align: middle; }
.modal-actions { margin-top: 25px; text-align: right; }
.btn { padding: 10px 18px; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem; margin-left: 10px; transition: background-color 0.2s ease; }
.btn-save { background-color: #28a745; color: white; }
.btn-save:hover { background-color: #218838; }
.btn-cancel { background-color: #6c757d; color: white; }
.btn-cancel:hover { background-color: #5a6268; }
</style>
Use code with care. Learn more
src/components/DrawProcess/DrawProcessSaveLoadControls.vue (Bản sao của SaveLoadControls.vue, chỉ cần kiểm tra import service)

vue
<template>
    <div class="save-load-controls">
        <button @click="handleSave" class="btn btn-save-state" :disabled="!canSave">Lưu Quy trình</button>
        <button @click="handleLoad" class="btn btn-load-state">Tải Quy trình</button>
    </div>
</template>

<script setup>
import {  computed } from 'vue';
// Đảm bảo import đúng service dùng chung
import { saveCanvasStateToFile, loadCanvasStateFromFile } from '../../services/canvasStateService.js';

const props = defineProps({
    currentRectangles: { type: Array, required: true }
});
const emit = defineEmits(['stateLoaded']);

const canSave = computed(() => props.currentRectangles && props.currentRectangles.length > 0);

const handleSave = () => {
    if (!canSave.value) return;
    // Có thể đổi tên file lưu mặc định
    saveCanvasStateToFile(props.currentRectangles, 'my_process.json');
};

const handleLoad = async () => {
    try {
        const loadedData = await loadCanvasStateFromFile();
        if (loadedData) emit('stateLoaded', loadedData);
    } catch (error) {
        console.error("[DrawProcess] Load operation failed in component:", error);
        alert("Tải quy trình thất bại.");
    }
};
</script>

<style scoped>
/* Style giữ nguyên như SaveLoadControls gốc */
.save-load-controls { margin-top: 1rem; padding: 0.5rem; background-color: #f0f0f0; border-radius: 4px; display: flex; gap: 10px; justify-content: center; }
.btn { padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; transition: background-color 0.2s ease, opacity 0.2s ease; }
.btn-save-state { background-color: #007bff; color: white; }
.btn-save-state:hover { background-color: #0056b3; }
.btn-save-state:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.7; }
.btn-load-state { background-color: #ffc107; color: #333; }
.btn-load-state:hover { background-color: #e0a800; }
</style>
src/router/index.js (Thêm route mới)

javascript
import { createRouter, createWebHistory } from 'vue-router'
import HelloWorld from '../components/HelloWorld.vue'
import DrawingCanvas from '../components/drawing/DrawingCanvas.vue'
// Import component canvas mới
import DrawProcessCanvas from '../components/DrawProcess/DrawProcessCanvas.vue' // Đảm bảo đường dẫn đúng

const routes = [
  {
    path: '/',
    name: 'HelloWorld',
    component: HelloWorld
  },
  {
    path: '/drawing', // Route cho bản gốc
    name: 'DrawingCanvas',
    component: DrawingCanvas
  },
  // Thêm route mới cho DrawProcess
  {
    path: '/process', // Đường dẫn mới
    name: 'DrawProcessCanvas', // Tên route mới
    component: DrawProcessCanvas // Component mới
  },
]

const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes
})

export default router
src/App.vue (Thêm liên kết điều hướng)

vue
<template>
  <nav>
    <router-link to="/">Home</router-link> |
    <router-link to="/drawing">Bản vẽ gốc</router-link> |
    <router-link to="/process">Quy trình mới</router-link> <!-- Liên kết mới -->
  </nav>
  <router-view/>
</template>

<style>
nav { padding: 30px; }
nav a { font-weight: bold; color: #2c3e50; }
nav a.router-link-exact-active { color: #42b983; }
</style>
File cấu hình:

public/process_templates/manifest.json: Nội dung giống hệt public/templates/manifest.json ban đầu.
public/process_templates/*.xml: Nội dung giống hệt các file XML tương ứng trong public/templates/ ban đầu.
File dùng chung (Không cần tạo mới):

src/services/canvasStateService.js
src/types/drawingTypes.js
Sau khi tạo và cập nhật các file này, bạn nên có một bản sao chức năng hoàn chỉnh tại route /process.

Rate this answer: 
External Sources (1)

Tùng Giang Lâm
tôi bị sót file canvasStateService.js


Gemini
Chắc chắn rồi, bạn nói đúng. Tôi đã mô tả chức năng của canvasStateService.js nhưng lại quên đưa code đầy đủ của nó vào. Xin lỗi vì sự thiếu sót đó.

Đây là nội dung đầy đủ cho file src/services/canvasStateService.js. File này có thể được dùng chung cho cả DrawingCanvas và DrawProcessCanvas vì logic lưu/tải file là độc lập.

src/services/canvasStateService.js

javascript
// src/services/canvasStateService.js

/**
 * Lưu trạng thái các hình chữ nhật vào file JSON và kích hoạt tải xuống.
 * @param {Array<object>} rectanglesData Mảng dữ liệu drawnRectangles (hoặc tương đương).
 * @param {string} [filename='canvas_state.json'] Tên file mặc định để lưu.
 */
export function saveCanvasStateToFile(rectanglesData, filename = 'canvas_state.json') {
    try {
        // 1. Chuyển đổi sang JSON (với định dạng đẹp để dễ đọc)
        // Sử dụng replacer là null và space là 2 để có thụt lề
        const jsonString = JSON.stringify(rectanglesData, null, 2);

        // 2. Tạo Blob (Binary Large Object) từ chuỗi JSON
        // Kiểu MIME là application/json
        const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8' });

        // 3. Tạo URL tạm thời cho Blob
        // URL này chỉ tồn tại trong phiên làm việc của trình duyệt
        const url = URL.createObjectURL(blob);

        // 4. Tạo một thẻ <a> ẩn để kích hoạt tải xuống
        const a = document.createElement('a');
        a.style.display = 'none'; // Ẩn thẻ a đi
        a.href = url;
        a.download = filename; // Đặt tên file tải xuống

        // 5. Thêm thẻ <a> vào DOM (cần thiết cho Firefox) và kích hoạt click
        document.body.appendChild(a);
        a.click();

        // 6. Dọn dẹp: Xóa thẻ <a> và thu hồi URL tạm thời để giải phóng bộ nhớ
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        console.log(`Canvas state saved to ${filename}`);
        // Có thể thêm thông báo thành công cho người dùng nếu muốn
        // alert(`Đã lưu trạng thái vào file ${filename}`);

    } catch (error) {
        console.error("Error saving canvas state:", error);
        // Thông báo lỗi cho người dùng
        alert("Đã xảy ra lỗi khi lưu trạng thái. Vui lòng kiểm tra console để biết thêm chi tiết.");
    }
}

/**
 * Mở hộp thoại chọn file và đọc trạng thái từ file JSON.
 * @returns {Promise<Array<object> | null>} Promise trả về mảng dữ liệu đã load hoặc null nếu người dùng hủy hoặc có lỗi đọc/parse cơ bản.
 */
export function loadCanvasStateFromFile() {
    return new Promise((resolve, reject) => {
        // 1. Tạo một input type="file" ẩn
        const input = document.createElement('input');
        input.type = 'file';
        // Chỉ chấp nhận các file có đuôi .json hoặc kiểu MIME application/json
        input.accept = '.json,application/json';
        input.style.display = 'none'; // Ẩn input đi

        // 2. Lắng nghe sự kiện 'change' (khi người dùng chọn file)
        input.onchange = (event) => {
            // Lấy file đầu tiên được chọn
            const file = event.target.files?.[0];

            // Nếu không có file nào được chọn (người dùng nhấn Cancel)
            if (!file) {
                console.log("File selection cancelled by user.");
                resolve(null); // Trả về null để báo hiệu hủy bỏ
                return;
            }

            // 3. Sử dụng FileReader để đọc nội dung file
            const reader = new FileReader();

            // 4. Xử lý khi đọc file thành công
            reader.onload = (e) => {
                try {
                    // Lấy nội dung file dưới dạng chuỗi
                    const jsonString = e.target?.result;
                    if (typeof jsonString !== 'string') {
                         throw new Error("Failed to read file content as string.");
                    }

                    // 5. Parse chuỗi JSON thành đối tượng JavaScript
                    const loadedData = JSON.parse(jsonString);

                    // 6. Kiểm tra cơ bản xem dữ liệu có phải là một mảng không
                    // (Vì trạng thái của chúng ta là một mảng các hình chữ nhật)
                    if (!Array.isArray(loadedData)) {
                        throw new Error("Loaded file does not contain a valid JSON array.");
                    }

                    console.log("Canvas state loaded successfully:", loadedData);
                    resolve(loadedData); // Trả về dữ liệu đã load thành công

                } catch (error) {
                    // Xử lý lỗi nếu parse JSON thất bại hoặc dữ liệu không hợp lệ
                    console.error("Error parsing loaded JSON file:", error);
                    alert("Lỗi đọc hoặc phân tích file trạng thái. File có thể không đúng định dạng JSON hoặc bị hỏng.");
                    reject(error); // Báo lỗi ra ngoài Promise
                } finally {
                    // Dọn dẹp input sau khi xử lý xong
                    document.body.removeChild(input);
                }
            };

            // 7. Xử lý khi đọc file thất bại
            reader.onerror = (error) => {
                console.error("Error reading file:", error);
                alert("Đã xảy ra lỗi khi đọc file.");
                reject(error); // Báo lỗi ra ngoài Promise
                // Dọn dẹp input
                document.body.removeChild(input);
            };

            // 8. Bắt đầu đọc file dưới dạng text (UTF-8 mặc định)
            reader.readAsText(file);
        };

        // 9. Thêm input vào DOM và kích hoạt click để mở hộp thoại chọn file
        document.body.appendChild(input);
        input.click();

        // Lưu ý: Input sẽ tự động bị xóa trong reader.onload hoặc reader.onerror
    });
}
Bạn có thể đặt file này vào thư mục src/services/. Các component DrawProcessSaveLoadControls.vue và SaveLoadControls.vue (của bản gốc) đều có thể import và sử dụng các hàm từ file này.

Rate this answer: 

Tùng Giang Lâm
hãy kiểm tra code vì sao các hình thả trên canvas trong thư mục không có số thứ tự


Gemini
Bạn đã đúng khi đặt câu hỏi này, nhưng file canvasStateService.js bạn cung cấp không phải là nơi gây ra lỗi này. File đó chỉ xử lý việc lưu và tải toàn bộ trạng thái của canvas, không liên quan đến việc gán số thứ tự khi một hình mới được thả vào.

Vấn đề thiếu số thứ tự khi thả hình mới thường nằm ở một trong hai nơi:

Logic gán số thứ tự khi tạo hình mới: Trong file src/components/DrawProcess/DrawProcessCanvas.vue, hàm handleDrop (cụ thể là phần xử lý CREATE NEW) phải gán giá trị order cho đối tượng newRect và sau đó tăng biến đếm currentOrder.
Hiển thị số thứ tự trên hình chữ nhật: File src/components/DrawProcess/DrawProcessRectangle.vue phải có code trong template để hiển thị giá trị rect.order.
Kiểm tra và Sửa lỗi:

Bước 1: Kiểm tra Logic Gán Thứ Tự trong DrawProcessCanvas.vue

Mở file src/components/DrawProcess/DrawProcessCanvas.vue và tìm đến hàm handleDrop. Bên trong khối else (xử lý việc tạo hình mới), hãy đảm bảo bạn có những dòng tương tự như sau:

javascript
// Bên trong hàm handleDrop, khối else (CREATE NEW)

// ... (sau khi load formSchema và tạo initialFormDataValues) ...

                const newRect = {
                    id: Date.now(),
                    color: sourceItemData.color,
                    schemaId: sourceItemData.schemaId,
                    x: dropX - defaultRectWidth / 2,
                    y: dropY - defaultRectHeight / 2,
                    width: defaultRectWidth,
                    height: defaultRectHeight,
                    // >>> ĐẢM BẢO DÒNG NÀY TỒN TẠI VÀ ĐÚNG <<<
                    order: currentOrder.value,
                    formData: clonedInitialValues
                };
                drawnRectangles.value.push(newRect);
                // >>> ĐẢM BẢO DÒNG NÀY TỒN TẠI VÀ ĐÚNG <<<
                currentOrder.value++;

// ... (phần còn lại) ...
Xác nhận: Dòng order: currentOrder.value, có tồn tại khi tạo newRect.
Xác nhận: Dòng currentOrder.value++; có tồn tại ngay sau khi push hình mới vào drawnRectangles.
Xác nhận: Biến currentOrder được khởi tạo đúng cách bằng ref(1) ở đầu phần <script setup>.
Bước 2: Thêm Hiển thị Thứ Tự trong DrawProcessRectangle.vue (Rất có thể đây là vấn đề)

Rất có thể bạn đã gán thứ tự đúng nhưng chưa hiển thị nó. Mở file src/components/DrawProcess/DrawProcessRectangle.vue và cập nhật phần <template> để hiển thị rect.order:

vue
// src/components/DrawProcess/DrawProcessRectangle.vue
<template>
    <div
        class="drawn-rect"
        :style="rectStyle"
        :draggable="!preventDrag"
        @dragstart="handleDragStart"
        @dragend="handleDragEnd"
        @contextmenu.prevent="handleContextMenu"
        @click="handleClick"
    >
        <!-- Thêm dòng này để hiển thị số thứ tự -->
        <span class="rect-order">{{ rect.order }}</span>
        <!-- Có thể giữ lại hoặc bỏ label cũ -->
        <!-- <span class="rect-label">{{ rect.formData?.['Tên'] || rect.schemaId }}</span> -->
    </div>
</template>

<script setup>
// ... (phần script setup không đổi) ...
import { computed } from 'vue';

const props = defineProps({
    rect: { type: Object, required: true },
    preventDrag: { type: Boolean, default: false }
});
const emit = defineEmits(['dragstart', 'dragend', 'contextmenu', 'open-edit']);

const rectStyle = computed(() => ({ /* ... styles ... */ }));
const handleDragStart = (event) => { /* ... */ };
const handleDragEnd = (event) => { /* ... */ };
const handleContextMenu = (event) => { /* ... */ };
const handleClick = (event) => { /* ... */ };
</script>

<style scoped>
.drawn-rect {
    box-sizing: border-box;
    position: absolute; /* Đảm bảo style này có */
    /* ... các style khác từ file gốc ... */
    display: flex;
    align-items: center;
    justify-content: center;
    color: white; /* Hoặc màu khác tương phản với background */
    font-size: 12px; /* Kích thước chữ cho số thứ tự */
    font-weight: bold;
    user-select: none;
    overflow: hidden;
}
.rect-order {
    pointer-events: none; /* Để không cản trở drag */
}
/* Style cũ cho label nếu bạn muốn giữ lại */
/* .rect-label { ... } */
</style>
Giải thích:

Chúng ta thêm một thẻ <span> với class rect-order bên trong div.drawn-rect.
Nội dung của span này là {{ rect.order }} để hiển thị giá trị order được truyền qua prop rect.
CSS được thêm/điều chỉnh để đảm bảo số thứ tự hiển thị rõ ràng ở giữa hình chữ nhật.
Sau khi thực hiện các kiểm tra và sửa đổi này (đặc biệt là Bước 2), số thứ tự sẽ được hiển thị trên các hình chữ nhật mới được thả vào canvas trong giao diện DrawProcess.

Rate this answer: 

Tùng Giang Lâm
hãy sửa file đang mở, cho phép có các mẫu ô nhập liệu tương ứng các kiểu, sau đó có thể kéo các mẫu vào để định nghĩa form nhập liệu động


Gemini
Ok, tôi hiểu. Bạn muốn biến DynamicProcessEditFormModal.vue từ một component hiển thị form dựa trên schema, thành một component xây dựng (builder) form đó một cách động, bằng cách kéo thả các loại ô nhập liệu mẫu.

Đây là một sự thay đổi lớn về chức năng của component này. Nó sẽ không còn hiển thị form để người dùng nhập dữ liệu nữa, mà thay vào đó, nó sẽ cung cấp giao diện để tạo ra cấu trúc (schema) của form đó.

Chiến lược:

Giao diện mới: Chia modal thành 2 phần:
Palette: Chứa các loại trường mẫu (Text, Number, Date, Textarea, Boolean) có thể kéo được.
Canvas/Form Builder Area: Nơi thả các trường từ palette vào, cho phép xem trước cấu trúc form và có thể sắp xếp/xóa các trường.
Trạng thái: Component sẽ quản lý một trạng thái nội bộ đại diện cho schema đang được xây dựng (ví dụ: một mảng các đối tượng field).
Props & Emits:
props: visible (để hiển thị modal), initialSchema (schema hiện có để chỉnh sửa, tùy chọn).
emits: saveSchema (emit ra schema đã xây dựng khi lưu), cancel.
Drag & Drop: Implement cơ chế kéo từ palette và thả vào khu vực xây dựng.
Lưu Schema: Khi nhấn "Lưu", component sẽ emit ra cấu trúc schema đã được xây dựng.
Code được cấu trúc lại cho DynamicProcessEditFormModal.vue:

vue
<template>
    <div v-if="visible" class="modal-overlay" @click.self="handleCancel">
        <div class="modal-content form-builder-modal">
            <h2>Xây dựng Form Nhập liệu Động</h2>

            <div class="form-builder-layout">
                <!-- Palette chứa các loại trường mẫu -->
                <div class="palette">
                    <h4>Kéo loại trường vào form:</h4>
                    <div
                        v-for="fieldType in availableFieldTypes"
                        :key="fieldType.type"
                        class="palette-item"
                        draggable="true"
                        @dragstart="handlePaletteDragStart($event, fieldType.type)"
                    >
                        {{ fieldType.label }}
                    </div>
                </div>

                <!-- Canvas/Khu vực xây dựng form -->
                <div
                    class="form-builder-canvas"
                    @dragover.prevent="handleCanvasDragOver"
                    @drop.prevent="handleCanvasDrop"
                >
                    <h4>Cấu trúc Form:</h4>
                    <div v-if="builtSchemaFields.length === 0" class="canvas-placeholder">
                        Thả các trường vào đây...
                    </div>
                    <!-- Sử dụng vuedraggable để dễ dàng sắp xếp (cần cài đặt) -->
                    <!-- Hoặc dùng div đơn giản trước -->
                     <div v-else>
                        <div
                            v-for="(field, index) in builtSchemaFields"
                            :key="field.id"
                            class="form-field-preview"
                            draggable="true"
                            @dragstart="handleFieldDragStart($event, index)"
                            @dragover.prevent="handleFieldDragOver($event, index)"
                            @drop.prevent="handleFieldDrop($event, index)"
                            @dragend="handleFieldDragEnd"
                            :class="{ 'drag-over': dragOverIndex === index && draggingIndex !== index }"
                        >
                            <span class="drag-handle">⠿</span>
                            <input type="text" v-model="field.key" placeholder="Nhãn trường (Key)" class="field-key-input"/>
                            <span class="field-type-label">({{ field.type }})</span>
                            <!-- Input giá trị mặc định tùy theo type -->
                            <input v-if="field.type === 'text' || field.type === 'email' || field.type === 'url' || field.type === 'date'" :type="field.type" v-model="field.value" placeholder="Giá trị mặc định" class="field-value-input"/>
                            <input v-else-if="field.type === 'number'" type="number" v-model.number="field.value" placeholder="Giá trị mặc định" class="field-value-input"/>
                            <textarea v-else-if="field.type === 'textarea'" v-model="field.value" placeholder="Giá trị mặc định" rows="1" class="field-value-input"></textarea>
                            <input v-else-if="field.type === 'boolean'" type="checkbox" v-model="field.value" class="field-value-input-cb"/>

                            <button @click="removeField(field.id)" class="delete-field-btn" title="Xóa trường">×</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" @click="handleSaveSchema" class="btn btn-save">Lưu Cấu trúc Form</button>
                <button type="button" @click="handleCancel" class="btn btn-cancel">Hủy</button>
            </div>
        </div>
    </div>
</template>

<script setup>
import { ref, watch } from 'vue';

const props = defineProps({
    visible: Boolean,
    // Schema ban đầu để chỉnh sửa, có cấu trúc { key: { value: ..., type: ... } }
    initialSchema: {
        type: Object,
        default: () => ({})
    }
});

const emit = defineEmits(['saveSchema', 'cancel']);

// Các loại trường có sẵn trong palette
const availableFieldTypes = ref([
    { type: 'text', label: 'Chữ (Text)' },
    { type: 'number', label: 'Số (Number)' },
    { type: 'date', label: 'Ngày (Date)' },
    { type: 'textarea', label: 'Văn bản dài (Textarea)' },
    { type: 'boolean', label: 'Đúng/Sai (Checkbox)' },
    { type: 'email', label: 'Email' },
    { type: 'url', label: 'URL' },
]);

// Trạng thái nội bộ: Mảng các đối tượng field đang được xây dựng
// Mỗi field có id, key, type, value (mặc định)
const builtSchemaFields = ref([]);

// Trạng thái cho drag & drop
const draggingFieldType = ref(null); // Loại field đang kéo từ palette
const draggingIndex = ref(null); // Index của field đang kéo trong canvas
const dragOverIndex = ref(null); // Index của field đang bị kéo qua trong canvas

// --- Watchers ---
// Khởi tạo builtSchemaFields khi modal mở hoặc initialSchema thay đổi
watch(() => props.visible, (newVisible) => {
    if (newVisible && props.initialSchema) {
        // Chuyển đổi initialSchema (object) thành mảng để dễ quản lý thứ tự và thêm ID
        const fieldsArray = [];
        let idCounter = Date.now(); // Tạo ID duy nhất đơn giản
        for (const key in props.initialSchema) {
            fieldsArray.push({
                id: idCounter++,
                key: key,
                type: props.initialSchema[key]?.type || 'text',
                value: props.initialSchema[key]?.value ?? getDefaultValue(props.initialSchema[key]?.type || 'text')
            });
        }
        builtSchemaFields.value = fieldsArray;
    } else if (!newVisible) {
        // Reset khi đóng modal
        builtSchemaFields.value = [];
    }
}, { immediate: true });


// --- Drag & Drop Handlers ---

// Kéo từ Palette
const handlePaletteDragStart = (event, fieldType) => {
    draggingFieldType.value = fieldType;
    event.dataTransfer.effectAllowed = 'copy';
    event.dataTransfer.setData('text/plain', fieldType); // Truyền type qua dataTransfer
};

// Kéo qua Canvas
const handleCanvasDragOver = (event) => {
    event.preventDefault(); // Cần thiết để cho phép drop
    event.dataTransfer.dropEffect = 'copy';
};

// Thả vào Canvas (từ Palette)
const handleCanvasDrop = (event) => {
    event.preventDefault();
    const fieldType = draggingFieldType.value || event.dataTransfer.getData('text/plain');
    if (fieldType && availableFieldTypes.value.some(f => f.type === fieldType)) {
        // Tạo field mới và thêm vào cuối mảng
        const newField = {
            id: Date.now(), // ID duy nhất
            key: `Trường mới ${builtSchemaFields.value.length + 1}`, // Key mặc định
            type: fieldType,
            value: getDefaultValue(fieldType) // Giá trị mặc định dựa trên type
        };
        builtSchemaFields.value.push(newField);
    }
    draggingFieldType.value = null; // Reset
};

// Kéo Field bên trong Canvas (để sắp xếp lại)
const handleFieldDragStart = (event, index) => {
    draggingIndex.value = index;
    event.dataTransfer.effectAllowed = 'move';
    // Không cần setData vì chúng ta xử lý dựa trên draggingIndex
};

const handleFieldDragOver = (event, index) => {
    event.preventDefault();
    if (draggingIndex.value !== null && draggingIndex.value !== index) {
        dragOverIndex.value = index; // Đánh dấu vị trí đang kéo qua
        event.dataTransfer.dropEffect = 'move';
    } else {
         dragOverIndex.value = null;
         event.dataTransfer.dropEffect = 'none';
    }
};

const handleFieldDrop = (event, targetIndex) => {
    event.preventDefault();
    if (draggingIndex.value !== null && draggingIndex.value !== targetIndex) {
        // Thực hiện di chuyển phần tử trong mảng
        const itemToMove = builtSchemaFields.value.splice(draggingIndex.value, 1)[0];
        builtSchemaFields.value.splice(targetIndex, 0, itemToMove);
    }
    handleFieldDragEnd(); // Reset trạng thái kéo thả
};

const handleFieldDragEnd = () => {
    draggingIndex.value = null;
    dragOverIndex.value = null;
};


// --- Field Management ---

const removeField = (fieldId) => {
    builtSchemaFields.value = builtSchemaFields.value.filter(field => field.id !== fieldId);
};

// Helper lấy giá trị mặc định
const getDefaultValue = (type) => {
    switch (type) {
        case 'number': return 0;
        case 'boolean': return false;
        case 'date': return ''; // Hoặc new Date().toISOString().slice(0, 10) nếu muốn ngày hiện tại
        default: return '';
    }
};

// --- Modal Actions ---

const handleSaveSchema = () => {
    // Chuyển đổi mảng builtSchemaFields về định dạng object { key: { value: ..., type: ... } }
    const finalSchema = {};
    for (const field of builtSchemaFields.value) {
        if (field.key) { // Chỉ lưu những field có key
            // Cần đảm bảo giá trị đúng kiểu trước khi lưu nếu cần
            let finalValue = field.value;
            if (field.type === 'number' && typeof field.value !== 'number') {
                finalValue = parseFloat(field.value) || 0;
            } else if (field.type === 'boolean' && typeof field.value !== 'boolean') {
                finalValue = Boolean(field.value);
            }
            finalSchema[field.key] = { value: finalValue, type: field.type };
        } else {
            console.warn("Skipping field without a key:", field);
        }
    }
    console.log("Saving built schema:", finalSchema);
    emit('saveSchema', finalSchema); // Emit schema đã xây dựng
};

const handleCancel = () => {
    emit('cancel');
};
</script>

<style scoped>
.modal-overlay { /* Style cũ */ }
.modal-content { /* Style cũ */ }

/* Style mới cho Form Builder */
.form-builder-modal {
    min-width: 600px; /* Rộng hơn để chứa palette và canvas */
    max-width: 80vw;
}

.form-builder-layout {
    display: flex;
    gap: 20px;
    margin-top: 15px;
    margin-bottom: 20px;
    min-height: 300px; /* Chiều cao tối thiểu */
}

.palette {
    width: 200px;
    border: 1px solid #e0e0e0;
    padding: 10px;
    background-color: #f9f9f9;
    border-radius: 4px;
    height: fit-content; /* Chỉ cao bằng nội dung */
}

.palette h4 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 0.9em;
    color: #555;
}

.palette-item {
    background-color: #e7f3ff;
    border: 1px solid #b3d7ff;
    padding: 8px 10px;
    margin-bottom: 8px;
    border-radius: 4px;
    cursor: grab;
    font-size: 0.9rem;
    text-align: center;
}
.palette-item:active {
    cursor: grabbing;
}

.form-builder-canvas {
    flex-grow: 1;
    border: 2px dashed #ccc;
    padding: 15px;
    border-radius: 4px;
    background-color: #fff;
    min-height: 300px; /* Đảm bảo có không gian để thả */
    position: relative; /* Cho placeholder */
}

.form-builder-canvas h4 {
     margin-top: 0;
     margin-bottom: 15px;
     font-size: 0.9em;
     color: #555;
}

.canvas-placeholder {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #aaa;
    font-style: italic;
}

.form-field-preview {
    background-color: #f0f0f0;
    border: 1px solid #dcdcdc;
    padding: 8px 10px;
    margin-bottom: 10px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: move; /* Cursor cho việc kéo thả sắp xếp */
}

.drag-handle {
    cursor: grab;
    color: #aaa;
    padding-right: 5px;
}
.form-field-preview:active .drag-handle {
    cursor: grabbing;
}


.field-key-input {
    flex-grow: 1; /* Cho phép input key co giãn */
    padding: 4px 6px;
    border: 1px solid #ccc;
    border-radius: 3px;
    font-size: 0.9rem;
}

.field-type-label {
    font-size: 0.8em;
    color: #777;
    white-space: nowrap;
}

.field-value-input, .field-value-input-cb {
    padding: 4px 6px;
    border: 1px solid #ccc;
    border-radius: 3px;
    font-size: 0.9rem;
    max-width: 150px; /* Giới hạn chiều rộng ô giá trị mặc định */
}
.field-value-input-cb {
     max-width: none; /* Checkbox không cần giới hạn */
     width: auto;
}


.delete-field-btn {
    background: none;
    border: none;
    color: #dc3545;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0 5px;
    line-height: 1;
}
.delete-field-btn:hover {
    color: #a71d2a;
}

/* Style khi kéo qua một field khác */
.form-field-preview.drag-over {
    border-top: 2px solid blue; /* Hoặc hiệu ứng khác */
    /* background-color: #e0e0ff; */
}


.modal-actions { /* Style cũ */ }
.btn { /* Style cũ */ }
.btn-save { /* Style cũ */ }
.btn-cancel { /* Style cũ */ }
</style>
Giải thích các thay đổi chính:

Template:
Chia thành .palette và .form-builder-canvas.
Palette dùng v-for để hiển thị availableFieldTypes, mỗi item có draggable="true" và @dragstart.
Canvas là drop target (@dragover, @drop).
Canvas hiển thị builtSchemaFields bằng v-for. Mỗi field có:
Tay nắm kéo (drag handle ⠿).
Input để sửa field.key.
Hiển thị field.type.
Input/Textarea/Checkbox để nhập field.value (giá trị mặc định).
Nút xóa (×).
Các thuộc tính draggable và sự kiện drag/drop (@dragstart, @dragover, @drop, @dragend) được thêm vào để cho phép sắp xếp lại.
Script:
Props: Đổi schema thành initialSchema. Bỏ rectData.
Emits: Đổi save thành saveSchema.
State:
availableFieldTypes: Định nghĩa các loại trường cho palette.
builtSchemaFields: Mảng ref lưu trữ các field đang xây dựng ({ id, key, type, value }).
draggingFieldType, draggingIndex, dragOverIndex: Quản lý trạng thái kéo thả.
Watcher: Khởi tạo builtSchemaFields từ initialSchema khi modal hiển thị. Chuyển đổi từ cấu trúc object sang mảng và thêm id.
Drag & Drop Handlers:
handlePaletteDragStart: Lưu type đang kéo từ palette.
handleCanvasDragOver: Cho phép drop.
handleCanvasDrop: Tạo field mới từ draggingFieldType và thêm vào builtSchemaFields.
handleFieldDragStart, handleFieldDragOver, handleFieldDrop, handleFieldDragEnd: Xử lý logic kéo thả để sắp xếp lại các field trong builtSchemaFields.
removeField: Lọc bỏ field khỏi mảng builtSchemaFields dựa trên id.
getDefaultValue: Helper để lấy giá trị mặc định phù hợp cho từng loại field.
handleSaveSchema: Chuyển đổi mảng builtSchemaFields trở lại định dạng object { key: { value: ..., type: ... } } và emit sự kiện saveSchema.
handleCancel: Emit cancel.
CSS: Thêm style cho layout mới (palette, canvas), các item kéo thả, các field xem trước, và hiệu ứng kéo qua (drag-over).
Lưu ý quan trọng:

Sắp xếp: Code hiện tại đã thêm logic cơ bản để sắp xếp lại các trường bằng HTML5 Drag and Drop. Bạn có thể thay thế bằng thư viện như vuedraggable để có trải nghiệm kéo thả mượt mà và mạnh mẽ hơn nếu cần.
Component Cha: Component cha (DrawProcessCanvas.vue) giờ đây cần lắng nghe sự kiện @saveSchema thay vì @save. Dữ liệu nhận được sẽ là cấu trúc schema mới. Bạn cần quyết định cách lưu trữ schema này (có thể gắn nó vào rect.formData hoặc một thuộc tính riêng như rect.formSchemaDefinition). Logic handleDrop và saveForm trong DrawProcessCanvas sẽ cần điều chỉnh để làm việc với schema động này.
Hiển thị Form: Bạn sẽ cần một component khác (hoặc phiên bản khác của modal này) để thực sự hiển thị form cho người dùng nhập liệu dựa trên schema đã được xây dựng bằng builder này.
Rate this answer: 

Tùng Giang Lâm
hãy viết lại full file bạn vừa tạo


Gemini
Chắc chắn rồi, đây là nội dung đầy đủ của file component Vue (DynamicProcessEditFormModal.vue hoặc tên tương tự bạn đặt) dùng để xây dựng cấu trúc form động bằng cách kéo thả, dựa trên code chúng ta đã thảo luận:

vue
<template>
    <div v-if="visible" class="modal-overlay" @click.self="handleCancel">
        <div class="modal-content form-builder-modal">
            <h2>Xây dựng Form Nhập liệu Động</h2>

            <div class="form-builder-layout">
                <!-- Palette chứa các loại trường mẫu -->
                <div class="palette">
                    <h4>Kéo loại trường vào form:</h4>
                    <div
                        v-for="fieldType in availableFieldTypes"
                        :key="fieldType.type"
                        class="palette-item"
                        draggable="true"
                        @dragstart="handlePaletteDragStart($event, fieldType.type)"
                    >
                        {{ fieldType.label }}
                    </div>
                </div>

                <!-- Canvas/Khu vực xây dựng form -->
                <div
                    class="form-builder-canvas"
                    @dragover.prevent="handleCanvasDragOver"
                    @drop.prevent="handleCanvasDrop"
                >
                    <h4>Cấu trúc Form:</h4>
                    <div v-if="builtSchemaFields.length === 0" class="canvas-placeholder">
                        Thả các trường vào đây...
                    </div>
                    <!-- Sử dụng div đơn giản cho kéo thả sắp xếp -->
                    <div v-else>
                        <div
                            v-for="(field, index) in builtSchemaFields"
                            :key="field.id"
                            class="form-field-preview"
                            draggable="true"
                            @dragstart="handleFieldDragStart($event, index)"
                            @dragover.prevent="handleFieldDragOver($event, index)"
                            @drop.prevent="handleFieldDrop($event, index)"
                            @dragend="handleFieldDragEnd"
                            :class="{ 'drag-over': dragOverIndex === index && draggingIndex !== index }"
                        >
                            <span class="drag-handle" title="Kéo để sắp xếp">⠿</span>
                            <input type="text" v-model="field.key" placeholder="Nhãn trường (Key)" class="field-key-input"/>
                            <span class="field-type-label">({{ field.type }})</span>
                            <!-- Input giá trị mặc định tùy theo type -->
                            <input v-if="field.type === 'text' || field.type === 'email' || field.type === 'url' || field.type === 'date'" :type="field.type" v-model="field.value" placeholder="Giá trị mặc định" class="field-value-input"/>
                            <input v-else-if="field.type === 'number'" type="number" v-model.number="field.value" placeholder="Giá trị mặc định" class="field-value-input"/>
                            <textarea v-else-if="field.type === 'textarea'" v-model="field.value" placeholder="Giá trị mặc định" rows="1" class="field-value-input"></textarea>
                            <input v-else-if="field.type === 'boolean'" type="checkbox" v-model="field.value" class="field-value-input-cb"/>

                            <button @click="removeField(field.id)" class="delete-field-btn" title="Xóa trường">×</button>
                        </div>
                    </div>
                     <!-- Cân nhắc dùng thư viện như vuedraggable nếu cần kéo thả phức tạp hơn -->
                     <!-- <draggable v-model="builtSchemaFields" item-key="id" @end="onDragEnd" class="drag-area" ghost-class="ghost">
                        <template #item="{element, index}">
                             <div class="form-field-preview"> ... nội dung field ... </div>
                        </template>
                     </draggable> -->
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" @click="handleSaveSchema" class="btn btn-save">Lưu Cấu trúc Form</button>
                <button type="button" @click="handleCancel" class="btn btn-cancel">Hủy</button>
            </div>
        </div>
    </div>
</template>

<script setup>
import { ref, watch } from 'vue';
// Nếu dùng vuedraggable, import nó ở đây:
// import draggable from 'vuedraggable';

const props = defineProps({
    visible: Boolean,
    // Schema ban đầu để chỉnh sửa, có cấu trúc { key: { value: ..., type: ... } }
    initialSchema: {
        type: Object,
        default: () => ({})
    }
});

const emit = defineEmits(['saveSchema', 'cancel']);

// Các loại trường có sẵn trong palette
const availableFieldTypes = ref([
    { type: 'text', label: 'Chữ (Text)' },
    { type: 'number', label: 'Số (Number)' },
    { type: 'date', label: 'Ngày (Date)' },
    { type: 'textarea', label: 'Văn bản dài (Textarea)' },
    { type: 'boolean', label: 'Đúng/Sai (Checkbox)' },
    { type: 'email', label: 'Email' },
    { type: 'url', label: 'URL' },
]);

// Trạng thái nội bộ: Mảng các đối tượng field đang được xây dựng
// Mỗi field có id, key, type, value (mặc định)
const builtSchemaFields = ref([]);

// Trạng thái cho drag & drop (HTML5)
const draggingFieldType = ref(null); // Loại field đang kéo từ palette
const draggingIndex = ref(null); // Index của field đang kéo trong canvas
const dragOverIndex = ref(null); // Index của field đang bị kéo qua trong canvas

// --- Watchers ---
// Khởi tạo builtSchemaFields khi modal mở hoặc initialSchema thay đổi
watch(() => props.visible, (newVisible) => {
    if (newVisible && props.initialSchema) {
        const fieldsArray = [];
        let idCounter = Date.now();
        for (const key in props.initialSchema) {
            // Đảm bảo initialSchema[key] tồn tại trước khi truy cập thuộc tính
            const schemaField = props.initialSchema[key];
            const fieldType = schemaField?.type || 'text';
            fieldsArray.push({
                id: idCounter++,
                key: key,
                type: fieldType,
                value: schemaField?.value ?? getDefaultValue(fieldType)
            });
        }
        builtSchemaFields.value = fieldsArray;
        console.log("Form builder initialized with:", builtSchemaFields.value);
    } else if (!newVisible) {
        // Reset khi đóng modal để tránh giữ lại trạng thái cũ
        builtSchemaFields.value = [];
        draggingFieldType.value = null;
        draggingIndex.value = null;
        dragOverIndex.value = null;
        console.log("Form builder closed and reset.");
    }
}, { immediate: true }); // Chạy ngay khi component mount/prop thay đổi lần đầu


// --- Drag & Drop Handlers (HTML5) ---

// Kéo từ Palette
const handlePaletteDragStart = (event, fieldType) => {
    try {
        draggingFieldType.value = fieldType;
        event.dataTransfer.effectAllowed = 'copy';
        event.dataTransfer.setData('text/plain', fieldType);
        console.log(`Dragging from palette: ${fieldType}`);
    } catch (e) {
        console.error("Error setting drag data:", e);
    }
};

// Kéo qua Canvas
const handleCanvasDragOver = (event) => {
    event.preventDefault();
    // Xác định hiệu ứng dựa trên nguồn kéo
    if (draggingFieldType.value) {
        event.dataTransfer.dropEffect = 'copy'; // Kéo từ palette
    } else if (draggingIndex.value !== null) {
        event.dataTransfer.dropEffect = 'move'; // Kéo trong canvas
    } else {
        event.dataTransfer.dropEffect = 'none';
    }
};

// Thả vào Canvas (từ Palette)
const handleCanvasDrop = (event) => {
    event.preventDefault();
    // Ưu tiên lấy từ state nếu kéo từ palette, nếu không thử lấy từ dataTransfer
    const fieldType = draggingFieldType.value || event.dataTransfer.getData('text/plain');
    console.log(`Dropped on canvas. Type detected: ${fieldType}`);

    if (fieldType && availableFieldTypes.value.some(f => f.type === fieldType)) {
        const newField = {
            id: Date.now() + Math.random(), // Thêm random để tăng tính duy nhất
            key: `Trường mới ${builtSchemaFields.value.length + 1}`,
            type: fieldType,
            value: getDefaultValue(fieldType)
        };
        builtSchemaFields.value.push(newField);
        console.log("Added new field:", newField);
    } else {
        console.warn("Invalid or no field type dropped.");
    }
    // Reset trạng thái kéo từ palette
    draggingFieldType.value = null;
    // Reset cả trạng thái kéo nội bộ (phòng trường hợp lỗi)
    handleFieldDragEnd();
};

// Kéo Field bên trong Canvas (để sắp xếp lại)
const handleFieldDragStart = (event, index) => {
    draggingIndex.value = index;
    event.dataTransfer.effectAllowed = 'move';
    // Thêm class tạm thời để làm mờ item đang kéo (tùy chọn)
    event.target.classList.add('dragging-field');
    console.log(`Start dragging field at index: ${index}`);
};

const handleFieldDragOver = (event, index) => {
    event.preventDefault();
    // Chỉ xử lý khi đang kéo một field khác
    if (draggingIndex.value !== null && draggingIndex.value !== index) {
        dragOverIndex.value = index;
        event.dataTransfer.dropEffect = 'move';
    } else {
         // Nếu kéo qua chính nó hoặc không kéo field nào, không làm gì
         dragOverIndex.value = null;
         event.dataTransfer.dropEffect = 'none';
    }
};

const handleFieldDrop = (event, targetIndex) => {
    event.preventDefault();
    console.log(`Drop field onto index: ${targetIndex}. Dragging index: ${draggingIndex.value}`);
    if (draggingIndex.value !== null && draggingIndex.value !== targetIndex) {
        // Di chuyển phần tử
        const itemToMove = builtSchemaFields.value[draggingIndex.value];
        builtSchemaFields.value.splice(draggingIndex.value, 1); // Xóa khỏi vị trí cũ
        // Chèn vào vị trí mới
        builtSchemaFields.value.splice(targetIndex, 0, itemToMove);
        console.log("Moved field. New order:", builtSchemaFields.value.map(f => f.key));
    }
    // Reset trạng thái sau khi thả
    handleFieldDragEnd();
};

const handleFieldDragEnd = (event) => {
    // Xóa class tạm thời (nếu có)
    if (event?.target) {
        event.target.classList.remove('dragging-field');
    }
    // Reset các biến trạng thái kéo thả nội bộ
    draggingIndex.value = null;
    dragOverIndex.value = null;
    console.log("Drag field end.");
};


// --- Field Management ---

const removeField = (fieldId) => {
    const indexToRemove = builtSchemaFields.value.findIndex(field => field.id === fieldId);
    if (indexToRemove > -1) {
        builtSchemaFields.value.splice(indexToRemove, 1);
        console.log(`Removed field with id: ${fieldId}`);
    }
};

// Helper lấy giá trị mặc định
const getDefaultValue = (type) => {
    switch (type) {
        case 'number': return 0;
        case 'boolean': return false;
        case 'date': return ''; // Hoặc null nếu muốn
        default: return '';
    }
};

// --- Modal Actions ---

const handleSaveSchema = () => {
    const finalSchema = {};
    let hasError = false;
    const seenKeys = new Set();

    for (const field of builtSchemaFields.value) {
        const key = field.key?.trim(); // Trim whitespace
        if (key) {
            if (seenKeys.has(key)) {
                alert(`Lỗi: Nhãn trường (Key) "${key}" bị trùng lặp. Vui lòng sửa lại.`);
                hasError = true;
                break; // Dừng lại khi gặp lỗi đầu tiên
            }
            seenKeys.add(key);

            let finalValue = field.value;
            // Chuyển đổi kiểu dữ liệu chặt chẽ hơn khi lưu
            try {
                if (field.type === 'number') {
                    finalValue = field.value === '' || field.value === null ? null : parseFloat(field.value); // Cho phép null hoặc số
                    if (field.value !== '' && field.value !== null && isNaN(finalValue)) finalValue = 0; // Default về 0 nếu parse lỗi
                } else if (field.type === 'boolean') {
                    finalValue = Boolean(field.value);
                }
                // Các kiểu khác giữ nguyên (text, date, textarea, email, url)
            } catch (e) {
                 console.error(`Error converting value for key "${key}":`, e);
                 // Có thể đặt giá trị mặc định hoặc báo lỗi tùy logic
                 finalValue = getDefaultValue(field.type);
            }

            finalSchema[key] = { value: finalValue, type: field.type };
        } else {
            console.warn("Skipping field without a key:", field);
            // Có thể thêm cảnh báo cho người dùng nếu muốn
            // alert("Cảnh báo: Có một trường chưa được đặt Nhãn (Key) và sẽ bị bỏ qua khi lưu.");
        }
    }

    if (!hasError) {
        console.log("Saving built schema:", finalSchema);
        emit('saveSchema', finalSchema);
    }
};

const handleCancel = () => {
    emit('cancel');
};
</script>

<style scoped>
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.6); display: flex;
    justify-content: center; align-items: center; z-index: 1000;
}
.modal-content {
    background-color: #fff; padding: 25px; border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

/* Style mới cho Form Builder */
.form-builder-modal {
    min-width: 650px; /* Tăng chiều rộng */
    max-width: 90vw;
}

h2 {
    margin-top: 0; margin-bottom: 20px; color: #333; text-align: center;
}

.form-builder-layout {
    display: flex; gap: 20px; margin-top: 15px; margin-bottom: 20px;
    min-height: 350px; /* Tăng chiều cao */
}

.palette {
    width: 220px; /* Rộng hơn chút */
    border: 1px solid #e0e0e0; padding: 15px; background-color: #f9f9f9;
    border-radius: 4px; height: fit-content; flex-shrink: 0; /* Không co lại */
}

.palette h4 {
    margin-top: 0; margin-bottom: 10px; font-size: 0.95em; color: #444;
}

.palette-item {
    background-color: #e7f3ff; border: 1px solid #b3d7ff; padding: 8px 12px;
    margin-bottom: 8px; border-radius: 4px; cursor: grab; font-size: 0.9rem;
    text-align: center; transition: background-color 0.2s ease;
}
.palette-item:hover {
    background-color: #d0e8ff;
}
.palette-item:active {
    cursor: grabbing; background-color: #b3d7ff;
}

.form-builder-canvas {
    flex-grow: 1; border: 2px dashed #ccc; padding: 20px; border-radius: 4px;
    background-color: #fff; min-height: 350px; position: relative;
    overflow-y: auto; /* Cho phép cuộn nếu nhiều field */
}

.form-builder-canvas h4 {
     margin-top: 0; margin-bottom: 15px; font-size: 0.95em; color: #444;
}

.canvas-placeholder {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    color: #aaa; font-style: italic; text-align: center;
}

.form-field-preview {
    background-color: #f8f9fa; border: 1px solid #dee2e6; padding: 10px 12px;
    margin-bottom: 10px; border-radius: 4px; display: flex; align-items: center;
    gap: 10px; cursor: move; transition: background-color 0.1s ease;
}
/* Style khi đang kéo field này */
.form-field-preview.dragging-field {
    opacity: 0.5;
    background-color: #e9ecef;
}


.drag-handle {
    cursor: grab; color: #adb5bd; padding-right: 5px; font-size: 1.2em;
}
.form-field-preview:active .drag-handle {
    cursor: grabbing;
}

.field-key-input {
    flex-grow: 1; padding: 5px 8px; border: 1px solid #ced4da;
    border-radius: 3px; font-size: 0.9rem; min-width: 100px; /* Đảm bảo có độ rộng tối thiểu */
}

.field-type-label {
    font-size: 0.8em; color: #6c757d; white-space: nowrap;
}

.field-value-input, .field-value-input-cb {
    padding: 5px 8px; border: 1px solid #ced4da; border-radius: 3px;
    font-size: 0.9rem; max-width: 180px; /* Tăng giới hạn */
}
.field-value-input-cb {
     max-width: none; width: auto; margin-left: 5px;
}
textarea.field-value-input {
    max-width: 180px; /* Giữ giới hạn cho textarea */
    resize: none; /* Không cho resize */
    line-height: 1.3;
    height: 2.2em; /* Chiều cao tương đương 1 dòng input */
}

.delete-field-btn {
    background: none; border: none; color: #dc3545; font-size: 1.4rem;
    cursor: pointer; padding: 0 5px; line-height: 1; margin-left: auto; /* Đẩy nút xóa sang phải */
}
.delete-field-btn:hover {
    color: #a71d2a;
}

/* Style khi kéo qua một field khác */
.form-field-preview.drag-over {
    /* Thêm đường viền rõ hơn ở trên */
    border-top: 3px solid #0d6efd;
    margin-top: -2px; /* Bù lại chiều cao border */
}

.modal-actions {
    margin-top: 25px; text-align: right; padding-top: 15px;
    border-top: 1px solid #eee;
}
.btn {
    padding: 10px 18px; border: none; border-radius: 4px; cursor: pointer;
    font-size: 1rem; margin-left: 10px; transition: background-color 0.2s ease;
}
.btn-save { background-color: #198754; color: white; } /* Màu xanh lá */
.btn-save:hover { background-color: #157347; }
.btn-cancel { background-color: #6c757d; color: white; }
.btn-cancel:hover { background-color: #5a6268; }
</style>
Use code with care. Learn more
Rate this answer: 
External Sources (1)

Tùng Giang Lâm
câu emit có nghĩa gì và có tác dụng gì

DynamicProcessEditFormModal.vue: 1 lines selected

Gemini
Câu lệnh emit('saveSchema', finalSchema); trong component Vue (sử dụng <script setup>) có ý nghĩa và tác dụng như sau:

Ý nghĩa:

emit: Đây là một hàm được cung cấp bởi Vue (thông qua defineEmits) cho phép component con phát ra (emit) một sự kiện tùy chỉnh lên component cha của nó.
'saveSchema': Đây là tên của sự kiện tùy chỉnh đang được phát ra. Tên này do bạn tự định nghĩa và component cha sẽ lắng nghe sự kiện có tên chính xác là 'saveSchema'.
finalSchema: Đây là dữ liệu (payload) được gửi kèm theo sự kiện. Bất kỳ dữ liệu nào bạn đặt ở vị trí thứ hai (hoặc các vị trí tiếp theo) của hàm emit sẽ được truyền lên cho hàm xử lý sự kiện ở component cha. Trong trường hợp này, đó là đối tượng finalSchema chứa cấu trúc form mà người dùng vừa xây dựng.
Tác dụng (Trong ngữ cảnh của file này):

Thông báo cho Component Cha: Khi người dùng nhấn nút "Lưu Cấu trúc Form" và hàm handleSaveSchema được thực thi, câu lệnh emit('saveSchema', ...) sẽ thông báo cho component cha (component đã sử dụng <DynamicProcessEditFormModal>) rằng người dùng đã hoàn tất việc xây dựng/chỉnh sửa schema và muốn lưu kết quả.
Truyền Dữ liệu Lên: Quan trọng hơn, nó không chỉ thông báo mà còn gửi dữ liệu finalSchema (cấu trúc form đã được xây dựng) lên component cha.
Cho phép Component Cha Xử lý: Component cha, sau khi nhận được sự kiện saveSchema và dữ liệu finalSchema, có thể thực hiện các hành động cần thiết, ví dụ:
Lưu cấu trúc finalSchema này vào dữ liệu của hình chữ nhật tương ứng (ví dụ: drawnRectangles.value[index].formSchemaDefinition = finalSchema).
Đóng modal.
Thực hiện các cập nhật giao diện khác nếu cần.
Tóm lại: emit('saveSchema', finalSchema); là cơ chế chuẩn của Vue để component con (DynamicProcessEditFormModal) giao tiếp ngược lên component cha, báo hiệu một hành động đã hoàn thành (lưu schema) và truyền dữ liệu kết quả (chính cái schema đó) lên để cha xử lý.

Rate this answer: 

Tùng Giang Lâm
làm sao để component cha hứng sự kiện và dữ liệu trả về, bạn hãy sửa trang cha để log các dữ liệu này

DynamicProcessEditFormModal.vue: 1 lines selected

Gemini
Ok, tôi hiểu. Bạn muốn component cha (trong trường hợp này là DrawProcessCanvas.vue) nhận được sự kiện saveSchema và dữ liệu finalSchema từ component con DynamicProcessEditFormModal.vue (tên file mới, thay thế cho DrawProcessEditFormModal.vue). Sau đó, bạn muốn log dữ liệu này ra console để kiểm tra.

Các bước thực hiện:

Thay đổi Import: Trong DrawProcessCanvas.vue, thay đổi import của component modal.
Lắng nghe sự kiện saveSchema: Thêm một event listener (@saveSchema) vào component <DynamicProcessEditFormModal> trong template của DrawProcessCanvas.vue.
Xử lý sự kiện: Tạo một hàm (ví dụ: handleSchemaSaved) trong DrawProcessCanvas.vue để xử lý sự kiện saveSchema và log dữ liệu ra console.
Lưu và sử dụng schema: Trong hàm handleSchemaSaved (và sau này là handleDrop), bạn cần quyết định cách sử dụng finalSchema (do modal trả về). Có thể lưu nó vào rect.formSchemaDefinition để phân biệt với rect.formData (dữ liệu người dùng nhập).
Đổi tên component Đổi tên component DrawProcessEditFormModal.vue thành DynamicProcessEditFormModal.vue Mã cập nhật cho src/components/DrawProcess/DrawProcessCanvas.vue:
vue
<template>
    <!-- ... (phần template cũ không thay đổi nhiều) ... -->
    <div v-else class="draw-process-app-container">
        <div class="draw-process-app">
            <!-- Palette -->
            <div class="palette">
                <!-- ... -->
            </div>

            <!-- Canvas -->
            <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
                <!-- ... -->
            </div>
        </div>

        <!-- Component Save/Load Controls -->
        <DrawProcessSaveLoadControls
            :current-rectangles="drawnRectangles"
            @state-loaded="onStateLoaded"
            class="controls-container"
        />

        <!-- Component Dynamic Process EditFormModal (đã thay thế) -->
        <DynamicProcessEditFormModal <!-- SỬA TÊN COMPONENT -->
            :visible="isModalVisible"
            :initial-schema="getInitialSchema(editingRect)" <!-- Truyền schema hiện có nếu có -->
            @saveSchema="handleSchemaSaved" <!-- Thêm listener cho sự kiện saveSchema -->
            @cancel="cancelForm"
        />

        <!-- Modal (nằm ngoài .drawing-app để không bị ảnh hưởng bởi flex) -->
        <DrawProcessContextMenu :visible="contextMenu.visible" :top="contextMenu.top" :left="contextMenu.left" @edit="handleEdit"
            @delete="handleDelete" ref="contextMenuRef" />
    </div>
</template>

<script setup>
/* eslint-disable */
// ... (các imports cũ) ...
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { debounce } from 'lodash-es';
import DrawProcessRectangle from './DrawProcessRectangle.vue';
import DrawProcessContextMenu from './DrawProcessContextMenu.vue';
//import DrawProcessEditFormModal from './DrawProcessEditFormModal.vue'; // Xóa import này
import DynamicProcessEditFormModal from './DynamicProcessEditFormModal.vue'; // Thêm import này
import DrawProcessSaveLoadControls from './DrawProcessSaveLoadControls.vue';
import { paletteItems, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawProcessSchemas.js';
import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';

// ... (các state, computed, helpers, event handlers cũ) ...
const isLoading = ref(true);
const loadError = ref(false);
const isSchemaLoading = ref(false);
const drawnRectangles = ref([]);
const canvasRef = ref(null);
const defaultRectWidth = 50;
const defaultRectHeight = 50;
const draggingRectId = ref(null);
const currentOrder = ref(1);
const contextMenuRef = ref(null);
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null });
const isModalVisible = ref(false);
const editingRect = ref(null);

const sortedRectangles = computed(() => { /* ... */ });
const getCachedSchemaForRect = (rect) => { /* ... */ };
const calculateElbowPoints = (rectA, rectB) => { /* ... */ };
const handleWindowChange = debounce(() => { /* ... */ }, 150);
onMounted(async () => { /* ... */ });
onUnmounted(() => { /* ... */ });
const onStateLoaded = (loadedRectangles) => { /* ... */ };
const handleClickOutside = (event) => { /* ... */ };
const showContextMenu = (event, rect) => { /* ... */ };
const closeContextMenu = () => { /* ... */ };
const handleEdit = () => { /* ... */ };
const handleDelete = () => { /* ... */ };

// --- CẬP NHẬT openEditModal, thêm hàm getInitialSchema ---
const getInitialSchema = (rect) => {
    // Trả về formSchemaDefinition nếu có, hoặc {} nếu không có
    return rect?.formSchemaDefinition || {};
};

const openEditModal = (rect) => {
    if (!rect || draggingRectId.value !== null) return;
    closeContextMenu();
    // Không cần clone formData nữa, mà chỉ cần gán lại rect
    editingRect.value = rect;
    isModalVisible.value = true;
};

const saveForm = (updatedFormData) => {
     if (!editingRect.value) return;
    // Cập nhật formData
    const originalRectIndex = drawnRectangles.value.findIndex(r => r.id === editingRect.value.id);
    if (originalRectIndex > -1) {
        try {
            drawnRectangles.value[originalRectIndex].formData = structuredClone(updatedFormData);
        } catch (e) {
            drawnRectangles.value[originalRectIndex].formData = JSON.parse(JSON.stringify(updatedFormData));
        }
    }
    cancelForm();
};

const cancelForm = () => {
    isModalVisible.value = false;
    editingRect.value = null;
};

// --- Xử lý Sự kiện từ DynamicProcessEditFormModal ---
const handleSchemaSaved = (newSchema) => {
    // newSchema: Dữ liệu trả về từ DynamicProcessEditFormModal
    console.log('[DrawProcess] New schema saved:', newSchema);

    // 1. Lưu schema vào rect.formSchemaDefinition (phân biệt với formData)
    if (editingRect.value) {
         editingRect.value.formSchemaDefinition = newSchema;
    }

    // 2. Đóng modal
    cancelForm(); // Dùng hàm cancelForm để đóng modal
};

const handleSourceDragStart = (event, item) => { /* ... */ };
const handleRectDragStart = (event, rect) => { /* ... */ };
const handleRectDragEnd = (event) => { /* ... */ };
const handleDragOver = (event) => { /* ... */ };
const handleDrop = async (event) => { /* ... */ };
</script>

<style scoped>
/* ... (CSS cũ, bạn có thể đổi class nếu cần) ... */
.draw-process-app-container { /* ... */ }
.draw-process-app { /* ... */ }
.controls-container { /* ... */ }
.schema-loading-overlay { /* ... */ }
.loading-indicator, .error-message { /* ... */ }
.palette { /* ... */ }
.source-rect { /* ... */ }
.canvas { /* ... */ }
.connection-lines { /* ... */ }
</style>
Giải thích các thay đổi:

Import:
Thay đổi import: Thay DrawProcessEditFormModal bằng DynamicProcessEditFormModal
Bỏ import: bỏ import DrawProcessEditFormModal
Thêm Import: thêm import DynamicProcessEditFormModal
Template:
Thay đổi thẻ: Thay thế thẻ <DrawProcessEditFormModal> bằng <DynamicProcessEditFormModal>.
Thêm @saveSchema: Thêm @saveSchema="handleSchemaSaved" vào thẻ <DynamicProcessEditFormModal> để lắng nghe sự kiện.
Truyền initial-schema thêm :initial-schema="getInitialSchema(editingRect)" để gửi đi cấu trúc nếu có.
Script:
Hàm getInitialSchema: Hàm mới được tạo để lấy formSchemaDefinition của editingRect (nếu có) hoặc trả về object rỗng nếu không có.
Hàm handleSchemaSaved: Hàm mới này được gọi khi DynamicProcessEditFormModal emit sự kiện saveSchema.
Log dữ liệu: Dòng console.log('[DrawProcess] New schema saved:', newSchema); sẽ log dữ liệu ra console để bạn kiểm tra.
Lưu vào formSchemaDefinition: editingRect.value.formSchemaDefinition = newSchema; để lưu vào ô tương ứng.
Đóng modal: cancelForm() được gọi để đóng modal.
Cập nhật openEditModal: Không cần clone formData nữa.
Cập nhật saveForm: giữ nguyên logic
Cập nhật cancelForm: giữ nguyên logic
Các bước tiếp theo:

Đổi tên file DrawProcessEditFormModal.vue thành DynamicProcessEditFormModal.vue
Cập nhật handleDrop Khi tạo mới hình chữ nhật, bạn nên thêm một đối tượng {} rỗng cho thuộc tính formSchemaDefinition để có thể mở modal dù chưa định nghĩa schema.
Hiển thị và sử dụng schema đã tạo: Ở thời điểm hiện tại, bạn chỉ mới tạo ra cơ chế để xây dựng schema. Bạn cần thêm một component khác (hoặc sửa đổi DrawProcessEditFormModal.vue) để hiển thị và cho phép người dùng nhập dữ liệu dựa trên schema đã xây dựng (sẽ dùng formSchemaDefinition để biết phải tạo ô nhập liệu nào).
Thêm cấu trúc dữ liệu Thêm formSchemaDefinition : {} trong newRect trong handleDrop
Kiểm tra: Chạy lại ứng dụng và:
Mở modal "chỉnh sửa" cho một hình chữ nhật.
Xây dựng schema bằng cách kéo thả các field vào.
Nhấn "Lưu Cấu trúc Form".
Kiểm tra console để xem dữ liệu finalSchema đã được log ra chưa.
Sau khi các bước trên được thực hiện, bạn đã có thể lưu và quản lý schema động cho từng hình chữ nhật. Hãy cho tôi biết nếu bạn gặp vấn đề gì trong quá trình thực hiện.

Rate this answer: 

Tùng Giang Lâm
hãy viết full file DynamicProcessCanvas


Gemini
Chắc chắn rồi. Dựa trên các bước đã thảo luận và tích hợp component DynamicProcessEditFormModal để xây dựng schema, đây là nội dung đầy đủ cho file src/components/DynamicProcess/DynamicProcessCanvas.vue:

vue
<template>
    <div v-if="isLoading" class="loading-indicator">
        Đang tải dữ liệu quy trình...
    </div>
    <div v-else-if="loadError" class="error-message">
        Lỗi tải dữ liệu quy trình. Vui lòng thử lại.
    </div>

    <div v-else class="draw-process-app-container">
        <div class="draw-process-app">
            <!-- Palette -->
            <div class="palette">
                <h3>Kéo mẫu quy trình:</h3>
                <div v-for="item in paletteItems" :key="item.schemaId" class="source-rect"
                    :style="{ backgroundColor: item.color }" draggable="true"
                    @dragstart="handleSourceDragStart($event, item)"></div>
            </div>

            <!-- Canvas -->
            <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
                <h3>Thả vào đây để vẽ quy trình:</h3>

                <!-- SVG Layer -->
                <svg class="connection-lines">
                    <defs>
                        <marker id="proc-arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3"
                            orient="auto-start-reverse" markerUnits="strokeWidth">
                            <path d="M0,0 L8,3 L0,6 Z" fill="#555" />
                        </marker>
                    </defs>
                    <g>
                        <template v-for="(rect, index) in sortedRectangles" :key="rect.id + '-proc-elbow'">
                            <template v-if="index < sortedRectangles.length - 1">
                                <polyline :points="calculateElbowPoints(rect, sortedRectangles[index + 1])" fill="none"
                                    stroke="#555" stroke-width="1.5" stroke-dasharray="4, 4" marker-end="url(#proc-arrowhead)" />
                            </template>
                        </template>
                    </g>
                </svg>

                <!-- Component Rectangle -->
                <DrawProcessRectangle v-for="rect in drawnRectangles" :key="rect.id" :rect="rect" :prevent-drag="isModalVisible"
                    @dragstart.stop="handleRectDragStart($event, rect)" @dragend="handleRectDragEnd"
                    @contextmenu="showContextMenu($event, rect)"
                    @open-edit="openSchemaBuilderModal" <!-- Thay đổi sự kiện để mở schema builder -->
                 />

                <!-- Loading Overlay -->
                <div v-if="isSchemaLoading" class="schema-loading-overlay">
                    Đang tải cấu hình...
                </div>
            </div>
        </div>

        <!-- Component Save/Load Controls -->
        <DrawProcessSaveLoadControls
            :current-rectangles="drawnRectangles"
            @state-loaded="onStateLoaded"
            class="controls-container"
        />

        <!-- Modal Builder Schema -->
        <DynamicProcessEditFormModal
            :visible="isSchemaBuilderVisible" <!-- Sử dụng state riêng cho modal builder -->
            :initial-schema="getInitialSchema(editingRect)"
            @saveSchema="handleSchemaSaved"
            @cancel="cancelSchemaBuilder"
        />

        <!-- Modal Context Menu -->
        <DrawProcessContextMenu
             :visible="contextMenu.visible"
             :top="contextMenu.top"
             :left="contextMenu.left"
             @edit="openSchemaBuilderModalFromContextMenu" <!-- Context menu giờ mở schema builder -->
             @delete="handleDelete"
             ref="contextMenuRef"
         />

         <!-- TODO: Thêm một modal khác nếu cần để *nhập dữ liệu* dựa trên schema đã xây dựng -->

    </div>
</template>

<script setup>
/* eslint-disable */
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { debounce } from 'lodash-es';
// Import các component con cho DrawProcess
import DrawProcessRectangle from './DrawProcessRectangle.vue'; // Đảm bảo tên file đúng
import DrawProcessContextMenu from './DrawProcessContextMenu.vue'; // Đảm bảo tên file đúng
import DynamicProcessEditFormModal from './DynamicProcessEditFormModal.vue'; // Modal Builder Schema
import DrawProcessSaveLoadControls from './DrawProcessSaveLoadControls.vue'; // Đảm bảo tên file đúng

// Import logic schema và types
import { paletteItems, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawProcessSchemas.js';
import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js';

// --- State ---
const isLoading = ref(true);
const loadError = ref(false);
const isSchemaLoading = ref(false); // Loading schema từ XML khi drop
const drawnRectangles = ref([]);
const canvasRef = ref(null);
const defaultRectWidth = 50;
const defaultRectHeight = 50;
const draggingRectId = ref(null);
const currentOrder = ref(1);
const contextMenuRef = ref(null);
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null });
const isSchemaBuilderVisible = ref(false); // State riêng cho modal builder schema
const editingRect = ref(null); // Rect đang được chỉnh sửa schema hoặc data

// --- Computed ---
const sortedRectangles = computed(() => {
    return drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
});

// --- Helpers ---
// Helper này không còn dùng để lấy schema cho modal builder nữa
// const getCachedSchemaForRect = (rect) => {
//     return rect ? getCachedSchemaById(rect.schemaId) : {};
// };

// Helper lấy schema definition hiện có để truyền vào modal builder
const getInitialSchema = (rect) => {
    return rect?.formSchemaDefinition || {};
};

const calculateElbowPoints = (rectA, rectB) => {
    if (!rectA || !rectB) return "";
    let startX, endX;
    const startY = rectA.y + rectA.height / 2;
    const endY = rectB.y + rectB.height / 2;
    if (rectB.x >= rectA.x + rectA.width) {
        startX = rectA.x + rectA.width; endX = rectB.x;
    } else if (rectB.x + rectB.width <= rectA.x) {
        startX = rectA.x; endX = rectB.x + rectB.width;
    } else {
        startX = rectA.x + rectA.width; endX = rectB.x;
    }
    const midX = (startX + endX) / 2;
    return `${startX},${startY} ${midX},${startY} ${midX},${endY} ${endX},${endY}`;
};

// --- Event Handlers ---
const handleWindowChange = debounce(() => {
    if (contextMenu.value.visible) closeContextMenu();
}, 150);

// --- Lifecycle Hooks ---
onMounted(async () => {
    try {
        await loadPaletteData('/process_templates/manifest.json'); // Sử dụng đường dẫn mới
        loadError.value = false;
    } catch (error) {
        console.error("[DrawProcess] Failed to initialize due to palette data loading error:", error);
        loadError.value = true;
    } finally {
        isLoading.value = false;
    }
    window.addEventListener('click', handleClickOutside);
    window.addEventListener('resize', handleWindowChange);
    window.addEventListener('scroll', handleWindowChange, true);
});

onUnmounted(() => {
    window.removeEventListener('click', handleClickOutside);
    window.removeEventListener('resize', handleWindowChange);
    window.removeEventListener('scroll', handleWindowChange, true);
    handleWindowChange.cancel?.();
});

// --- Event Handlers ---

const onStateLoaded = (loadedRectangles) => {
    console.log("[DrawProcess] Received loaded state:", loadedRectangles);
    // Đảm bảo các thuộc tính cần thiết tồn tại khi load state
    drawnRectangles.value = loadedRectangles.map(rect => ({
        ...rect,
        formSchemaDefinition: rect.formSchemaDefinition || {}, // Đảm bảo có formSchemaDefinition
        formData: rect.formData || {} // Đảm bảo có formData
    }));
    currentOrder.value = loadedRectangles.length > 0 ? Math.max(...loadedRectangles.map(r => r.order)) + 1 : 1;
    console.log("[DrawProcess] Canvas state restored. New currentOrder:", currentOrder.value);
    const uniqueSchemaIds = [...new Set(loadedRectangles.map(r => r.schemaId))];
    console.log("[DrawProcess] Pre-loading schemas for IDs:", uniqueSchemaIds);
    uniqueSchemaIds.forEach(id => {
        getOrLoadFormSchema(id).catch(err => { // getOrLoadFormSchema vẫn cần để load schema gốc từ XML nếu cần
            console.error(`[DrawProcess] Failed to pre-load schema ${id} after state load:`, err);
        });
    });
};

const handleClickOutside = (event) => {
    // Đóng context menu
    const contextMenuElement = contextMenuRef.value?.$el || contextMenuRef.value;
    const isClickInsideMenu = contextMenuElement instanceof Element && contextMenuElement.contains(event.target);
    if (contextMenu.value.visible && !isClickInsideMenu) closeContextMenu();

    // Có thể thêm logic đóng modal builder nếu click ra ngoài, nhưng @click.self đã xử lý
};

const showContextMenu = (event, rect) => {
    if (isSchemaBuilderVisible.value) return; // Không mở context menu nếu modal đang mở
    if (contextMenu.value.visible) closeContextMenu();
    event.preventDefault();
    contextMenu.value = { visible: true, top: event.clientY, left: event.clientX, targetRectId: rect.id, targetRectOrder: rect.order };
};

const closeContextMenu = () => {
    if (contextMenu.value.visible) {
        contextMenu.value = { visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null };
    }
};

// Xử lý khi chọn "Xóa" từ context menu
const handleDelete = () => {
    const idToDelete = contextMenu.value.targetRectId;
    closeContextMenu(); // Đóng menu trước
    if (idToDelete !== null) {
        const indexToDelete = drawnRectangles.value.findIndex(r => r.id === idToDelete);
        if (indexToDelete > -1) {
            drawnRectangles.value.splice(indexToDelete, 1);
            // Cập nhật lại thứ tự
            const remainingSorted = drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
            remainingSorted.forEach((rect, index) => { rect.order = index + 1; });
            currentOrder.value = drawnRectangles.value.length + 1;
        }
    }
};

// Mở Modal Builder Schema (có thể gọi từ nhiều nơi)
const openSchemaBuilderModal = (rect) => {
    if (!rect || draggingRectId.value !== null) return;
    closeContextMenu(); // Đóng context menu nếu đang mở
    editingRect.value = rect; // Lưu lại rect đang được chỉnh sửa schema
    isSchemaBuilderVisible.value = true; // Mở modal builder
};

// Hàm gọi từ context menu
const openSchemaBuilderModalFromContextMenu = () => {
     if (contextMenu.value.targetRectId) {
        const rectToEdit = drawnRectangles.value.find(r => r.id === contextMenu.value.targetRectId);
        if (rectToEdit) {
            openSchemaBuilderModal(rectToEdit); // Gọi hàm mở modal chung
        }
    }
    closeContextMenu(); // Đóng context menu sau khi xử lý
};


// Xử lý khi Schema được lưu từ Modal Builder
const handleSchemaSaved = (newSchemaDefinition) => {
    console.log('[DrawProcess] New schema definition saved:', newSchemaDefinition);
    if (editingRect.value) {
        // Lưu schema definition mới vào hình chữ nhật đang chỉnh sửa
        editingRect.value.formSchemaDefinition = newSchemaDefinition;

        // TODO: Cập nhật formData dựa trên schema mới?
        // Ví dụ: Xóa các trường trong formData không còn tồn tại trong schema mới,
        // hoặc thêm các trường mới từ schema với giá trị mặc định.
        // Điều này cần cân nhắc kỹ lưỡng về logic nghiệp vụ.
        // Ví dụ đơn giản: Tạo formData mới hoàn toàn từ schema definition mới
        const newFormData = {};
        for (const key in newSchemaDefinition) {
            newFormData[key] = newSchemaDefinition[key]?.value ?? getDefaultValue(newSchemaDefinition[key]?.type);
        }
         try {
             editingRect.value.formData = structuredClone(newFormData);
             console.log("Updated formData based on new schema:", editingRect.value.formData);
         } catch(e) {
             editingRect.value.formData = JSON.parse(JSON.stringify(newFormData));
             console.warn("Used JSON fallback to update formData based on new schema:", editingRect.value.formData);
         }

    }
    cancelSchemaBuilder(); // Đóng modal builder
};

// Đóng Modal Builder Schema
const cancelSchemaBuilder = () => {
    isSchemaBuilderVisible.value = false;
    editingRect.value = null; // Reset rect đang chỉnh sửa
};

// --- Drag & Drop Handlers ---

const handleSourceDragStart = (event, item) => {
    closeContextMenu();
    const dataToTransfer = { schemaId: item.schemaId, color: item.color, filename: item.filename };
    try {
        event.dataTransfer.setData(SOURCE_ITEM_DATA_TYPE, JSON.stringify(dataToTransfer));
        event.dataTransfer.effectAllowed = 'copy';
        draggingRectId.value = null;
    } catch (e) { console.error("[DrawProcess] Source Drag Start Error:", e, dataToTransfer); }
};

const handleRectDragStart = (event, rect) => {
    if (contextMenu.value.visible) closeContextMenu();
    if (isSchemaBuilderVisible.value) { event.preventDefault(); return; } // Ngăn kéo khi modal mở
    try {
        event.dataTransfer.setData(RECT_ID_DATA_TYPE, rect.id.toString());
        const offsetData = JSON.stringify({ x: event.offsetX, y: event.offsetY });
        event.dataTransfer.setData(DRAG_OFFSET_DATA_TYPE, offsetData);
        event.dataTransfer.effectAllowed = 'move';
        draggingRectId.value = rect.id;
    } catch (e) { console.error("[DrawProcess] Rect Drag Start Error:", e); event.preventDefault(); }
};

const handleRectDragEnd = (event) => {
    draggingRectId.value = null;
};

const handleDragOver = (event) => {
    event.preventDefault();
    if (event.dataTransfer.types.includes(RECT_ID_DATA_TYPE)) event.dataTransfer.dropEffect = "move";
    else if (event.dataTransfer.types.includes(SOURCE_ITEM_DATA_TYPE)) event.dataTransfer.dropEffect = "copy";
    else event.dataTransfer.dropEffect = "none";
};

const handleDrop = async (event) => {
    event.preventDefault();
    closeContextMenu();
    const canvasRect = canvasRef.value?.getBoundingClientRect();
    if (!canvasRect) { console.error('[DrawProcess] Drop Error: Cannot get canvas bounds.'); draggingRectId.value = null; return; }
    const dropX = event.clientX - canvasRect.left;
    const dropY = event.clientY - canvasRect.top;
    const draggedRectIdStr = event.dataTransfer.getData(RECT_ID_DATA_TYPE);

    if (draggedRectIdStr) { // --- MOVE ---
        try {
            const draggedRectId = parseInt(draggedRectIdStr, 10);
            const offsetData = event.dataTransfer.getData(DRAG_OFFSET_DATA_TYPE);
            let offsetX = 0, offsetY = 0;
            try { const offset = JSON.parse(offsetData || '{}'); offsetX = offset.x || 0; offsetY = offset.y || 0; }
            catch (e) { console.warn('[DrawProcess] Could not parse drag offset data:', offsetData, e); }
            const rectToMove = drawnRectangles.value.find(r => r.id === draggedRectId);
            if (rectToMove) { rectToMove.x = dropX - offsetX; rectToMove.y = dropY - offsetY; }
            else { console.error(`[DrawProcess] Move Error: Cannot find rect with ID ${draggedRectId}.`); }
        } catch (e) { console.error("[DrawProcess] Error processing move drop:", e); }
    } else { // --- CREATE NEW ---
        const sourceItemDataStr = event.dataTransfer.getData(SOURCE_ITEM_DATA_TYPE);
        if (sourceItemDataStr) {
            let sourceItemData;
            try {
                sourceItemData = JSON.parse(sourceItemDataStr);
                console.log('[DrawProcess] Handling CREATE NEW for:', sourceItemData);
                isSchemaLoading.value = true;
                let formSchemaDefinitionFromXml = null; // Schema gốc từ XML
                try { formSchemaDefinitionFromXml = await getOrLoadFormSchema(sourceItemData.schemaId); }
                finally { isSchemaLoading.value = false; }

                if (formSchemaDefinitionFromXml === null) {
                     console.error(`[DrawProcess] Failed to load base formSchema for ${sourceItemData.schemaId}. Creating rect with empty schema and data.`);
                     formSchemaDefinitionFromXml = {}; // Dùng schema rỗng nếu load lỗi
                }

                // Tạo formData ban đầu từ giá trị mặc định trong schema XML
                const initialFormDataValues = {};
                for (const key in formSchemaDefinitionFromXml) {
                    initialFormDataValues[key] = formSchemaDefinitionFromXml[key]?.value ?? getDefaultValue(formSchemaDefinitionFromXml[key]?.type);
                }

                let clonedInitialValues;
                 try { clonedInitialValues = structuredClone(initialFormDataValues); }
                 catch(e) { clonedInitialValues = JSON.parse(JSON.stringify(initialFormDataValues)); }

                const newRect = {
                    id: Date.now(),
                    color: sourceItemData.color,
                    schemaId: sourceItemData.schemaId, // Giữ lại để biết nguồn gốc
                    x: dropX - defaultRectWidth / 2,
                    y: dropY - defaultRectHeight / 2,
                    width: defaultRectWidth,
                    height: defaultRectHeight,
                    order: currentOrder.value,
                    // Lưu cả schema definition (có thể chỉnh sửa) và formData (dữ liệu nhập)
                    formSchemaDefinition: structuredClone(formSchemaDefinitionFromXml), // Clone schema gốc từ XML
                    formData: clonedInitialValues // Dữ liệu nhập ban đầu
                };
                drawnRectangles.value.push(newRect);
                currentOrder.value++;
            } catch (e) { console.error("[DrawProcess] Drop Error:", e, sourceItemDataStr); isSchemaLoading.value = false; }
        } else { console.warn('[DrawProcess] Drop Warning: No valid data found.'); }
    }
    draggingRectId.value = null;
};

// Helper lấy giá trị mặc định (cần thiết ở đây nữa)
const getDefaultValue = (type) => {
    switch (type) {
        case 'number': return 0;
        case 'boolean': return false;
        case 'date': return '';
        default: return '';
    }
};

</script>

<style scoped>
/* Style giữ nguyên như trước */
.draw-process-app-container { display: flex; flex-direction: column; }
.draw-process-app { display: flex; gap: 2rem; font-family: sans-serif; }
.controls-container { margin: 1rem auto; width: fit-content; }
.schema-loading-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.7); display: flex; justify-content: center; align-items: center; font-size: 1.2em; color: #333; z-index: 10; }
.loading-indicator, .error-message { padding: 2rem; text-align: center; font-style: italic; color: #666; }
.error-message { color: red; font-weight: bold; }
.palette { border: 1px solid #ccc; padding: 1rem; display: flex; flex-direction: column; align-items: center; gap: 0.5rem; background-color: #f8f8f8; height: fit-content; }
.palette h3 { margin: 0 0 0.5rem 0; font-size: 0.9em; color: #555; }
.source-rect { width: 50px; height: 50px; border: 1px solid #eee; cursor: grab; transition: transform 0.2s ease; }
.source-rect:active { cursor: grabbing; transform: scale(1.1); }
.canvas { border: 2px dashed #007bff; width: 100%; height: 500px; position: relative; background-color: #e9ecef; overflow: hidden; }
.canvas h3 { position: absolute; top: 5px; left: 10px; margin: 0; font-size: 0.9em; color: #6c757d; pointer-events: none; }
.connection-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
</style>
Rate this answer: 

Tùng Giang Lâm
vì sao bạn không rút kinh nghiệm, khi tôi bật devtools hay thay đổi kích thước cửa sổ, tôi không chọn được các hình mẫu và chọn các hình trong canvas


Gemini
Bạn nói đúng, và tôi xin lỗi vì sự bất tiện lặp đi lặp lại này. Việc lựa chọn đối tượng bị hỏng sau khi thay đổi kích thước cửa sổ hoặc mở/đóng DevTools là một vấn đề kinh điển liên quan đến hệ tọa độ và thời điểm tính toán.

Nguyên nhân gốc rễ (Tại sao nó cứ xảy ra):

Thay đổi Layout: Cả việc thay đổi kích thước cửa sổ và việc mở/đóng DevTools đều làm thay đổi kích thước của khung nhìn (viewport) và có thể làm thay đổi vị trí và kích thước của các phần tử trên trang, bao gồm cả phần tử .canvas của bạn.
Hệ Tọa độ:
Tọa độ Sự kiện Chuột (event.clientX, event.clientY): Luôn luôn được tính toán dựa trên khung nhìn (viewport) của trình duyệt.
Tọa độ Hình chữ nhật (rect.x, rect.y): Trong code của bạn, chúng được lưu trữ dưới dạng tọa độ tương đối so với góc trên bên trái của phần tử .canvas.
Vị trí Canvas (canvasRef.value.getBoundingClientRect()): Trả về vị trí và kích thước của phần tử .canvas so với khung nhìn (viewport). Giá trị này thay đổi khi bạn resize hoặc mở/đóng DevTools.
Thời điểm Tính toán: Vấn đề xảy ra khi bạn cố gắng so sánh hoặc sử dụng tọa độ từ các hệ quy chiếu khác nhau mà không thực hiện chuyển đổi dựa trên thông tin layout mới nhất tại thời điểm xảy ra sự kiện (như click chuột).
Tại sao code hiện tại vẫn lỗi (Mặc dù handleDrop có vẻ đúng):

handleDrop: Hàm này hoạt động đúng khi tạo hoặc di chuyển hình chữ nhật vì nó lấy canvasRef.value.getBoundingClientRect() ngay tại thời điểm thả, tính toán dropX, dropY tương đối chính xác cho thao tác thả đó.
Vấn đề nằm ở các tương tác khác (Click, ContextMenu):
showContextMenu: Hàm này hiện đang sử dụng event.clientY, event.clientX để định vị menu. Điều này đúng cho việc hiển thị menu tại con trỏ. Tuy nhiên, nếu bạn có logic ngầm (hoặc dự định thêm) để xác định chính xác hình chữ nhật nào được click chuột phải dựa trên tọa độ click, logic đó có thể đang bị sai.
@open-edit trên DrawProcessRectangle: Sự kiện @click (hoặc sự kiện nào đó kích hoạt open-edit) trên component con DrawProcessRectangle được Vue xử lý. Về lý thuyết, Vue nên biết component nào được click. Tuy nhiên, nếu có sự sai lệch lớn giữa vị trí render thực tế của component (do CSS left, top dựa trên rect.x, rect.y cũ) và vị trí mà trình duyệt/Vue nghĩ rằng nó nên ở đó sau khi layout thay đổi, việc click có thể không "trúng" vào khu vực nhạy cảm của component như mong đợi. Nhưng nguyên nhân chính thường là do logic hit-testing thủ công (nếu có) hoặc việc xử lý tọa độ trong các sự kiện như context menu.
Giải pháp (Rút kinh nghiệm và tập trung vào gốc rễ):

Chúng ta cần đảm bảo rằng bất kỳ lúc nào cần so sánh tọa độ sự kiện chuột (viewport-relative) với vị trí của một hình chữ nhật (canvas-relative), chúng ta phải thực hiện chuyển đổi bằng cách sử dụng getBoundingClientRect() của canvas ngay tại thời điểm sự kiện đó xảy ra.

Sửa đổi cụ thể:

Logic cần sửa đổi nhiều khả năng nằm ở cách bạn xác định hình chữ nhật mục tiêu cho Context Menu hoặc Click trực tiếp (nếu có). Mặc dù DrawProcessCanvas.vue hiện tại không có logic rõ ràng để tìm hình chữ nhật bị click chuột phải (nó chỉ hiển thị menu tại tọa độ chuột), nhưng nếu bạn ngầm hiểu rằng menu đó thuộc về hình chữ nhật nào, hoặc nếu bạn thêm logic click để chọn/mở modal, bạn cần làm như sau:

Ví dụ: Sửa đổi logic tiềm ẩn trong showContextMenu (hoặc một hàm xử lý click tương tự):

javascript
// Bên trong <script setup> của DrawProcessCanvas.vue

const findClickedRect = (clickEvent) => {
    const canvasEl = canvasRef.value;
    if (!canvasEl) return null;

    // 1. Lấy tọa độ click so với viewport
    const clickX_viewport = clickEvent.clientX;
    const clickY_viewport = clickEvent.clientY;

    // 2. Lấy vị trí MỚI NHẤT của canvas so với viewport TẠI THỜI ĐIỂM CLICK
    const canvasRect = canvasEl.getBoundingClientRect();

    // 3. Chuyển đổi tọa độ click thành tọa độ tương đối bên trong canvas
    const clickX_relative = clickX_viewport - canvasRect.left;
    const clickY_relative = clickY_viewport - canvasRect.top;

    console.log(`Click relative to canvas: (${clickX_relative}, ${clickY_relative})`);

    // 4. Tìm hình chữ nhật bị click bằng cách so sánh tọa độ tương đối
    // Duyệt ngược để ưu tiên hình vẽ sau (nằm trên) nếu có chồng lấp
    for (let i = drawnRectangles.value.length - 1; i >= 0; i--) {
        const rect = drawnRectangles.value[i];
        if (
            clickX_relative >= rect.x &&
            clickX_relative <= rect.x + rect.width &&
            clickY_relative >= rect.y &&
            clickY_relative <= rect.y + rect.height
        ) {
            console.log("Clicked on rect:", rect);
            return rect; // Trả về hình chữ nhật được click
        }
    }

    console.log("Clicked on canvas background.");
    return null; // Không click vào hình nào
};

// Sửa đổi showContextMenu để sử dụng logic trên (nếu cần xác định target)
const showContextMenu = (event, rectFromEmit) => { // rectFromEmit là rect được component con emit lên
    if (isSchemaBuilderVisible.value) return;
    if (contextMenu.value.visible) closeContextMenu();
    event.preventDefault();

    // --- PHẦN QUAN TRỌNG ---
    // Nếu bạn cần xác định lại rect bị click thay vì tin tưởng rectFromEmit
    // (ví dụ: nếu sự kiện contextmenu gắn vào canvas thay vì từng rect)
    // const targetRect = findClickedRect(event);
    // if (!targetRect) return; // Không mở menu nếu không click vào hình nào

    // Nếu bạn tin tưởng rectFromEmit (cách hiện tại):
    const targetRect = rectFromEmit;
    // ----------------------

    contextMenu.value = {
        visible: true,
        top: event.clientY, // Vị trí menu vẫn dùng clientY/X
        left: event.clientX,
        targetRectId: targetRect.id,
        targetRectOrder: targetRect.order
    };
};

// Nếu bạn muốn xử lý click trực tiếp để mở modal (thay vì emit từ con)
const handleCanvasClick = (event) => {
    // Đóng context menu nếu đang mở
    if (contextMenu.value.visible) {
        closeContextMenu();
        return; // Chỉ đóng menu, không làm gì khác
    }

    // Nếu modal đang mở, không làm gì
    if (isSchemaBuilderVisible.value) {
        return;
    }

    const clickedRect = findClickedRect(event);
    if (clickedRect) {
        // Mở modal builder cho hình chữ nhật được click
        openSchemaBuilderModal(clickedRect);
    } else {
        // Xử lý click vào nền canvas (ví dụ: bỏ chọn)
        console.log("Canvas background clicked");
    }
};

// Trong onMounted, bạn có thể thêm listener này vào canvas
onMounted(async () => {
    // ... code loadPaletteData ...
    window.addEventListener('click', handleClickOutside);
    window.addEventListener('resize', handleWindowChange);
    window.addEventListener('scroll', handleWindowChange, true);

    // Thêm listener click vào canvas nếu muốn xử lý click trực tiếp
    // canvasRef.value?.addEventListener('click', handleCanvasClick);
});

// Và trong onUnmounted
onUnmounted(() => {
    // ... remove listeners cũ ...
    // canvasRef.value?.removeEventListener('click', handleCanvasClick);
});

Giải thích giải pháp:

Hàm findClickedRect: Hàm này đóng gói logic cốt lõi: lấy tọa độ click viewport, lấy vị trí canvas mới nhất, chuyển đổi tọa độ click sang hệ tọa độ canvas, và sau đó lặp qua các hình chữ nhật để xem tọa độ tương đối đó có nằm trong hình nào không.
Sử dụng trong showContextMenu hoặc handleCanvasClick: Bạn gọi findClickedRect bên trong hàm xử lý sự kiện chuột để đảm bảo getBoundingClientRect() được gọi đúng thời điểm.
Không cần tính toán lại rect.x, rect.y khi resize: Vì rect.x, rect.y đã là tương đối so với canvas, chúng vẫn đúng bên trong canvas. Vấn đề là chuyển đổi tọa độ click cho đúng hệ quy chiếu.
Về việc chọn các hình mẫu (Palette):

Việc kéo thả từ palette (handleSourceDragStart) thường ít bị ảnh hưởng bởi resize vì nó không dựa vào tọa độ phức tạp để bắt đầu kéo. Nếu việc thả vào canvas bị sai, thì logic trong handleDrop (vốn đã lấy getBoundingClientRect mới) có thể có vấn đề khác không liên quan đến resize (ví dụ: lỗi parse dataTransfer). Nếu việc bắt đầu kéo từ palette bị lỗi, hãy kiểm tra xem có CSS nào làm thay đổi vị trí của các source-rect một cách bất thường khi resize/mở DevTools không.

Tóm lại: Vấn đề cốt lõi là sự sai lệch hệ tọa độ khi layout thay đổi. Giải pháp là luôn lấy thông tin vị trí của container (.canvas) tại thời điểm xảy ra sự kiện (click, contextmenu) để chuyển đổi tọa độ sự kiện chuột về hệ tọa độ tương đối của container trước khi so sánh với vị trí lưu trữ của các phần tử con.

Rate this answer: 

Tùng Giang Lâm
hãy viết lại full trang DynamicProcessCanvas


Gemini
Chắc chắn rồi, đây là nội dung đầy đủ cho file src/components/DynamicProcess/DynamicProcessCanvas.vue, đã được cập nhật để tích hợp modal xây dựng schema động (DynamicProcessEditFormModal.vue) và xử lý lưu/tải trạng thái, cùng các chức năng vẽ cơ bản.

vue
<template>
    <!-- Chỉ báo Loading ban đầu -->
    <div v-if="isLoading" class="loading-indicator">
        Đang tải dữ liệu quy trình...
    </div>
    <!-- Thông báo lỗi load ban đầu -->
    <div v-else-if="loadError" class="error-message">
        Lỗi tải dữ liệu quy trình. Vui lòng thử lại.
    </div>

    <!-- Giao diện chính sau khi load xong -->
    <div v-else class="draw-process-app-container">
        <div class="draw-process-app">
            <!-- Palette: Chứa các mẫu kéo thả -->
            <div class="palette">
                <h3>Kéo mẫu quy trình:</h3>
                <!-- Lặp qua các item từ manifest để hiển thị -->
                <div v-for="item in paletteItems" :key="item.schemaId" class="source-rect"
                    :style="{ backgroundColor: item.color }" draggable="true"
                    @dragstart="handleSourceDragStart($event, item)"></div>
            </div>

            <!-- Canvas: Khu vực vẽ chính -->
            <div class="canvas" @dragover.prevent="handleDragOver" @drop.prevent="handleDrop" ref="canvasRef">
                <h3>Thả vào đây để vẽ quy trình:</h3>

                <!-- SVG Layer: Vẽ đường nối -->
                <svg class="connection-lines">
                    <defs>
                        <!-- Định nghĩa mũi tên cho đường nối -->
                        <marker id="proc-arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3"
                            orient="auto-start-reverse" markerUnits="strokeWidth">
                            <path d="M0,0 L8,3 L0,6 Z" fill="#555" />
                        </marker>
                    </defs>
                    <g>
                        <!-- Vẽ đường nối giữa các hình chữ nhật liền kề -->
                        <template v-for="(rect, index) in sortedRectangles" :key="rect.id + '-proc-elbow'">
                            <template v-if="index < sortedRectangles.length - 1">
                                <polyline :points="calculateElbowPoints(rect, sortedRectangles[index + 1])" fill="none"
                                    stroke="#555" stroke-width="1.5" stroke-dasharray="4, 4" marker-end="url(#proc-arrowhead)" />
                            </template>
                        </template>
                    </g>
                </svg>

                <!-- Component Rectangle: Hiển thị các hình chữ nhật đã vẽ -->
                <DrawProcessRectangle
                    v-for="rect in drawnRectangles"
                    :key="rect.id"
                    :rect="rect"
                    :prevent-drag="isSchemaBuilderVisible" <!-- Ngăn kéo khi modal mở -->
                    @dragstart.stop="handleRectDragStart($event, rect)"
                    @dragend="handleRectDragEnd"
                    @contextmenu="showContextMenu($event, rect)"
                    @open-edit="openSchemaBuilderModal" <!-- Click vào hình sẽ mở modal builder -->
                 />

                <!-- Loading Overlay: Hiển thị khi đang load schema từ XML -->
                <div v-if="isSchemaLoading" class="schema-loading-overlay">
                    Đang tải cấu hình...
                </div>
            </div>
        </div>

        <!-- Component Save/Load Controls: Nút Lưu/Tải trạng thái -->
        <DrawProcessSaveLoadControls
            :current-rectangles="drawnRectangles"
            @state-loaded="onStateLoaded"
            class="controls-container"
        />

        <!-- Modal Builder Schema: Component để xây dựng cấu trúc form -->
        <DynamicProcessEditFormModal
            :visible="isSchemaBuilderVisible"
            :initial-schema="getInitialSchema(editingRect)" <!-- Truyền schema hiện có -->
            @saveSchema="handleSchemaSaved" <!-- Lắng nghe sự kiện lưu schema -->
            @cancel="cancelSchemaBuilder" <!-- Lắng nghe sự kiện hủy -->
        />

        <!-- Modal Context Menu: Menu chuột phải -->
        <DrawProcessContextMenu
             :visible="contextMenu.visible"
             :top="contextMenu.top"
             :left="contextMenu.left"
             @edit="openSchemaBuilderModalFromContextMenu" <!-- "Edit" mở modal builder -->
             @delete="handleDelete" <!-- Xử lý xóa -->
             ref="contextMenuRef"
         />

         <!-- TODO: Thêm một modal khác nếu cần để *nhập dữ liệu* thực tế dựa trên schema đã xây dựng -->
         <!-- Ví dụ: <DataEntryModal :visible="isDataEntryVisible" :schema="editingRect?.formSchemaDefinition" :initialData="editingRect?.formData" @save="handleDataSaved" @cancel="cancelDataEntry" /> -->

    </div>
</template>

<script setup>
/* eslint-disable */
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { debounce } from 'lodash-es'; // Thư viện debounce cho resize/scroll

// Import các component con đã được tạo/đổi tên cho DrawProcess
import DrawProcessRectangle from './DrawProcessRectangle.vue';
import DrawProcessContextMenu from './DrawProcessContextMenu.vue';
import DynamicProcessEditFormModal from './DynamicProcessEditFormModal.vue'; // Modal Builder Schema
import DrawProcessSaveLoadControls from './DrawProcessSaveLoadControls.vue';

// Import logic quản lý schema và types
import { paletteItems, getCachedSchemaById, loadPaletteData, getOrLoadFormSchema } from '../../data/drawProcessSchemas.js'; // Sử dụng file schema riêng
import { RECT_ID_DATA_TYPE, DRAG_OFFSET_DATA_TYPE, SOURCE_ITEM_DATA_TYPE } from '../../types/drawingTypes.js'; // Types dùng chung

// --- Component State ---
const isLoading = ref(true); // Trạng thái loading ban đầu (tải manifest)
const loadError = ref(false); // Trạng thái lỗi load ban đầu
const isSchemaLoading = ref(false); // Trạng thái loading schema từ XML khi thả item mới
const drawnRectangles = ref([]); // Mảng chứa dữ liệu các hình chữ nhật đã vẽ trên canvas
const canvasRef = ref(null); // Tham chiếu tới phần tử DOM của canvas
const defaultRectWidth = 50; // Kích thước mặc định
const defaultRectHeight = 50;
const draggingRectId = ref(null); // ID của hình chữ nhật đang được kéo
const currentOrder = ref(1); // Số thứ tự cho hình chữ nhật tiếp theo
const contextMenuRef = ref(null); // Tham chiếu tới component context menu
const contextMenu = ref({ visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null }); // State của context menu
const isSchemaBuilderVisible = ref(false); // State điều khiển hiển thị modal builder schema
const editingRect = ref(null); // Tham chiếu tới hình chữ nhật đang được chỉnh sửa schema hoặc data

// --- Computed Properties ---
// Mảng các hình chữ nhật đã sắp xếp theo thứ tự 'order' để vẽ đường nối
const sortedRectangles = computed(() => {
    // Tạo bản sao và sắp xếp
    return drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
});

// --- Helper Functions ---

// Lấy schema definition hiện có của một hình chữ nhật để truyền vào modal builder
const getInitialSchema = (rect) => {
    // Trả về formSchemaDefinition nếu tồn tại, nếu không trả về object rỗng
    return rect?.formSchemaDefinition || {};
};

// Tính toán các điểm cho đường nối gấp khúc giữa hai hình chữ nhật
const calculateElbowPoints = (rectA, rectB) => {
    if (!rectA || !rectB) return ""; // Trả về chuỗi rỗng nếu thiếu dữ liệu

    let startX, endX;
    const startY = rectA.y + rectA.height / 2; // Điểm giữa cạnh dọc của rect A
    const endY = rectB.y + rectB.height / 2;   // Điểm giữa cạnh dọc của rect B

    // Xác định điểm bắt đầu (startX) và kết thúc (endX) dựa trên vị trí tương đối
    if (rectB.x >= rectA.x + rectA.width) { // Rect B nằm hoàn toàn bên phải Rect A
        startX = rectA.x + rectA.width; // Bắt đầu từ cạnh phải A
        endX = rectB.x;                 // Kết thúc ở cạnh trái B
    } else if (rectB.x + rectB.width <= rectA.x) { // Rect B nằm hoàn toàn bên trái Rect A
        startX = rectA.x;                 // Bắt đầu từ cạnh trái A
        endX = rectB.x + rectB.width;   // Kết thúc ở cạnh phải B
    } else { // Các trường hợp khác (chồng lấp, gần nhau) - mặc định nối từ phải A sang trái B
        startX = rectA.x + rectA.width;
        endX = rectB.x;
    }

    // Tạo chuỗi điểm cho polyline (ngang -> dọc -> ngang)
    const midX = (startX + endX) / 2; // Điểm giữa theo chiều ngang
    return `${startX},${startY} ${midX},${startY} ${midX},${endY} ${endX},${endY}`;
};

// --- Event Handlers ---

// Xử lý sự kiện resize/scroll cửa sổ (đã debounce)
const handleWindowChange = debounce(() => {
    // Đóng context menu nếu đang mở khi resize/scroll
    if (contextMenu.value.visible) closeContextMenu();
}, 150); // Delay 150ms

// --- Lifecycle Hooks ---

// Chạy khi component được mount vào DOM
onMounted(async () => {
    try {
        // Tải dữ liệu cơ bản cho palette từ manifest
        await loadPaletteData('/process_templates/manifest.json'); // Sử dụng đường dẫn mới
        loadError.value = false; // Đặt lại trạng thái lỗi nếu thành công
    } catch (error) {
        console.error("[DrawProcess] Failed to initialize due to palette data loading error:", error);
        loadError.value = true; // Đặt trạng thái lỗi
    } finally {
        isLoading.value = false; // Luôn tắt trạng thái loading
    }
    // Đăng ký các event listener toàn cục
    window.addEventListener('click', handleClickOutside); // Đóng menu/modal khi click ra ngoài
    window.addEventListener('resize', handleWindowChange); // Xử lý resize
    window.addEventListener('scroll', handleWindowChange, true); // Xử lý scroll
});

// Chạy ngay trước khi component bị unmount
onUnmounted(() => {
    // Gỡ bỏ các event listener để tránh memory leak
    window.removeEventListener('click', handleClickOutside);
    window.removeEventListener('resize', handleWindowChange);
    window.removeEventListener('scroll', handleWindowChange, true);
    handleWindowChange.cancel?.(); // Hủy bỏ các lệnh debounce đang chờ (nếu dùng lodash)
});

// --- Component Methods / Event Handlers ---

// Xử lý khi trạng thái được tải từ file (emit từ SaveLoadControls)
const onStateLoaded = (loadedRectangles) => {
    console.log("[DrawProcess] Received loaded state:", loadedRectangles);
    // Đảm bảo các thuộc tính cần thiết tồn tại khi load state
    drawnRectangles.value = loadedRectangles.map(rect => ({
        ...rect,
        formSchemaDefinition: rect.formSchemaDefinition || {}, // Đảm bảo có formSchemaDefinition
        formData: rect.formData || {} // Đảm bảo có formData
    }));
    // Cập nhật lại số thứ tự tiếp theo
    currentOrder.value = loadedRectangles.length > 0 ? Math.max(...loadedRectangles.map(r => r.order)) + 1 : 1;
    console.log("[DrawProcess] Canvas state restored. New currentOrder:", currentOrder.value);

    // Tùy chọn: Pre-load schema gốc từ XML vào cache để tăng tốc độ mở modal sau này
    const uniqueSchemaIds = [...new Set(loadedRectangles.map(r => r.schemaId))];
    console.log("[DrawProcess] Pre-loading schemas for IDs:", uniqueSchemaIds);
    uniqueSchemaIds.forEach(id => {
        getOrLoadFormSchema(id).catch(err => {
            console.error(`[DrawProcess] Failed to pre-load schema ${id} after state load:`, err);
        });
    });
};

// Xử lý click ra ngoài để đóng context menu
const handleClickOutside = (event) => {
    const contextMenuElement = contextMenuRef.value?.$el || contextMenuRef.value;
    // Kiểm tra xem click có nằm trong context menu không
    const isClickInsideMenu = contextMenuElement instanceof Element && contextMenuElement.contains(event.target);
    if (contextMenu.value.visible && !isClickInsideMenu) {
        closeContextMenu();
    }
    // Lưu ý: Modal builder đã có @click.self để tự đóng khi click overlay
};

// Hiển thị context menu tại vị trí chuột phải
const showContextMenu = (event, rect) => {
    if (isSchemaBuilderVisible.value) return; // Không mở nếu modal builder đang hiển thị
    if (contextMenu.value.visible) closeContextMenu(); // Đóng menu cũ nếu có
    event.preventDefault(); // Ngăn menu mặc định của trình duyệt
    // Cập nhật state của context menu
    contextMenu.value = {
        visible: true,
        top: event.clientY,
        left: event.clientX,
        targetRectId: rect.id,
        targetRectOrder: rect.order
    };
};

// Đóng context menu
const closeContextMenu = () => {
    if (contextMenu.value.visible) {
        // Reset state context menu
        contextMenu.value = { visible: false, top: 0, left: 0, targetRectId: null, targetRectOrder: null };
    }
};

// Xử lý sự kiện "Xóa" từ context menu
const handleDelete = () => {
    const idToDelete = contextMenu.value.targetRectId;
    closeContextMenu(); // Đóng menu trước
    if (idToDelete !== null) {
        const indexToDelete = drawnRectangles.value.findIndex(r => r.id === idToDelete);
        if (indexToDelete > -1) {
            // Xóa hình chữ nhật khỏi mảng
            drawnRectangles.value.splice(indexToDelete, 1);
            // Cập nhật lại thứ tự các hình còn lại
            const remainingSorted = drawnRectangles.value.slice().sort((a, b) => a.order - b.order);
            remainingSorted.forEach((rect, index) => { rect.order = index + 1; });
            // Cập nhật số thứ tự tiếp theo
            currentOrder.value = drawnRectangles.value.length + 1;
            console.log(`[DrawProcess] Deleted rect ID: ${idToDelete}. Order updated.`);
        }
    }
};

// Mở Modal Builder Schema (chung)
const openSchemaBuilderModal = (rect) => {
    if (!rect || draggingRectId.value !== null) return; // Kiểm tra điều kiện hợp lệ
    closeContextMenu(); // Đóng context menu nếu đang mở
    editingRect.value = rect; // Lưu lại hình chữ nhật đang được chỉnh sửa
    isSchemaBuilderVisible.value = true; // Hiển thị modal builder
    console.log(`[DrawProcess] Opening schema builder for rect ID: ${rect.id}`);
};

// Xử lý sự kiện "Edit" từ context menu để mở modal builder
const openSchemaBuilderModalFromContextMenu = () => {
     if (contextMenu.value.targetRectId) {
        // Tìm hình chữ nhật tương ứng trong mảng
        const rectToEdit = drawnRectangles.value.find(r => r.id === contextMenu.value.targetRectId);
        if (rectToEdit) {
            openSchemaBuilderModal(rectToEdit); // Gọi hàm mở modal chung
        }
    }
    closeContextMenu(); // Luôn đóng context menu sau khi xử lý
};

// Xử lý khi schema được lưu từ Modal Builder (sự kiện @saveSchema)
const handleSchemaSaved = (newSchemaDefinition) => {
    console.log('[DrawProcess] Received new schema definition:', newSchemaDefinition);
    if (editingRect.value) {
        // 1. Cập nhật schema definition cho hình chữ nhật đang chỉnh sửa
        editingRect.value.formSchemaDefinition = newSchemaDefinition;

        // 2. Cập nhật formData dựa trên schema mới (reset về giá trị mặc định)
        const newFormData = {};
        for (const key in newSchemaDefinition) {
            // Lấy giá trị mặc định từ schema definition mới
            newFormData[key] = newSchemaDefinition[key]?.value ?? getDefaultValue(newSchemaDefinition[key]?.type);
        }
         try {
             // Gán lại formData bằng bản sao sâu của dữ liệu mới
             editingRect.value.formData = structuredClone(newFormData);
             console.log("[DrawProcess] Updated formData based on new schema:", editingRect.value.formData);
         } catch(e) {
             // Fallback nếu structuredClone lỗi
             editingRect.value.formData = JSON.parse(JSON.stringify(newFormData));
             console.warn("[DrawProcess] Used JSON fallback to update formData based on new schema:", editingRect.value.formData);
         }
    }
    cancelSchemaBuilder(); // Đóng modal builder sau khi lưu
};

// Đóng Modal Builder Schema và reset trạng thái
const cancelSchemaBuilder = () => {
    isSchemaBuilderVisible.value = false;
    editingRect.value = null; // Reset hình chữ nhật đang chỉnh sửa
    console.log("[DrawProcess] Schema builder cancelled/closed.");
};

// --- Drag & Drop Handlers ---

// Bắt đầu kéo từ Palette
const handleSourceDragStart = (event, item) => {
    closeContextMenu(); // Đóng menu nếu đang mở
    // Chuẩn bị dữ liệu cần truyền (schemaId, color, filename)
    const dataToTransfer = { schemaId: item.schemaId, color: item.color, filename: item.filename };
    try {
        // Đặt dữ liệu vào dataTransfer dưới dạng chuỗi JSON
        event.dataTransfer.setData(SOURCE_ITEM_DATA_TYPE, JSON.stringify(dataToTransfer));
        event.dataTransfer.effectAllowed = 'copy'; // Cho phép sao chép
        draggingRectId.value = null; // Đảm bảo không có rect nào đang được kéo
    } catch (e) { console.error("[DrawProcess] Source Drag Start Error:", e, dataToTransfer); }
};

// Bắt đầu kéo một hình chữ nhật đã có trên canvas
const handleRectDragStart = (event, rect) => {
    if (contextMenu.value.visible) closeContextMenu(); // Đóng menu
    if (isSchemaBuilderVisible.value) { event.preventDefault(); return; } // Ngăn kéo khi modal mở
    try {
        // Đặt ID của rect vào dataTransfer
        event.dataTransfer.setData(RECT_ID_DATA_TYPE, rect.id.toString());
        // Tính và đặt offset của chuột bên trong rect
        const offsetData = JSON.stringify({ x: event.offsetX, y: event.offsetY });
        event.dataTransfer.setData(DRAG_OFFSET_DATA_TYPE, offsetData);
        event.dataTransfer.effectAllowed = 'move'; // Cho phép di chuyển
        draggingRectId.value = rect.id; // Lưu ID đang kéo
    } catch (e) { console.error("[DrawProcess] Rect Drag Start Error:", e); event.preventDefault(); }
};

// Kết thúc kéo một hình chữ nhật trên canvas
const handleRectDragEnd = (event) => {
    draggingRectId.value = null; // Reset ID đang kéo
};

// Xử lý khi kéo qua canvas (cần để cho phép drop)
const handleDragOver = (event) => {
    event.preventDefault(); // Quan trọng: Ngăn hành vi mặc định để cho phép drop
    // Xác định loại thao tác dựa trên dữ liệu đang kéo
    if (event.dataTransfer.types.includes(RECT_ID_DATA_TYPE)) event.dataTransfer.dropEffect = "move";
    else if (event.dataTransfer.types.includes(SOURCE_ITEM_DATA_TYPE)) event.dataTransfer.dropEffect = "copy";
    else event.dataTransfer.dropEffect = "none"; // Không cho phép thả loại khác
};

// Xử lý khi thả vào canvas
const handleDrop = async (event) => {
    event.preventDefault(); // Ngăn hành vi mặc định (ví dụ: mở file)
    closeContextMenu(); // Đóng menu nếu đang mở

    // Lấy vị trí và kích thước MỚI NHẤT của canvas tại thời điểm thả
    const canvasRect = canvasRef.value?.getBoundingClientRect();
    if (!canvasRect) { console.error('[DrawProcess] Drop Error: Cannot get canvas bounds.'); draggingRectId.value = null; return; }

    // Tính tọa độ thả tương đối so với canvas
    const dropX = event.clientX - canvasRect.left;
    const dropY = event.clientY - canvasRect.top;

    // Lấy dữ liệu từ dataTransfer
    const draggedRectIdStr = event.dataTransfer.getData(RECT_ID_DATA_TYPE);

    // --- Xử lý DI CHUYỂN hình chữ nhật hiện có ---
    if (draggedRectIdStr) {
        try {
            const draggedRectId = parseInt(draggedRectIdStr, 10);
            const offsetData = event.dataTransfer.getData(DRAG_OFFSET_DATA_TYPE);
            let offsetX = 0, offsetY = 0;
            // Parse offset, có fallback nếu lỗi
            try { const offset = JSON.parse(offsetData || '{}'); offsetX = offset.x || 0; offsetY = offset.y || 0; }
            catch (e) { console.warn('[DrawProcess] Could not parse drag offset data:', offsetData, e); }
            // Tìm hình chữ nhật cần di chuyển
            const rectToMove = drawnRectangles.value.find(r => r.id === draggedRectId);
            if (rectToMove) {
                // Cập nhật tọa độ mới dựa trên điểm thả và offset
                rectToMove.x = dropX - offsetX;
                rectToMove.y = dropY - offsetY;
                console.log(`[DrawProcess] Moved rect ID ${draggedRectId} to (${rectToMove.x}, ${rectToMove.y})`);
            } else { console.error(`[DrawProcess] Move Error: Cannot find rect with ID ${draggedRectId}.`); }
        } catch (e) { console.error("[DrawProcess] Error processing move drop:", e); }
    }
    // --- Xử lý TẠO MỚI hình chữ nhật từ palette ---
    else {
        const sourceItemDataStr = event.dataTransfer.getData(SOURCE_ITEM_DATA_TYPE);
        if (sourceItemDataStr) {
            let sourceItemData;
            try {
                sourceItemData = JSON.parse(sourceItemDataStr);
                console.log('[DrawProcess] Handling CREATE NEW for:', sourceItemData);

                // Bắt đầu loading schema gốc từ XML
                isSchemaLoading.value = true;
                let formSchemaDefinitionFromXml = null;
                try {
                    // Load schema gốc (có thể từ cache hoặc fetch)
                    formSchemaDefinitionFromXml = await getOrLoadFormSchema(sourceItemData.schemaId);
                } finally {
                    isSchemaLoading.value = false; // Kết thúc loading
                }

                // Xử lý nếu load schema gốc lỗi
                if (formSchemaDefinitionFromXml === null) {
                     console.error(`[DrawProcess] Failed to load base formSchema for ${sourceItemData.schemaId}. Creating rect with empty schema and data.`);
                     formSchemaDefinitionFromXml = {}; // Sử dụng schema rỗng
                }

                // Tạo formData ban đầu từ giá trị mặc định trong schema gốc
                const initialFormDataValues = {};
                for (const key in formSchemaDefinitionFromXml) {
                    initialFormDataValues[key] = formSchemaDefinitionFromXml[key]?.value ?? getDefaultValue(formSchemaDefinitionFromXml[key]?.type);
                }

                // Clone dữ liệu ban đầu và schema gốc để tránh tham chiếu
                let clonedInitialValues;
                let clonedSchemaDefinition;
                 try {
                    clonedInitialValues = structuredClone(initialFormDataValues);
                    clonedSchemaDefinition = structuredClone(formSchemaDefinitionFromXml);
                 } catch(e) {
                    clonedInitialValues = JSON.parse(JSON.stringify(initialFormDataValues));
                    clonedSchemaDefinition = JSON.parse(JSON.stringify(formSchemaDefinitionFromXml));
                    console.warn("[DrawProcess] Used JSON fallback for cloning initial data/schema.");
                 }

                // Tạo đối tượng hình chữ nhật mới
                const newRect = {
                    id: Date.now(), // ID duy nhất
                    color: sourceItemData.color,
                    schemaId: sourceItemData.schemaId, // Giữ lại để biết nguồn gốc
                    x: dropX - defaultRectWidth / 2, // Căn giữa vào điểm thả
                    y: dropY - defaultRectHeight / 2,
                    width: defaultRectWidth,
                    height: defaultRectHeight,
                    order: currentOrder.value, // Gán thứ tự hiện tại
                    formSchemaDefinition: clonedSchemaDefinition, // Lưu schema definition (có thể sửa sau)
                    formData: clonedInitialValues // Lưu dữ liệu nhập ban đầu
                };
                // Thêm hình mới vào mảng
                drawnRectangles.value.push(newRect);
                // Tăng số thứ tự cho lần thả tiếp theo
                currentOrder.value++;
                console.log("[DrawProcess] Created new rect:", newRect);

            } catch (e) {
                console.error("[DrawProcess] Drop Error (Create New):", e, sourceItemDataStr);
                isSchemaLoading.value = false; // Đảm bảo tắt loading nếu có lỗi
            }
        } else {
            // Trường hợp không có dữ liệu hợp lệ nào được thả
            console.warn('[DrawProcess] Drop Warning: No valid data (RECT_ID or SOURCE_ITEM) found.');
        }
    }
    // Luôn reset ID đang kéo sau khi xử lý xong drop
    draggingRectId.value = null;
};

// Helper lấy giá trị mặc định (cần thiết ở đây cho handleDrop)
const getDefaultValue = (type) => {
    switch (type) {
        case 'number': return 0;
        case 'boolean': return false;
        case 'date': return ''; // Hoặc null
        default: return '';
    }
};

</script>

<style scoped>
/* Style giữ nguyên như các phiên bản trước */
.draw-process-app-container { display: flex; flex-direction: column; }
.draw-process-app { display: flex; gap: 2rem; font-family: sans-serif; }
.controls-container { margin: 1rem auto; width: fit-content; }
.schema-loading-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.7); display: flex; justify-content: center; align-items: center; font-size: 1.2em; color: #333; z-index: 10; }
.loading-indicator, .error-message { padding: 2rem; text-align: center; font-style: italic; color: #666; }
.error-message { color: red; font-weight: bold; }
.palette { border: 1px solid #ccc; padding: 1rem; display: flex; flex-direction: column; align-items: center; gap: 0.5rem; background-color: #f8f8f8; height: fit-content; }
.palette h3 { margin: 0 0 0.5rem 0; font-size: 0.9em; color: #555; }
.source-rect { width: 50px; height: 50px; border: 1px solid #eee; cursor: grab; transition: transform 0.2s ease; }
.source-rect:active { cursor: grabbing; transform: scale(1.1); }
.canvas { border: 2px dashed #007bff; width: 100%; height: 500px; position: relative; background-color: #e9ecef; overflow: hidden; }
.canvas h3 { position: absolute; top: 5px; left: 10px; margin: 0; font-size: 0.9em; color: #6c757d; pointer-events: none; }
.connection-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
</style>
Rate this answer: 

Tùng Giang Lâm
Hãy tạo 1 file tương tự DynamicProcessEditFormModal, tuy nhiên trong các mẫu nhập liệu có một kiểu dữ liệu tham chiếu. Hãy tạo các ví dụ file dữ liệu XML về Employee, Customer, DocumentType tương ứng với các tham chiếu khác nhau. Có thể chọn ô nhập liệu kiểu tham chiếu nào đó để định nghĩa form. Hãy thêm form đó, chỉnh sửa Context Menu để thêm 1 kiểu định nghĩa

